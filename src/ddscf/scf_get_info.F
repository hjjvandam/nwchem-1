      block data cscfdata
      implicit none
#include "cscf.fh"
c
      data oinitialized /.false./
      data g_movecs /0,0/
      data k_occ /10000000/
      data k_eval /10000000/
c
      end
      subroutine scf_init(rtdb)
      implicit none
#include "mafdecls.fh"
#include "global.fh"
#include "bas.fh"
#include "geom.fh"
#include "rtdb.fh"
#include "inp.fh"
#include "sym.fh"
#include "util.fh"
#include "cscf.fh"
c     
      integer rtdb              ! database handle
c     
      double precision nuclear_charge
      character*255 name
      integer len_occ
      external cscfdata ! For T3D linker
c
      if (.not. rtdb_cget(rtdb, 'title', 1, title))
     $     title = ' '
c
c     load geometry and symmetry info
c
      if (.not. geom_create(geom, 'geometry'))
     $     call errquit('scf_init: geom_create?', 0)
      if (.not. geom_rtdb_load(rtdb, geom, 'geometry'))
     $     call errquit('scf_init: no geometry ', 0)
      if (.not.rtdb_get(rtdb, 'scf:skeleton',MT_LOG, 1, oskel)) then
         oskel = sym_number_ops(geom) .gt. 0
      endif
      if (.not.rtdb_get(rtdb, 'scf:adapt',MT_LOG, 1, oadapt)) then
         oadapt = sym_number_ops(geom) .gt. 0
      endif
      if (.not.rtdb_get(rtdb, 'scf:lock',MT_LOG, 1, olock)) then
         olock = .false.
      endif
c     
c     load the basis set and get info about it
c
      if (.not. bas_create(basis, 'mo basis'))
     $     call errquit('scf_init: bas_create?', 0)
      if (.not. bas_rtdb_load(rtdb, geom, basis, 'ao basis')) then
         if (.not. bas_rtdb_load(rtdb, geom, basis, 'mo basis'))
     $        call errquit('scf_init: no mo or ao basis set', 0)
      end if
      if (.not. bas_name(basis, name, trans))
     $     call errquit('scf_init: bas_name?', 0)
c
      if (.not. bas_numbf(basis, nbf)) call errquit
     $     ('scf_init: basis info',0)
c
c   DIIS toggle
c
      if (.not.rtdb_get(rtdb, 'scf:diis',MT_LOG, 1, odiis))
     $   odiis = .false.
c
c     is RI approximation to be used?
c
      if (rtdb_get(rtdb, 'scf:ri', MT_INT, 1, nriscf)) then
        if (.not. bas_create(riscf_basis, 'riscf basis'))
     $       call errquit('scf_init: bas_create?', 0)
        if (.not. bas_rtdb_load(rtdb, geom, riscf_basis, 'riscf basis'))
     $       call errquit('scf_init: no riscf basis set', 0)
      else
        nriscf = 0
        riscf_basis = 0
      endif

c
c     Figure input/output MO vectors ... all this should be
c     context sensitive but that design is incomplete.
c     
      if (.not. rtdb_cget(rtdb, 'scf:input vectors', 1, movecs_in))
     $     movecs_in = 'atomic'
      if (.not. rtdb_cget(rtdb, 'scf:output vectors', 1, movecs_out))
     $     movecs_out = ' '
      if (movecs_out.eq.' ') then
         if (movecs_in.eq.'atomic' .or. movecs_in.eq.'hcore' .or. 
     $        movecs_in.eq.'project') then
            call util_file_name('movecs', .false.,.false.,movecs_out)
         else
            movecs_out = movecs_in
         endif
      endif
c
c  Dump lagrangian?
c
      if (.not.rtdb_get(rtdb, 'scf:lagrangian',MT_LOG, 1, olagr))
     $   olagr = .false.
c     
c     Figure out the number of electrons from the required total
c     charge and the sum of nuclear charges
c     
      if (.not. rtdb_get(rtdb, 'charge', MT_DBL, 1, charge))
     $     charge = 0.0d0
      if (.not. geom_nuc_charge(geom, nuclear_charge))
     $     call errquit('scf: geom_nuc_charge failed', 0)
      nelec = nint(nuclear_charge - charge)
      if (nelec .le. 0) call errquit
     $     ('scf: negative no. of electrons ?', nelec)
      if (abs(nuclear_charge - charge - dble(nelec)) .gt. 1d-8)
     $     call errquit('scf: non-integral no. of electrons ?', 0)
c     
c     Determine no. of open and closed shells ... default is to run closed
c     shell unless told otherwise
c     
      if (.not. rtdb_get(rtdb, 'scf:nopen', MT_INT, 1, nopen))
     $     nopen = 0
      if (nopen .gt. nelec) call errquit
     $     ('scf: nopen > nelec ', nopen)
      if (mod(nelec-nopen,2) .ne. 0) call errquit
     $     ('scf: no. of closed-shell electrons is not even!',nopen)
      nclosed = (nelec-nopen) / 2
c     
      if (.not. rtdb_cget(rtdb, 'scf:scftype', 1, scftype)) then
         if (nopen .eq. 0) then
            scftype = 'RHF'
         else
            scftype = 'ROHF'
         endif
      endif
      call inp_ucase(scftype)
c
      if ( scftype.ne.'ROHF' .and. scftype.ne.'RHF' .and.
     $     scftype.ne.'UHF' ) call errquit
     $     ('scf: only ROHF, RHF, and UHF currently supported', 0)
c
      nalpha = nclosed + nopen
      nbeta  = nclosed
c
c     For now set NMO = NBF, however this may change later just
c     when the dependency analysis is done just before the starting guess
c
      nmo = nbf
c
c     Store the derived info in the database for other wavefunction
c     modules and/or restart to access
c
      if (.not. rtdb_cput(rtdb, 'scf:scftype', 1, scftype)) 
     $     call errquit('scf_init: put of scftyp failed',0)
      if (.not. rtdb_put(rtdb, 'scf:nopen', MT_INT, 1, nopen))
     $     call errquit('scf_init: put of nopen failed',0)
      if (.not. rtdb_put(rtdb, 'scf:nclosed', MT_INT, 1, nclosed))
     $     call errquit('scf_init: put of nclosed failed',0)
      if (.not. rtdb_put(rtdb, 'scf:nelec', MT_INT, 1, nelec))
     $     call errquit('scf_init: put of nelec failed',0)
      if (.not. rtdb_put(rtdb, 'scf:nmo', MT_INT, 1, nmo))
     $     call errquit('scf_init: put of nmo failed',0)
      if (scftype .eq. 'UHF') then
         if (.not. rtdb_put(rtdb, 'scf:nalpha', MT_INT, 1, nalpha))
     $        call errquit('scf_init: put of nalpha failed',0)
         if (.not. rtdb_put(rtdb, 'scf:nbeta', MT_INT, 1, nbeta))
     $        call errquit('scf_init: put of nbeta failed',0)
      endif
c     
c     Allocate persistent local and global arrays ... these may
c     be reallocated later when the dependency analysis is done
c
      if (scftype .eq. 'UHF') then
         if (.not. ga_create(MT_DBL, nbf, nmo, 'scf_init: alpha MOs',
     $        1, 1, g_movecs)) call errquit('scf_init: alpha MOs', 0)
         if (.not. ga_create(MT_DBL, nbf, nmo, 'scf_init: beta MOs',
     $        1, 1, g_movecs(2))) call errquit('scf_init: beta MOs', 0)
      else
         if (.not. ga_create(MT_DBL, nbf, nmo, 'scf_init: MOs',
     $        1, 1, g_movecs)) call errquit('scf_init: MOs', 0)
      endif
c     
      len_occ = nmo
      if (scftype .eq. 'UHF') len_occ = nbf * 2
      if (.not. ma_push_get(mt_dbl, len_occ, 'scf_init: mo evals',
     $     l_eval, k_eval)) call errquit
     $     ('rihf_init: insufficient memory?', len_occ)
c     
      if (.not. ma_push_get(mt_dbl, len_occ, 'scf_init: mo occ',
     $     l_occ, k_occ)) call errquit
     $     ('rihf_init: insufficient memory?', len_occ)
c
c     Fill in the SCF convergence info
c     
      call scf_get_conv_info(rtdb)
      call scf_get_fock_param(rtdb, tol2e)
c
      oinitialized = .true.
c     
      end
      subroutine scf_get_conv_info(rtdb)
C$Id: scf_get_info.F,v 1.28 1996-07-17 16:29:32 d3g681 Exp $
      implicit none
#include "mafdecls.fh"
#include "global.fh"
#include "rtdb.fh"
#include "cscf.fh"
c     
      integer rtdb
c
      double precision mone
      parameter (mone = -1.0d0)
c     
      ouser_changed_conv = .false.
c
      if (.not. rtdb_get(rtdb, 'scf:maxiter', MT_INT, 1, maxiter)) then
         if (scftype .ne. 'UHF') then
            maxiter = 8
         else
            maxiter = 20        ! UHF not yet QC
         endif
      endif
      if (.not.rtdb_get(rtdb, 'scf:thresh',
     $     MT_DBL, 1, gnorm_tol)) gnorm_tol = 1.d-4
c
c     Ensure that the default integral selection is sufficient
c     for the request accuracy of the SCF.  However, allow user override.
c
      if (.not. rtdb_get(rtdb, 'scf:tol2e', MT_DBL, 1, tol2e)) then
	 tol2e = min(1.0d-7,gnorm_tol*1d-2)
      endif
c
      if (rtdb_get(rtdb, 'scf:level shift info', MT_DBL, 6,shifts))then
         ouser_changed_conv = .true.
      else
         call dfill(6, mone, shifts, 1)
      endif
      if (rtdb_get(rtdb, 'scf:full hessian switch', MT_DBL, 1, 
     $     nr_gswitch)) then
         ouser_changed_conv = .true.
      else 
         nr_gswitch = 0.1d0
      endif
c
c     Apply defaults
c
      if (shifts(1) .eq. -1.0d0) shifts(1) = 5.0d0
      if (shifts(2) .eq. -1.0d0) shifts(2) = 0.5d0
      if (shifts(3) .eq. -1.0d0) shifts(3) = 0.0d0
      if (shifts(4) .eq. -1.0d0) shifts(4) = 0.0d0
      if (shifts(5) .eq. -1.0d0) shifts(5) = 0.0d0
      if (shifts(6) .eq. -1.0d0) shifts(6) = 0.0d0
c
      end
      subroutine scf_get_fock_param(rtdb, tol2e)
      implicit none
#include "mafdecls.fh"
#include "rtdb.fh"
#include "cfock.fh"
#include "global.fh"
#include "util.fh"
      integer rtdb
      double precision tol2e
c
      integer chunktmp
      logical orestart
      logical int2e_file_open
      external int2e_file_open
c
c     Load balancing information
c
      if (rtdb_get(rtdb, 'scf:task_bf',
     $     MT_INT, 1, chunktmp)) then
         task_bf = chunktmp
      endif
c
c     Integral caching/file information
c
      if (.not. rtdb_get(rtdb, 'int2e:filesize',
     $     MT_INT, 1, filesize)) filesize = 0
      if (.not. rtdb_get(rtdb, 'int2e:memsize',
     $     MT_INT, 1, memsize)) memsize = 0
      if (.not. rtdb_get(rtdb, 'int2e:restart',
     $     MT_LOG, 1, orestart)) orestart = .false.
c
c     The opening routine will put the .pid on the integral filename
c     (hence even tho' parallel file, open as sequential)
c
      if (.not. rtdb_cget(rtdb, 'int2e:filename', 1, int2efilename)) 
     $     call util_file_name('aoints',.true.,.false.,int2efilename)
c
      oreadfile = .false.
      owritefile= .false.
c
      if (filesize.gt.0 .or. memsize.gt.0) then
         if (.not. int2e_file_open(int2efilename, memsize, filesize,
     $        tol2e*0.1d0, orestart))
     $        call errquit('get_fock_param: opening aoints?', 0)
         if (orestart) then
            oreadfile = .true.
         else
            owritefile = .true.
         endif
      endif
c
c     Blocking integral interface
c
      if (.not. rtdb_get(rtdb, 'fock:maxquartet',
     $     MT_INT, 1, maxquartet)) maxquartet = 10000
      if (.not. rtdb_get(rtdb, 'fock:maxpair',
     $     MT_INT, 1, maxquartet)) maxpair = sqrt(dble(maxquartet))
      if (.not. rtdb_get(rtdb, 'fock:maxeri',
     $     MT_INT, 1, maxeri)) maxeri = 1296*100 ! 100 d(6) quartets
      if (.not. rtdb_get(rtdb, 'fock:maxscr',
     $     MT_INT, 1, maxscr)) maxscr = 0 ! <=0 implies use texas estimate
      if (.not. rtdb_get(rtdb, 'fock:intacc',
     $     MT_DBL, 1, intacc)) intacc = 0.0d0 ! Default is variable
c
      if (.not. rtdb_get(rtdb, 'fock:replicated',
     $     mt_log, 1, oreplicated)) oreplicated = .true.
      if (.not. rtdb_get(rtdb, 'fock:noblock',
     $     mt_log, 1, onoblock)) onoblock = .false.
c
c  Use labels by default
c
      if (.not. rtdb_get( rtdb, 'fock:uselabels',  MT_LOG, 1,
     $                    oerilabel)) oerilabel = .true.
c
      if (ga_nodeid().eq.0 .and.
     $     util_print('information',print_high)) then
         write(6,2) task_bf, maxquartet, maxeri, maxscr, intacc
 2       format(/
     $        ' Setting fock-build task_bf   :', i8/
     $        '                    maxquartet:', i8/
     $        '                    maxeri    :', i8/
     $        '                    maxscr    :', i8/
     $        '                    intacc    :', 1p,d8.1/)
         call util_flush(6)
      endif
c
      end
      subroutine scf_tidy(rtdb)
      implicit none
#include "cscf.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "geom.fh"
#include "bas.fh"
#include "cfock.fh"
      integer rtdb
c
      logical status
      logical int2e_file_close
      external int2e_file_close
c
      if (oinitialized) then
         if (.not. geom_destroy(geom)) call errquit
     $        ('scf_tidy: geom destroy failed', 0)
         if (.not. bas_destroy(basis)) call errquit
     $        ('scf_tidy: basis destroy failed',0)
         status = ma_pop_stack(l_occ)
         status = ma_pop_stack(l_eval) .and. status
         if (.not. status) call errquit
     $        ('scf_tidy: failed to free occupation/evals',0)
         if (.not. ga_destroy(g_movecs)) call errquit
     $        ('scf_tidy: failed to free movecs',0)
         if (scftype .eq. 'UHF') then
            if (.not. ga_destroy(g_movecs(2))) call errquit
     $           ('scf_tidy: failed to free beta movecs',0)
         endif
c
         oinitialized = .false.
c
      endif
c
      if (filesize.gt.0 .or. memsize.gt.0) then
         if (.not. int2e_file_close())
     $        call errquit('scf_tidy: closing aoints?', 0)
      endif
c
      end
