      logical function int_norm_2c(basisin)
c $Id: int_norm_2c.F,v 1.2 1996-01-22 21:48:56 d3e129 Exp $
c::assumptions
*..   MA_init has been called
c
      implicit none
#include "bas.fh"
#include "basP.fh"
#include "basdeclsP.fh"
#include "mafdecls.fh"
#include "bas_exndcf_dec.fh"
      integer basisin             ! [input] basis handle
      integer basis, nucont, iucont, type, nprim, ngen, ept, cpt, igen
      integer maxg2c, mem2c, lscr, h_scr, i_scr, maxang
c
#include "bas_exndcf_sfn.fh"
c
c     Normalize the contraction coefficients in this basis.
c     Eventually we need to store both the normalized and unnormalized
c     coefficients so that the user can print out something recognizable
c
      int_norm_2c = bas_check_handle(basisin, 'int_norm_2c')
      if (.not. int_norm_2c) return
c
c...  get memory requirements for one electron integrals
c
      call emem_2e2c(basisin, basisin, maxg2c, mem2c)
      lscr = maxg2c + mem2c
      int_norm_2c =
     &    MA_push_get(mt_dbl,lscr,'int_norm_2c:scr',h_scr,i_scr)
c
c... define xyz for angular momentum      
      if (.not.bas_high_angular(basisin,maxang)) call errquit
     &    ('int_norm_2c: bas_high_angular failed?',911)
      call defNxyz(maxang)
c
      basis = basisin + BASIS_HANDLE_OFFSET
c
      nucont = infbs_head(HEAD_NCONT,basis)
      do iucont = 1, nucont
         type  = infbs_cont(CONT_TYPE, iucont,basis)
         nprim = infbs_cont(CONT_NPRIM,iucont,basis) 
         ngen  = infbs_cont(CONT_NGEN, iucont,basis)
         ept   = infbs_cont(CONT_IEXP, iucont,basis)
         cpt   = infbs_cont(CONT_ICFP, iucont,basis)
         if (type .ge. 0) then
            do igen = 0,ngen-1
              call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &              dbl_mb(mb_exndcf(cpt+igen*nprim,basis)),
     &              type, nprim, dbl_mb(i_scr), lscr)
            enddo
c....... sp
         else if (type .eq. -1) then
            call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &           dbl_mb(mb_exndcf(cpt, basis)), 
     &           0, nprim, dbl_mb(i_scr), lscr)
            call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &            dbl_mb(mb_exndcf(cpt+nprim,basis)),
     &           1, nprim, dbl_mb(i_scr), lscr)
         else if (type .eq. -2) then
c........ spd
            call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &           dbl_mb(mb_exndcf(cpt, basis)), 
     &           0, nprim, dbl_mb(i_scr), lscr)
            call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &            dbl_mb(mb_exndcf(cpt+nprim,basis)),
     &           1, nprim, dbl_mb(i_scr), lscr)
            call nmcoef2c(dbl_mb(mb_exndcf(ept, basis)),
     &            dbl_mb(mb_exndcf(cpt+2*nprim,basis)),
     &           2, nprim, dbl_mb(i_scr), lscr)
         else
            call errquit('int_norm_2c: invalid contraction type', 0)
         endif
      enddo
c
c... free memory used for 2c2e integrals
      int_norm_2c = MA_pop_stack(h_scr)
c
      end
