      logical function tce_property(rtdb)
c
c $Id: tce_property.F,v 1.11 2008-02-12 17:19:28 jhammond Exp $
c 
c Main routine for many-electron theory calculations.
c Some of the subroutines have been generated by 
c operator/tensor contraction engines.
c
c Written by Jeff Hammond, January 2008.
c
      implicit none
#include "mafdecls.fh"
#include "tcgmsg.fh"
#include "global.fh"
#include "bas.fh"
#include "geom.fh"
#include "rtdb.fh"
#include "sym.fh"
#include "util.fh"
#include "msgids.fh"
#include "stdio.fh"
#include "sf.fh"
#include "inp.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
#include "tce_prop.fh"
#include "tce_ints.fh"
#include "tce_amps.fh"
#include "tce_diis.fh"
c
c     CI, CC, & MBPT
c
      integer rtdb             ! Run-time database
      logical nodezero         ! True if node 0
      logical recompf          ! True if recompute Fock
      double precision cpu     ! CPU sec counter
      double precision wall    ! WALL sec counter
c      integer lax_v2_alpha_offset  ! Offset for 2e integrals if intorb=.true.
c      integer kax_v2_alpha_offset  ! Offset for 2e integrals if intorb=.true.
c      integer lx_o2o_offset,kx_o2o_offset
c      integer lx_o2ot_offset,kx_o2ot_offset
c      integer lx_v2spin_offset,kx_v2spin_offset
c      integer length
      integer irrep
      integer irrep_g
      double precision ref     ! Ground state energy
      double precision corr    ! Correlation energy
c      double precision mbpt2   ! Correlation energy
c      double precision mbpt3   ! Correlation energy
c      double precision mbpt4   ! Correlation energy
      double precision r1      ! Residual t1
      double precision r2      ! Residual t2
      double precision r3      ! Residual t3
      double precision r4      ! Residual t4
      double precision residual! Largest residual
      integer i,j,dummy
      integer l_shell,l_subshell,l_sh_size
      character*255 filename
      character*8 title
      character*20 dtitle      ! Title to pass to drivers
      character*4 irrepname
      logical dft_energy
      external dft_energy
      logical scf
      external scf
      logical tce_ccsd_driver
      external tce_ccsd_driver
      logical tce_ccsdt_driver
      external tce_ccsdt_driver
      logical tce_ccsdtq_driver
      external tce_ccsdtq_driver
      logical tce_ccsd_lambda_driver
      external tce_ccsd_lambda_driver
c      logical tce_ccsdt_lambda_driver
c      external tce_ccsdt_lambda_driver
c      logical tce_ccsdtq_lambda_driver
c      external tce_ccsdtq_lambda_driver
      logical tce_ccsd_response_driver
      external tce_ccsd_response_driver
c      logical tce_ccsdt_response_driver
c      external tce_ccsdt_response_driver
c      logical tce_ccsdtq_response_driver
c      external tce_ccsdtq_response_driver
      double precision tce_ccsd_symm_polar
      external tce_ccsd_symm_polar
      logical tce_ccsd_lambda_response_driver
      external tce_ccsd_lambda_response_driver
      double precision tce_ccsd_asym_polar
      external tce_ccsd_asym_polar
c      double precision tce_ccsdt_symm_polar
c      external tce_ccsdt_symm_polar
c      double precision tce_ccsdtq_symm_polar
c      external tce_ccsdtq_symm_polar
c
c     These will go soon
c
      double precision alpha1,alpha2,alpha3,alpha4
      double precision beta1,beta2,beta3,beta4
c
      double precision dipole_scf(3) ! Dipole moment
      double precision dipole_cor(3) ! Dipole moment
      double precision dipole_exc(3) ! Dipole moment
      double precision cdipole   ! Dipole moment correlation
      double precision ddotfile
      external ddotfile
      integer sym_abelian_axis ! Move this and the following to "sym.fh"
      external sym_abelian_axis
      integer irrep_d1(3)
      double precision omega      ! The frequency used in (A-Iw)x=b
      double precision au2ev   ! Conversion factor from a.u. to eV
c      double precision numerator   ! <L|D exp(T)|R>
c      double precision denominator ! <L|exp(T)|R>
c      double precision transition(3) ! Transition moments
      parameter (au2ev=27.2113961d0)
      character*255 modelname
      nodezero=(ga_nodeid().eq.0)
      tce_property = .false.
c
c     =========================
c     Ground-state HF/DFT first
c     =========================
c
      call tce_reference_check(rtdb,ref)
c
c     ===================
c     Print utility start
c     ===================
c
      call util_print_push
      call util_print_rtdb_load(rtdb,'tce')
c
c     ==========
c     Initialize
c     ==========
c
      call tce_init(rtdb)
c
c     ===================
c     Initializing irreps
c     ===================
c
      irrep_x = 0
      irrep_y = 0
      irrep_c = 0
      irrep_g = 0
c
c     ==============
c     Create a mutex
c     ==============
c
      if (.not.ga_create_mutexes(1))
     1  call errquit('tce_property: GA problem',0,GA_ERR)
c
c     =========================
c     Reorder and tile orbitals
c     =========================
c
      call tce_tile(rtdb)
      call sf_test
c
c     ================================
c     Parallel integral transformation
c     ================================
c
      call tce_fock_create(rtdb,d_f1,l_f1_offset,k_f1_offset)
      call tce_multipole_create(rtdb,d_d1,l_d1_offset,k_d1_offset)
      call tce_fourindex_driver(rtdb,d_v2,l_v2_offset,k_v2_offset)
c
c     ====================
c     Initial t amplitudes
c     ====================
c
      needt1 = .false.
      needt2 = .false.
      needt3 = .false.
      needt4 = .false.
      if (model.eq.'ccsd') then
        needt1 = .true.
        needt2 = .true.
      else if (model.eq.'ccsdt') then
        needt1 = .true.
        needt2 = .true.
        needt3 = .true.
      else if (model.eq.'ccsdtq') then
        needt1 = .true.
        needt2 = .true.
        needt3 = .true.
        needt4 = .true.
      endif
c
c     t1 amplitudes
c
      if (needt1) then
        call tce_create_t1(d_t1,l_t1_offset,k_t1_offset,
     &                     size_t1,irrep_t,'t1      ')
        if (left) then
          call tce_create_y1(d_lambda1,l_l1_offset,k_l1_offset,
     &                       size_l1,irrep_t,'lambda1 ')
        endif
        if (lineresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_x1(d_tr1(axis),l_tr1_offset(axis),
     1           k_tr1_offset(axis),size_tr1(axis),
     2           sym_abelian_axis(geom,axis),tr1filename(axis))
            call tce_clone_x1(d_tr1(axis+3),size_tr1(axis),
     1           sym_abelian_axis(geom,axis),tr1filename(axis+3))
          endif
          enddo ! axis
        endif ! lineresp
        if (leftresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_y1(d_yr1(axis),l_yr1_offset(axis),
     1           k_yr1_offset(axis),size_yr1(axis),
     2           sym_abelian_axis(geom,axis),yr1filename(axis))
            call tce_clone_y1(d_yr1(axis+3),size_yr1(axis),
     1           sym_abelian_axis(geom,axis),yr1filename(axis+3))
          endif
          enddo ! axis
        endif ! leftresp
      endif
c
c     t2 amplitudes
c
      if (needt2) then
        call tce_create_t2(d_t2,l_t2_offset,k_t2_offset,size_t2,
     &                         irrep_t,'t2      ',
     &                         d_t1,k_t1_offset,size_t1,
     &                         d_f1,k_f1_offset,size_1e,
     &                         d_v2,k_v2_offset,size_2e,
     &                         ref,needt1)
        if (left) then
          call tce_create_y2(d_lambda2,l_l2_offset,k_l2_offset,
     &                             size_l2,irrep_t,'lambda2 ')
        endif
        if (lineresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_x2(d_tr2(axis),l_tr2_offset(axis),
     1           k_tr2_offset(axis),size_tr2(axis),
     2           sym_abelian_axis(geom,axis),tr2filename(axis))
            call tce_clone_x2(d_tr2(axis+3),size_tr2(axis),
     1           sym_abelian_axis(geom,axis),tr2filename(axis+3))
          endif
          enddo ! axis
        endif ! lineresp
        if (leftresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_y2(d_yr2(axis),l_yr2_offset(axis),
     1           k_yr2_offset(axis),size_yr2(axis),
     2           sym_abelian_axis(geom,axis),yr2filename(axis))
            call tce_clone_y2(d_yr2(axis+3),size_yr2(axis),
     1           sym_abelian_axis(geom,axis),yr2filename(axis+3))
          endif
          enddo ! axis
        endif ! leftresp
      endif
c
c     t3 amplitudes
c
      if (needt3) then
        call tce_create_t3(d_t3,l_t3_offset,k_t3_offset,size_t3,
     &                         irrep_t,'t3      ')
        if (left) then
          call tce_create_y3(d_lambda3,l_l3_offset,k_l3_offset,
     &                             size_l3,irrep_t,'lambda3 ')
        endif
        if (lineresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_x3(d_tr3(axis),l_tr3_offset(axis),
     1           k_tr3_offset(axis),size_tr3(axis),
     2           sym_abelian_axis(geom,axis),tr3filename(axis))
            call tce_clone_x3(d_tr3(axis+3),size_tr3(axis),
     1           sym_abelian_axis(geom,axis),tr3filename(axis+3))
          endif
          enddo ! axis
        endif ! lineresp
        if (leftresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_y3(d_yr3(axis),l_yr3_offset(axis),
     1           k_yr3_offset(axis),size_yr3(axis),
     2           sym_abelian_axis(geom,axis),yr3filename(axis))
            call tce_clone_y3(d_yr3(axis+3),size_yr3(axis),
     1           sym_abelian_axis(geom,axis),yr3filename(axis+3))
          endif
          enddo ! axis
        endif ! leftresp
      endif
c
c     t4 amplitudes
c
      if (needt4) then
        call tce_filename('t4',filename)
        call tce_create_t4(d_t4,l_t4_offset,k_t4_offset,size_t4,
     &                         irrep_t,'t4      ')

        if (left) then
          call tce_filename('lambda4',filename)
          call tce_create_y4(d_lambda4,l_l4_offset,k_l4_offset,
     &                             size_l4,irrep_t,'lambda4 ')
        endif
        if (lineresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_x4(d_tr4(axis),l_tr4_offset(axis),
     1           k_tr4_offset(axis),size_tr4(axis),
     2           sym_abelian_axis(geom,axis),tr4filename(axis))
            call tce_clone_x4(d_tr4(axis+3),size_tr4(axis),
     1           sym_abelian_axis(geom,axis),tr4filename(axis+3))
          endif
          enddo ! axis
        endif ! lineresp
        if (leftresp) then
          do axis = 1, 3
          if (respaxis(axis)) then
            call tce_create_y4(d_yr4(axis),l_yr4_offset(axis),
     1           k_yr4_offset(axis),size_yr4(axis),
     2           sym_abelian_axis(geom,axis),yr4filename(axis))
            call tce_clone_y4(d_yr4(axis+3),size_yr4(axis),
     1           sym_abelian_axis(geom,axis),yr4filename(axis+3))
          endif
          enddo ! axis
        endif ! leftresp
      endif
c
c ----------------------------------- c
c Coupled Cluster Singles and Doubles c
c ----------------------------------- c
      if (model.eq.'ccsd') then
c ----------- c
c CCSD Energy c
c ----------- c
        dtitle='CCSD'
        if (.not.tce_ccsd_driver(dtitle,ref,corr,thresh,maxiter,
     &           d_t1,k_t1_offset,size_t1,d_t2,k_t2_offset,size_t2,
     &           d_f1,k_f1_offset,d_v2,k_v2_offset)) then
          call errquit('tce_property: CCSD failed',0,CALC_ERR)
        endif
c -------------- c
c CCSD(T) Energy c
c -------------- c

c ----------- c
c CCSD Lambda c
c ----------- c
        if (left.and..true.) then
          dtitle='CCSD Lambda'
          if (.not.tce_ccsd_lambda_driver(dtitle,thresh,maxiter,
     &             d_lambda1,k_l1_offset,size_l1,
     &             d_lambda2,k_l2_offset,size_l2,
     &             d_t1,k_t1_offset,size_t1,d_t2,k_t2_offset,size_t2,
     &             d_f1,k_f1_offset,d_v2,k_v2_offset)) then
            call errquit('tce_property: CCSD Lambda failed',0,CALC_ERR)
        endif
        endif
c ------------------------------ c
c CCSD Dipole Moments (OLD CODE) c
c ------------------------------ c

c --------------------------------- c
c CCSD Multipole Moments (NEW CODE) c
c --------------------------------- c

c --------------------- c
c CCSD Density Matrices c
c --------------------- c

c --------------------------------- c
c CCSD Expectation Value Properties c
c --------------------------------- c

c ------- c
c CCSD-LR c
c ------- c
        if (lineresp) then
c
          do omegacount=1,anumfreq
            omega = afreq(omegacount)
            if (omega.eq.(0.0d0)) then
              dynfreq = 1
            else
              dynfreq = 2
            endif
c
          do axis = 1, 3
          if (respaxis(axis)) then
            irrep_d=sym_abelian_axis(geom,axis)
            call sym_irrepname(geom,irrep_d+1,irrepname)
            if (nodezero.and.util_print('mod1',print_default)) then
              write(LuOut,*)
              write(LuOut,9440) axisname(axis),irrepname
            endif
            irrep_o=irrep_d
            irrep_x=irrep_d
c
          do omegasign=1,dynfreq
            if (omegasign.eq.1) then
              omega = (-1.0d0)*afreq(omegacount)
              dynaxis = 0
            elseif (omegasign.eq.2) then
              omega = (1.0d0)*afreq(omegacount)
              dynaxis = 3
            endif
            if (nodezero) write(LuOut,9431) omega
c
            dtitle='CCSD-LR'
            if (.not.tce_ccsd_response_driver(dtitle,thresh,maxiter,
     &        d_tr1(axis+dynaxis),k_tr1_offset(axis),size_tr1(axis),
     &        d_tr2(axis+dynaxis),k_tr2_offset(axis),size_tr2(axis),
     &        d_t1,k_t1_offset,size_t1,d_t2,k_t2_offset,size_t2,
     &        d_f1,k_f1_offset,d_v2,k_v2_offset,
     &        d_d1(axis),k_d1_offset(axis),omega)) then
              call errquit('tce_property: CCSD-LR failed',0,CALC_ERR)
            endif
c
          enddo ! omegasign loop
c
          endif ! respaxis(axis)
          enddo ! axis loop
c ------------------------------------------------ c
c CCSD Polarizabilities using symmetric evaluation c
c ------------------------------------------------ c
          cpu=-util_cpusec()
          wall=-util_wallsec()
          do axisA = 1, 3
          do axisB = 1, axisA
          if (respaxis(axisA).and.respaxis(axisB)) then
            irrep_a=sym_abelian_axis(geom,axisA)
            irrep_b=sym_abelian_axis(geom,axisB)
            irrep_y=irrep_g
c
            if (nodezero) then
              write(LuOut,*)
              write(LuOut,9350) 'CCSD-LR Polarizability'
            endif
            alpha(axisA,axisB)=tce_ccsd_symm_polar(omega,.false.,
     &         irrep_a,d_d1(axisA),k_d1_offset(axisA),
     &         irrep_b,d_d1(axisB),k_d1_offset(axisB),
     &         d_f1,k_f1_offset,d_v2,k_v2_offset,
     &         d_t1,k_t1_offset,d_t2,k_t2_offset,
     &         d_lambda1,k_l1_offset,d_lambda2,k_l2_offset,
     &         d_tr1(axisA),d_tr1(axisA+dynaxis),k_tr1_offset(axisA),
     &         d_tr2(axisA),d_tr2(axisA+dynaxis),k_tr2_offset(axisA),
     &         d_tr1(axisB),d_tr1(axisB+dynaxis),k_tr1_offset(axisB),
     &         d_tr2(axisB),d_tr2(axisB+dynaxis),k_tr2_offset(axisB))
c
          endif ! respaxis(axis)
          enddo ! axisB loop
          enddo ! axisA loop
          cpu=cpu+util_cpusec()
          wall=wall+util_wallsec()
c
          if (nodezero) write(LuOut,9434) "CCSD Linear Response",
     1        afreq(omegacount),
     2        alpha(1,1),alpha(2,1),alpha(3,1),
     3        alpha(2,1),alpha(2,2),alpha(3,2),
     4        alpha(3,1),alpha(3,2),alpha(3,3)
          if (nodezero) write(LuOut,9020) cpu, wall
          call util_flush(LuOut)
c
          enddo ! omegacount loop
c
        endif ! lineresp
c
c ------- c
c CCSD-YR c
c ------- c
        if (leftresp) then
c
          do omegacount=1,anumfreq
            omega1 = afreq(omegacount)
            if (omega1.eq.(0.0d0)) then
              dynfreq = 1
            else
              dynfreq = 2
            endif
c
          do axis = 1, 3
          if (respaxis(axis)) then
            irrep_d=sym_abelian_axis(geom,axis)
            call sym_irrepname(geom,irrep_d+1,irrepname)
            if (nodezero.and.util_print('mod1',print_default)) then
              write(LuOut,*)
              write(LuOut,9440) axisname(axis),irrepname
            endif
            irrep_o=irrep_d
            irrep_x=irrep_d
c
          do omegasign=1,dynfreq
            if (omegasign.eq.1) then
              omega = (1.0d0)*afreq(omegacount)
              dynaxis = 0
            elseif (omegasign.eq.2) then
              omega = (-1.0d0)*afreq(omegacount)
              dynaxis = 3
            endif
            if (nodezero) write(LuOut,9431) omega
            dtitle='CCSD-YR'
            if (.not.tce_ccsd_lambda_response_driver(dtitle,
     &        thresh,maxiter,
     &        d_yr1(axis+dynaxis),k_yr1_offset(axis),size_yr1(axis),
     &        d_yr2(axis+dynaxis),k_yr2_offset(axis),size_yr2(axis),
     &        d_lambda1,k_l1_offset,d_lambda2,k_l2_offset,
     &        d_tr1(axis+dynaxis),k_tr1_offset(axis),size_tr1(axis),
     &        d_tr2(axis+dynaxis),k_tr2_offset(axis),size_tr2(axis),
     &        d_t1,k_t1_offset,size_t1,d_t2,k_t2_offset,size_t2,
     &        d_f1,k_f1_offset,d_v2,k_v2_offset,
     &        d_d1(axis),k_d1_offset(axis),omega)) then
              call errquit('tce_property: CCSD-YR failed',0,CALC_ERR)
            endif
c
          enddo ! omegasign loop
c
          endif ! respaxis(axis)
          enddo ! axis loop
c ------------------------------------------------- c
c CCSD Polarizabilities using asymmetric evaluation c
c ------------------------------------------------- c
          cpu=-util_cpusec()
          wall=-util_wallsec()
          do axisA = 1, 3
            irrep_a=sym_abelian_axis(geom,axisA)
          do axisB = 1, 3
            irrep_b=sym_abelian_axis(geom,axisB)
          if ( respaxis(axisA).and.respaxis(axisB) ) then
c
            irrep_a=sym_abelian_axis(geom,axisA)
            irrep_b=sym_abelian_axis(geom,axisB)
c
            if (nodezero) then
              write(LuOut,*)
              write(LuOut,9350) 'CCSD-YR Polarizability'
            endif
            alpha(axisA,axisB)=0.0
            alpha(axisA,axisB)=alpha(axisA,axisB)+
     &         tce_ccsd_asym_polar(omega,.false.,
     &         irrep_a,d_d1(axisA),k_d1_offset(axisA),irrep_b,
     &         d_f1,k_f1_offset,d_v2,k_v2_offset,
     &         d_t1,k_t1_offset,d_t2,k_t2_offset,
     &         d_lambda1,k_l1_offset,d_lambda2,k_l2_offset,
     &         d_tr1(axisB),k_tr1_offset(axisB),
     &         d_tr2(axisB),k_tr2_offset(axisB),
     &         d_yr1(axisB),k_yr1_offset(axisB),
     &         d_yr2(axisB),k_yr2_offset(axisB))
            alpha(axisA,axisB)=alpha(axisA,axisB)+
     &         tce_ccsd_asym_polar(omega,.false.,
     &         irrep_a,d_d1(axisA),k_d1_offset(axisA),irrep_b,
     &         d_f1,k_f1_offset,d_v2,k_v2_offset,
     &         d_t1,k_t1_offset,d_t2,k_t2_offset,
     &         d_lambda1,k_l1_offset,d_lambda2,k_l2_offset,
     &         d_tr1(axisB+dynaxis),k_tr1_offset(axisB),
     &         d_tr2(axisB+dynaxis),k_tr2_offset(axisB),
     &         d_yr1(axisB+dynaxis),k_yr1_offset(axisB),
     &         d_yr2(axisB+dynaxis),k_yr2_offset(axisB))
c
          endif ! respaxis(axisA,axisB)
          enddo ! axisB loop
          enddo ! axisA loop
c
          if (nodezero) write(LuOut,9434) "CCSD Lambda Response",
     1      afreq(omegacount),
     2      alpha(1,1),alpha(1,2),alpha(1,3),
     3      alpha(2,1),alpha(2,2),alpha(2,3),
     4      alpha(3,1),alpha(3,2),alpha(3,3)
          cpu=cpu+util_cpusec()
          wall=wall+util_wallsec()
          if (nodezero) write(LuOut,9020) cpu, wall
          call util_flush(LuOut)
c -------------------------- c
c CCSD Hyperpolarizabilities c
c -------------------------- c
          do axis = 1, 3
            irrep_d1(axis)=sym_abelian_axis(geom,axis)
          enddo
c
c      print*,'d_d1,offset',d_d1,k_d1_offset
c      print*,'d_f1,offset',d_f1,k_f1_offset
c      print*,'d_v2,offset',d_v2,k_v2_offset
c      print*,'d_t1,offset',d_t1,k_t1_offset
c      print*,'d_t2,offset',d_t2,k_t2_offset
c      print*,'d_y1,offset',d_lambda1,k_l1_offset
c      print*,'d_y2,offset',d_lambda2,k_l2_offset
c      print*,'d_tr1,offset',d_tr1,k_tr1_offset
c      print*,'d_tr2,offset',d_tr2,k_tr2_offset
c      print*,'d_yr1,offset',d_yr1,k_yr1_offset
c      print*,'d_yr2,offset',d_yr2,k_yr2_offset
c
          call tce_ccsd_hyperpolar(beta,.true.,respaxis,
     1         irrep_d1,d_d1,k_d1_offset,
     2         d_f1,k_f1_offset,d_v2,k_v2_offset,
     3         d_t1,k_t1_offset,d_t2,k_t2_offset,
     4         d_lambda1,k_l1_offset,d_lambda2,k_l2_offset,
     5         d_tr1,k_tr1_offset,d_tr2,k_tr2_offset,
     6         d_yr1,k_yr1_offset,d_yr2,k_yr2_offset)
c
          if (nodezero) then
            write(LuOut,*)
            write(LuOut,9120) "CCSD Quadratic Response"
            write(LuOut,9504)
            write(LuOut,9502)
            do axisA = 1, 3
              do axisB = 1, 3
                do axisC = 1, 3
                  if (dabs(beta(axisA,axisB,axisC)).gt.1.0d-8)
     1              write(LuOut,9503) axisname(axisA),axisname(axisB),
     2              axisname(axisC),beta(axisA,axisB,axisC),' / au'
                enddo
              enddo
            enddo
            write(LuOut,9502)
          endif
          call util_flush(LuOut)
c
          enddo ! omegacount loop
c
        endif ! leftresp
c -------------------------------------------- c
c Coupled Cluster Singles, Doubles and Triples c
c -------------------------------------------- c
      else if (model.eq.'ccsdt') then
c -------------
c CCSDT   right
c -------------
        dtitle='CCSDT'
        if (.not.tce_ccsdt_driver(dtitle,ref,corr,thresh,maxiter,
     &           d_t1,k_t1_offset,size_t1,d_t2,k_t2_offset,size_t2,
     &           d_t1,k_t3_offset,size_t3,d_f1,k_f1_offset,
     &           d_v2,k_v2_offset,.true.)) then
          call errquit('tce_property: CCSDT failed',0,CALC_ERR)
        endif
        call errquit('tce_property: manual stop',0,CALC_ERR)
c -------------
c CCSDT   left
c -------------
        if (left) then
        irrep_y=0
        call tce_diis_init()
        do iter=1,maxiter
          cpu=-util_cpusec()
          wall=-util_wallsec()
          if (nodezero.and.(iter.eq.1)) write(LuOut,9400) "CCSDT Lambda"
          call tce_filename('lr1',filename)
          call createfile(filename,d_lr1,size_l1)
          call ccsdt_lambda1(d_f1,d_lr1,d_t1,d_t2,d_t3,d_v2,d_lambda1,
     1       d_lambda2,d_lambda3,k_f1_offset,k_l1_offset,k_t1_offset,
     2       k_t2_offset,k_t3_offset,k_v2_offset,k_l1_offset,
     3       k_l2_offset,k_l3_offset)
          call reconcilefile(d_lr1,size_l1)
          call tce_filename('lr2',filename)
          call createfile(filename,d_lr2,size_l2)
          call ccsdt_lambda2(d_f1,d_lr2,d_t1,d_t2,d_t3,d_v2,d_lambda1,
     1       d_lambda2,d_lambda3,k_f1_offset,k_l2_offset,k_t1_offset,
     2       k_t2_offset,k_t3_offset,k_v2_offset,k_l1_offset,
     3       k_l2_offset,k_l3_offset)
          call reconcilefile(d_lr2,size_l2)
          call tce_filename('lr3',filename)
          call createfile(filename,d_lr3,size_l3)
          call ccsdt_lambda3(d_f1,d_lr3,d_t1,d_t2,d_v2,d_lambda1,
     1       d_lambda2,d_lambda3,k_f1_offset,k_l3_offset,k_t1_offset,
     2       k_t2_offset,k_v2_offset,k_l1_offset,
     3       k_l2_offset,k_l3_offset)
          call reconcilefile(d_lr3,size_l3)
          r1 = ddotfile(d_lr1,d_lr1,size_l1)
          r2 = ddotfile(d_lr2,d_lr2,size_l2)
          r3 = ddotfile(d_lr3,d_lr3,size_l3)
          residual = max(r1,r2,r3)
          cpu=cpu+util_cpusec()
          wall=wall+util_wallsec()
          if (nodezero) write(LuOut,9420) iter,residual,cpu,wall
          if (residual .lt. thresh) then
            if (nodezero) then
              write(LuOut,9410)
            endif
            call deletefile(d_lr3)
            call deletefile(d_lr2)
            call deletefile(d_lr1)
            call tce_diis_tidy()
            do axis=1,3
              irrep_d=sym_abelian_axis(geom,axis)
              call tce_filename('d0',filename)
              call createfile(filename,d_d0,size_d0)
              call ccsdt_density1(d_d1(axis),d_d0,d_t1,d_t2,d_t3,
     1          d_lambda1,d_lambda2,d_lambda3,k_d1_offset(axis),
     2          k_d0_offset,k_t1_offset,k_t2_offset,k_t3_offset,
     3          k_l1_offset,k_l2_offset,k_l3_offset)
              call reconcilefile(d_d0,size_d0)
              call get_block(d_d0,cdipole,1,0)
              dipole_cor(axis)=dipole_scf(axis)+cdipole
              call deletefile(d_d0)
            enddo
            if (nodezero) write(LuOut,9430) "CCSDT",
     1                    dipole_cor(1),dipole_cor(1)*debye,
     2                    dipole_cor(2),dipole_cor(2)*debye,
     3                    dipole_cor(3),dipole_cor(3)*debye
ccc            goto 2010
            goto 2337
          endif
          call tce_diis(.true.,iter,.true.,.true.,.true.,.false.,
     1                  d_lr1,d_lambda1,k_l1_offset,size_l1,
     2                  d_lr2,d_lambda2,k_l2_offset,size_l2,
     3                  d_lr3,d_lambda3,k_l3_offset,size_l3,
     4                  dummy,dummy,dummy,dummy)
          call deletefile(d_lr3)
          call deletefile(d_lr2)
          call deletefile(d_lr1)
          if (nodezero) call util_flush(LuOut)
        enddo
        call errquit('tce_property: maxiter exceeded',iter,CALC_ERR)
        endif ! (left)
 2337   continue
c -------------
c CCSDT-LR
c -------------
c
        if (lineresp) then
c          if (nodezero) write(LuOut,*) "lineresp is go"
          do omegacount=1,anumfreq
c            if (nodezero) write(LuOut,*) "omegacount is go"
            omega = afreq(omegacount)
            if (omega.eq.(0.0d0)) then
              dynfreq = 1
            else
              dynfreq = 2
            endif
c 
          do axis = 1, 3 
c            if (nodezero) write(LuOut,*) "axis is go"
          if (respaxis(axis)) then
c            if (nodezero) write(LuOut,*) "respaxis(axis) is go"
            irrep_d=sym_abelian_axis(geom,axis)
            call sym_irrepname(geom,irrep_d+1,irrepname)
            if (nodezero.and.util_print('mod1',print_default)) then
              write(LuOut,*)
              write(LuOut,9440) axisname(axis),irrepname
            endif
            irrep_o=irrep_d
            irrep_x=irrep_d
c
          do omegasign=1,dynfreq
c            if (nodezero) write(LuOut,*) "omegasign is go"
            if (omegasign.eq.1) then
              omega = (1.0d0)*afreq(omegacount)
              dynaxis = 0
            elseif (omegasign.eq.2) then
              omega = (-1.0d0)*afreq(omegacount)
              dynaxis = 3
            endif
            if (nodezero) write(LuOut,9431) omega
c            if (nodezero) write(LuOut,*) "omega = ",omega
c            if (nodezero) write(LuOut,*) "dynaxis = ",dynaxis
c
            call tce_diis_init()
            do iter=1,maxiter
              cpu=-util_cpusec()
              wall=-util_wallsec()
              if (nodezero.and.(iter.eq.1))
     &          write(LuOut,9400) "CCSDT-LR"
c
              call tce_filename(rr1filename(axis),filename)
              call createfile(filename,d_rr1(axis),size_tr1(axis))
              call tce_zero(d_rr1(axis),size_tr1(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega,d_tr1(axis+dynaxis),
     1             d_rr1(axis),size_tr1(axis))
c        write(LuOut,*) "eomccsdt_x1"
              call eomccsdt_x1(d_f1,d_rr1(axis),d_t1,d_t2,d_v2,
     1             d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),k_f1_offset,k_tr1_offset(axis),
     3             k_t1_offset,k_t2_offset,k_v2_offset,
     4             k_tr1_offset(axis),k_tr2_offset(axis),
     5             k_tr3_offset(axis))
c        write(LuOut,*) "ccsdt_o1"
              call ccsdt_o1(d_rr1(axis),d_d1(axis),d_t1,d_t2,
     &             k_tr1_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset)
c
              call tce_filename(rr2filename(axis),filename)
              call createfile(filename,d_rr2(axis),size_tr2(axis))
              call tce_zero(d_rr2(axis),size_tr2(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega,d_tr2(axis+dynaxis),
     1             d_rr2(axis),size_tr2(axis))
c        write(LuOut,*) "eomccsdt_x2"
              call eomccsdt_x2(d_f1,d_rr2(axis),d_t1,d_t2,d_t3,d_v2,
     1             d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),k_f1_offset,k_tr2_offset(axis),
     3             k_t1_offset,k_t2_offset,k_t3_offset,k_v2_offset,
     4             k_tr1_offset(axis),k_tr2_offset(axis),
     5             k_tr3_offset(axis))
c        write(LuOut,*) "ccsdt_o2"
              call ccsdt_o2(d_rr2(axis),d_d1(axis),d_t1,d_t2,d_t3,
     &             k_tr2_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset,k_t3_offset)
c
              call tce_filename(rr3filename(axis),filename)
              call createfile(filename,d_rr3(axis),size_tr3(axis))
              call tce_zero(d_rr3(axis),size_tr3(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega,d_tr3(axis+dynaxis),
     1             d_rr3(axis),size_tr3(axis))
c        write(LuOut,*) "eomccsdt_x3"
              call eomccsdt_x3(d_f1,d_rr3(axis),d_t1,d_t2,d_t3,d_v2,
     1             d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),k_f1_offset,k_tr3_offset(axis),
     3             k_t1_offset,k_t2_offset,k_t3_offset,k_v2_offset,
     4             k_tr1_offset(axis),k_tr2_offset(axis),
     5             k_tr3_offset(axis))
c        write(LuOut,*) "ccsdt_o3"
              call ccsdt_o3(d_rr3(axis),d_d1(axis),d_t1,d_t2,d_t3,
     &             k_tr3_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset,k_t3_offset)
c
c        write(LuOut,*) "reconcilefile"
              call reconcilefile(d_rr1(axis),size_tr1(axis))
              call reconcilefile(d_rr2(axis),size_tr2(axis))
              call reconcilefile(d_rr3(axis),size_tr3(axis))
c        write(LuOut,*) "tce_residual_tr1"
              call tce_residual_tr1(d_rr1(axis),k_tr1_offset(axis),rr1)
c        write(LuOut,*) "tce_residual_tr2"
              call tce_residual_tr2(d_rr2(axis),k_tr2_offset(axis),rr2)
c        write(LuOut,*) "tce_residual_tr3"
              call tce_residual_tr3(d_rr3(axis),k_tr3_offset(axis),rr3)
              residual = max(rr1,rr2,rr3)
              cpu=cpu+util_cpusec()
              wall=wall+util_wallsec()
              if (nodezero) write(LuOut,9420) iter,residual,cpu,wall
              if (residual .lt. thresh) then
                if (nodezero) write(LuOut,9410)
                call deletefile(d_rr3(axis))
                call deletefile(d_rr2(axis))
                call deletefile(d_rr1(axis))
c                call tce_print_x1r(d_tr1(axis),k_tr1_offset(axis),
c     &               ampthresh,irrep_tr)
c                call tce_print_x2r(d_tr2(axis),k_tr2_offset(axis),
c     &               ampthresh,irrep_tr)
                call tce_diis_tidy()
                goto 2338
              endif
              call tce_diis2(.false.,iter,.true.,.true.,.true.,.false.,
     1             d_rr1(axis),d_tr1(axis+dynaxis),k_tr1_offset(axis),
     2             size_tr1(axis),
     3             d_rr2(axis),d_tr2(axis+dynaxis),k_tr2_offset(axis),
     4             size_tr2(axis),
     5             d_rr3(axis),d_tr3(axis+dynaxis),k_tr3_offset(axis),
     6             size_tr3(axis),
     7             dummy,dummy,dummy,dummy)
              call deletefile(d_rr3(axis))
              call deletefile(d_rr2(axis))
              call deletefile(d_rr1(axis))
              if (nodezero) call util_flush(LuOut)
            enddo ! iter loop
          call errquit('tce_property: maxiter exceeded',iter,CALC_ERR)
 2338 continue
c
          enddo ! omegasign loop
          endif ! respaxis(axis)
          enddo ! axis loop
c
c         Evaluate Dipole Polarizability
c
          do axisA = 1, 3
          do axisB = 1, axisA
          if (respaxis(axisA).and.respaxis(axisB)) then
            irrep_a=sym_abelian_axis(geom,axisA)
            irrep_b=sym_abelian_axis(geom,axisB)
            irrep_y=irrep_g
c
c            if (nodezero) write(LuOut,*) "axisA = ",axisA
c            if (nodezero) write(LuOut,*) "axisB = ",axisB
c
            alpha(axisA,axisB)=0.0d0
c
            call tce_filename('a0',filename)
            call createfile(filename,d_a0,size_a0)
c
              alpha1=0.0d0
              alpha2=0.0d0
c
              if (omega.ne.0.0d0) then
                dynaxis = 3
              else
                dynaxis = 0
              endif
c
              irrep_c=irrep_a
              irrep_oa=irrep_a
              irrep_ob=irrep_b
c              if (nodezero) write(LuOut,*) "ccsdt_lr_alpha_offdiag #1"
              call ccsdt_lr_alpha_offdiag(d_tr1(axisA),
     1             d_tr2(axisA),d_tr3(axisA),
     2             d_tr1(axisB+dynaxis),d_tr2(axisB+dynaxis),
     3             d_tr3(axisB+dynaxis),d_tr1(axisA),
     4             d_tr2(axisA),d_tr3(axisA),
     5             d_f1,d_a0,d_d1(axisA),d_d1(axisB),d_t1,d_t2,d_t3,
     6             d_v2,d_lambda1,d_lambda2,d_lambda3,
     7             k_tr1_offset(axisA),k_tr2_offset(axisA),
     8             k_tr3_offset(axisA),k_tr1_offset(axisB),
     9             k_tr2_offset(axisB),k_tr3_offset(axisB),
     1             k_tr1_offset(axisA),k_tr2_offset(axisA),
     2             k_tr3_offset(axisA),k_f1_offset,k_a0_offset,
     3             k_d1_offset(axisA),k_d1_offset(axisB),
     4             k_t1_offset,k_t2_offset,k_t3_offset,
     5             k_v2_offset,k_l1_offset,k_l2_offset,k_l3_offset)
c
              call reconcilefile(d_a0,size_a0)
              call get_block(d_a0,alpha1,1,0)
              call tce_zero(d_a0,size_a0)
c              write(LuOut,*) "alpha1 = ",alpha1
c
              if ((omega.eq.0.0d0).or.(axisA.eq.axisB)) then
                alpha2=alpha1
              else
c                if (nodezero) write(LuOut,*) "ccsdt_lr_alpha_offdiag #2"
                call ccsdt_lr_alpha_offdiag(d_tr1(axisA+dynaxis),
     1               d_tr2(axisA+dynaxis),d_tr3(axisA+dynaxis),
     2               d_tr1(axisB),d_tr2(axisB),
     3               d_tr3(axisB),d_tr1(axisA+dynaxis),
     4               d_tr2(axisA+dynaxis),d_tr3(axisA+dynaxis),
     5               d_f1,d_a0,d_d1(axisA),d_d1(axisB),d_t1,d_t2,d_t3,
     6               d_v2,d_lambda1,d_lambda2,d_lambda3,
     7               k_tr1_offset(axisA),k_tr2_offset(axisA),
     8               k_tr3_offset(axisA),k_tr1_offset(axisB),
     9               k_tr2_offset(axisB),k_tr3_offset(axisB),
     1               k_tr1_offset(axisA),k_tr2_offset(axisA),
     2               k_tr3_offset(axisA),k_f1_offset,k_a0_offset,
     3               k_d1_offset(axisA),k_d1_offset(axisB),
     4               k_t1_offset,k_t2_offset,k_t3_offset,
     5               k_v2_offset,k_l1_offset,k_l2_offset,k_l3_offset)
c
                call reconcilefile(d_a0,size_a0)
                call get_block(d_a0,alpha2,1,0)
                call tce_zero(d_a0,size_a0)
              endif ! axisA.eq.axisB
c              write(LuOut,*) "alpha2 = ",alpha2
c
              alpha(axisA,axisB)=(-0.5d0)*(alpha1+alpha2)
c
            call deletefile(d_a0)
c
c            write(LuOut,*) "alpha(axisA,axisB) = ",alpha(axisA,axisB)
c            if (nodezero) write(LuOut,9020) cpu, wall
c
          endif ! respaxis(axis)
          enddo ! axisB loop
          enddo ! axisA loop
c
          if (nodezero) write(LuOut,9434) "CCSDT Linear Response",
     1        afreq(omegacount),
     2        alpha(1,1),alpha(2,1),alpha(3,1),
     3        alpha(2,1),alpha(2,2),alpha(3,2),
     4        alpha(3,1),alpha(3,2),alpha(3,3)
          if (nodezero) write(LuOut,9020) cpu, wall
          call util_flush(LuOut)
c
          enddo ! omegacount loop
c
        endif ! lineresp
c
      else if (model.eq.'ccsdtq') then
c -------------
c CCSDTQ  right
c -------------
        call tce_diis_init()
        do iter=1,maxiter
          cpu=-util_cpusec()
          wall=-util_wallsec()
          if (nodezero.and.(iter.eq.1)) write(LuOut,9050) "CCSDTQ"
          call tce_filename('e',filename)
          call createfile(filename,d_e,size_e)
          call ccsdtq_e(d_f1,d_e,d_t1,d_t2,d_v2,
     1                  k_f1_offset,k_e_offset,
     2                  k_t1_offset,k_t2_offset,k_v2_offset)
          call reconcilefile(d_e,size_e)
          call tce_filename('r1',filename)
          call createfile(filename,d_r1,size_r1)
          call ccsdtq_t1(d_f1,d_r1,d_t1,d_t2,d_t3,d_v2,
     1                   k_f1_offset,k_r1_offset,k_t1_offset,
     2                   k_t2_offset,k_t3_offset,k_v2_offset)
          call reconcilefile(d_r1,size_r1)
          call tce_filename('r2',filename)
          call createfile(filename,d_r2,size_r2)
          call ccsdtq_t2(d_f1,d_r2,d_t1,d_t2,d_t3,d_t4,d_v2,
     1                   k_f1_offset,k_r2_offset,k_t1_offset,
     2                   k_t2_offset,k_t3_offset,k_t4_offset,
     3                   k_v2_offset)
          call reconcilefile(d_r2,size_r2)
          call tce_filename('r3',filename)
          call createfile(filename,d_r3,size_r3)
          call ccsdtq_t3(d_f1,d_r3,d_t1,d_t2,d_t3,d_t4,d_v2,
     1                   k_f1_offset,k_r3_offset,k_t1_offset,
     2                   k_t2_offset,k_t3_offset,k_t4_offset,
     3                   k_v2_offset)
          call reconcilefile(d_r3,size_r3)
          call tce_filename('r4',filename)
          call createfile(filename,d_r4,size_r4)
          call ccsdtq_t4(d_f1,d_r4,d_t1,d_t2,d_t3,d_t4,d_v2,
     1                   k_f1_offset,k_r4_offset,k_t1_offset,
     2                   k_t2_offset,k_t3_offset,k_t4_offset,
     3                   k_v2_offset)
          call reconcilefile(d_r4,size_r4)
          call tce_residual_t1(d_r1,k_r1_offset,r1)
          call tce_residual_t2(d_r2,k_r2_offset,r2)
          call tce_residual_t3(d_r3,k_r3_offset,r3)
          call tce_residual_t4(d_r4,k_r4_offset,r4)
          residual = max(r1,r2,r3,r4)
          call get_block(d_e,corr,1,0)
          cpu=cpu+util_cpusec()
          wall=wall+util_wallsec()
          if (nodezero) write(LuOut,9100) iter,residual,corr,cpu,wall
          if (residual .lt. thresh) then
            if (nodezero) then
              write(LuOut,9060)
              write(LuOut,9070) "CCSDTQ",corr
              write(LuOut,9080) "CCSDTQ",ref + corr
            endif
            call deletefile(d_r4)
            call deletefile(d_r3)
            call deletefile(d_r2)
            call deletefile(d_r1)
            call deletefile(d_e)
            call tce_diis_tidy()
            goto 340 
          endif
          call tce_diis(.false.,iter,.true.,.true.,.true.,.true.,
     1                  d_r1,d_t1,k_t1_offset,size_t1,
     2                  d_r2,d_t2,k_t2_offset,size_t2,
     3                  d_r3,d_t3,k_t3_offset,size_t3,
     4                  d_r4,d_t4,k_t4_offset,size_t4)
          call deletefile(d_r4)
          call deletefile(d_r3)
          call deletefile(d_r2)
          call deletefile(d_r1)
          call deletefile(d_e)
          if (nodezero) call util_flush(LuOut)
        enddo
        call errquit('tce_property: maxiter exceeded',iter,CALC_ERR)
c -------------
c CCSDTQ  left 
c -------------
  340   continue
        if (left) then
        irrep_y=0
        call tce_diis_init()
        do iter=1,maxiter
          cpu=-util_cpusec()
          wall=-util_wallsec()
          if (nodezero.and.(iter.eq.1))
     1    write(LuOut,9400) "CCSDTQ Lambda"
          call tce_filename('lr1',filename)
          call createfile(filename,d_lr1,size_l1)
          call ccsdtq_lambda1(d_f1,d_lr1,d_t1,d_t2,d_t3,d_t4,d_v2,
     1      d_lambda1,d_lambda2,d_lambda3,d_lambda4,k_f1_offset,
     2      k_l1_offset,k_t1_offset,k_t2_offset,k_t3_offset,
     3      k_t4_offset,k_v2_offset,k_l1_offset,k_l2_offset,
     4      k_l3_offset,k_l4_offset)
          call reconcilefile(d_lr1,size_l1)
          call tce_filename('lr2',filename)
          call createfile(filename,d_lr2,size_l2)
          call ccsdtq_lambda2(d_f1,d_lr2,d_t1,d_t2,d_t3,d_t4,d_v2,
     1      d_lambda1,d_lambda2,d_lambda3,d_lambda4,k_f1_offset,
     2      k_l2_offset,k_t1_offset,k_t2_offset,k_t3_offset,
     3      k_t4_offset,k_v2_offset,k_l1_offset,k_l2_offset,
     4      k_l3_offset,k_l4_offset)
          call reconcilefile(d_lr2,size_l2)
          call tce_filename('lr3',filename)
          call createfile(filename,d_lr3,size_l3)
          call ccsdtq_lambda3(d_f1,d_lr3,d_t1,d_t2,d_t3,d_v2,
     1      d_lambda1,d_lambda2,d_lambda3,d_lambda4,k_f1_offset,
     2      k_l3_offset,k_t1_offset,k_t2_offset,k_t3_offset,
     3      k_v2_offset,k_l1_offset,k_l2_offset,
     4      k_l3_offset,k_l4_offset)
          call reconcilefile(d_lr3,size_l3)
          call tce_filename('lr4',filename)
          call createfile(filename,d_lr4,size_l4)
          call ccsdtq_lambda4(d_f1,d_lr4,d_t1,d_t2,d_v2,
     1      d_lambda2,d_lambda3,d_lambda4,k_f1_offset,
     2      k_l4_offset,k_t1_offset,k_t2_offset,
     3      k_v2_offset,k_l2_offset,k_l3_offset,k_l4_offset)
          call reconcilefile(d_lr4,size_l4)
          r1 = ddotfile(d_lr1,d_lr1,size_l1)
          r2 = ddotfile(d_lr2,d_lr2,size_l2)
          r3 = ddotfile(d_lr3,d_lr3,size_l3)
          r4 = ddotfile(d_lr4,d_lr4,size_l4)
          residual = max(r1,r2,r3,r4)
          cpu=cpu+util_cpusec()
          wall=wall+util_wallsec()
          if (nodezero) write(LuOut,9420) iter,residual,cpu,wall
          if (residual .lt. thresh) then
            if (nodezero) then
              write(LuOut,9410)
            endif
            call deletefile(d_lr4)
            call deletefile(d_lr3)
            call deletefile(d_lr2)
            call deletefile(d_lr1)
            call tce_diis_tidy()
            do axis=1,3
              irrep_d=sym_abelian_axis(geom,axis)
              call tce_filename('d0',filename)
              call createfile(filename,d_d0,size_d0)
              call ccsdtq_density1(d_d1(axis),d_d0,d_t1,d_t2,d_t3,d_t4,
     1          d_lambda1,d_lambda2,d_lambda3,d_lambda4,
     2          k_d1_offset(axis),k_d0_offset,k_t1_offset,k_t2_offset,
     3          k_t3_offset,k_t4_offset,k_l1_offset,k_l2_offset,
     4          k_l3_offset,k_l4_offset)
              call reconcilefile(d_d0,size_d0)
              call get_block(d_d0,cdipole,1,0)
              dipole_cor(axis)=dipole_scf(axis)+cdipole
              call deletefile(d_d0)
            enddo
            if (nodezero) write(LuOut,9430) "CCSDTQ",
     1                    dipole_cor(1),dipole_cor(1)*debye,
     2                    dipole_cor(2),dipole_cor(2)*debye,
     3                    dipole_cor(3),dipole_cor(3)*debye
c            goto 100 
            goto 2437
          endif
          call tce_diis(.true.,iter,.true.,.true.,.true.,.true.,
     1                  d_lr1,d_lambda1,k_l1_offset,size_l1,
     2                  d_lr2,d_lambda2,k_l2_offset,size_l2,
     3                  d_lr3,d_lambda3,k_l3_offset,size_l3,
     4                  d_lr4,d_lambda4,k_l4_offset,size_l4)
          call deletefile(d_lr4)
          call deletefile(d_lr3)
          call deletefile(d_lr2)
          call deletefile(d_lr1)
          if (nodezero) call util_flush(LuOut)
        enddo
        call errquit('tce_property: maxiter exceeded',iter,CALC_ERR)
        endif
c -------------
c CCSDTQ-LR
c -------------
 2437   continue
        if (lineresp) then
c
c          if (nodezero) write(LuOut,*) "lineresp is go"
          do omegacount=1,anumfreq
c            if (nodezero) write(LuOut,*) "omegacount is go"
            omega1 = afreq(omegacount)
            if (omega1.eq.(0.0d0)) then
              dynfreq = 1
            else
              dynfreq = 2
            endif
c
          do axis = 1, 3
c            if (nodezero) write(LuOut,*) "axis is go"
          if (respaxis(axis)) then
c            if (nodezero) write(LuOut,*) "respaxis(axis) is go"
            irrep_d=sym_abelian_axis(geom,axis)
            call sym_irrepname(geom,irrep_d+1,irrepname)
            if (nodezero.and.util_print('mod1',print_default)) then
              write(LuOut,*)
              write(LuOut,9440) axisname(axis),irrepname
            endif
            irrep_o=irrep_d
            irrep_x=irrep_d
c
          do omegasign=1,dynfreq
c            if (nodezero) write(LuOut,*) "omegasign is go"
            if (omegasign.eq.1) then
              omega1 = (1.0d0)*afreq(omegacount)
              dynaxis = 0
            elseif (omegasign.eq.2) then
              omega1 = (-1.0d0)*afreq(omegacount)
              dynaxis = 3
            endif
            if (nodezero) write(LuOut,9431) omega1
c            if (nodezero) write(LuOut,*) "omega1 = ",omega1
c            if (nodezero) write(LuOut,*) "dynaxis = ",dynaxis
c
            call tce_diis_init()
            do iter=1,maxiter
              cpu=-util_cpusec()
              wall=-util_wallsec()
              if (nodezero.and.(iter.eq.1))
     &          write(LuOut,9400) "CCSDTQ-LR"
c
              call tce_filename(rr1filename(axis),filename)
              call createfile(filename,d_rr1(axis),size_tr1(axis))
              call tce_zero(d_rr1(axis),size_tr1(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega1,d_tr1(axis+dynaxis),
     1             d_rr1(axis),size_tr1(axis))
c        write(LuOut,*) "eomccsdtq_x1"
              call eomccsdtq_x1(d_f1,d_rr1(axis),d_t1,d_t2,d_v2,
     1             d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),k_f1_offset,
     3             k_tr1_offset(axis),
     4             k_t1_offset,k_t2_offset,k_v2_offset,
     5             k_tr1_offset(axis),k_tr2_offset(axis),
     6             k_tr3_offset(axis))
c        write(LuOut,*) "ccsdtq1_o1"
              call ccsdtq_o1(d_rr1(axis),d_d1(axis),d_t1,d_t2,
     &             k_tr1_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset)
c
              call tce_filename(rr2filename(axis),filename)
              call createfile(filename,d_rr2(axis),size_tr2(axis))
              call tce_zero(d_rr2(axis),size_tr2(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega1,d_tr2(axis+dynaxis),
     1             d_rr2(axis),size_tr2(axis))
c        write(LuOut,*) "eomccsdtq_x2"
              call eomccsdtq_x2(d_f1,d_rr2(axis),d_t1,d_t2,d_t3,d_v2,
     1             d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),d_tr4(axis+dynaxis),
     3             k_f1_offset,k_tr2_offset(axis),
     4             k_t1_offset,k_t2_offset,k_t3_offset,k_v2_offset,
     5             k_tr1_offset(axis),k_tr2_offset(axis),
     6             k_tr3_offset(axis),k_tr4_offset(axis))
c        write(LuOut,*) "ccsdtq_o2"
              call ccsdtq_o2(d_rr2(axis),d_d1(axis),d_t1,d_t2,d_t3,
     &             k_tr2_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset,k_t3_offset)
c
              call tce_filename(rr3filename(axis),filename)
              call createfile(filename,d_rr3(axis),size_tr3(axis))
              call tce_zero(d_rr3(axis),size_tr3(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega1,d_tr3(axis+dynaxis),
     1             d_rr3(axis),size_tr3(axis))
c        write(LuOut,*) "eomccsdtq_x3"
              call eomccsdtq_x3(d_f1,d_rr3(axis),d_t1,d_t2,d_t3,d_t4,
     1             d_v2,d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),d_tr4(axis+dynaxis),
     3             k_f1_offset,k_tr3_offset(axis),
     4             k_t1_offset,k_t2_offset,k_t3_offset,k_t4_offset,
     5             k_v2_offset,
     6             k_tr1_offset(axis),k_tr2_offset(axis),
     7             k_tr3_offset(axis),k_tr4_offset(axis))
c        write(LuOut,*) "ccsdtq_o3"
              call ccsdtq_o3(d_rr3(axis),d_d1(axis),d_t1,d_t2,d_t3,d_t4,
     &             k_tr3_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset,k_t3_offset,k_t4_offset)
c
              call tce_filename(rr4filename(axis),filename)
              call createfile(filename,d_rr4(axis),size_tr4(axis))
              call tce_zero(d_rr4(axis),size_tr4(axis))
c        write(LuOut,*) "daxpyfile"
              call daxpyfile(1,(-1.0d0)*omega1,d_tr4(axis+dynaxis),
     1             d_rr4(axis),size_tr4(axis))
c        write(LuOut,*) "eomccsdtq_x4"
              call eomccsdtq_x4(d_f1,d_rr4(axis),d_t1,d_t2,d_t3,d_t4,
     1             d_v2,d_tr1(axis+dynaxis),d_tr2(axis+dynaxis),
     2             d_tr3(axis+dynaxis),d_tr4(axis+dynaxis),
     3             k_f1_offset,k_tr4_offset(axis),
     4             k_t1_offset,k_t2_offset,k_t3_offset,k_t4_offset,
     5             k_v2_offset,
     6             k_tr1_offset(axis),k_tr2_offset(axis),
     7             k_tr3_offset(axis),k_tr4_offset(axis))
c        write(LuOut,*) "ccsdtq_o4"
              call ccsdtq_o4(d_rr4(axis),d_d1(axis),d_t1,d_t2,d_t3,d_t4,
     &             k_tr4_offset(axis),k_d1_offset(axis),
     &             k_t1_offset,k_t2_offset,k_t3_offset,k_t4_offset)
c
c        write(LuOut,*) "reconcilefile"
              call reconcilefile(d_rr1(axis),size_tr1(axis))
              call reconcilefile(d_rr2(axis),size_tr2(axis))
              call reconcilefile(d_rr3(axis),size_tr3(axis))
              call reconcilefile(d_rr4(axis),size_tr4(axis))
c        write(LuOut,*) "tce_residual_tr1"
              call tce_residual_tr1(d_rr1(axis),k_tr1_offset(axis),rr1)
c        write(LuOut,*) "tce_residual_tr2"
              call tce_residual_tr2(d_rr2(axis),k_tr2_offset(axis),rr2)
c        write(LuOut,*) "tce_residual_tr3"
              call tce_residual_tr3(d_rr3(axis),k_tr3_offset(axis),rr3)
c        write(LuOut,*) "tce_residual_tr4"
              call tce_residual_tr4(d_rr4(axis),k_tr4_offset(axis),rr4)
              residual = max(rr1,rr2,rr3,rr4)
              cpu=cpu+util_cpusec()
              wall=wall+util_wallsec()
              if (nodezero) write(LuOut,9420) iter,residual,cpu,wall
              if (residual .lt. thresh) then
                if (nodezero) write(LuOut,9410)
                call deletefile(d_rr4(axis))
                call deletefile(d_rr3(axis))
                call deletefile(d_rr2(axis))
                call deletefile(d_rr1(axis))
                call tce_diis_tidy()
                goto 2438
              endif
              call tce_diis2(.false.,iter,.true.,.true.,.true.,.true.,
     1             d_rr1(axis),d_tr1(axis+dynaxis),k_tr1_offset(axis),
     2             size_tr1(axis),
     3             d_rr2(axis),d_tr2(axis+dynaxis),k_tr2_offset(axis),
     4             size_tr2(axis),
     5             d_rr3(axis),d_tr3(axis+dynaxis),k_tr3_offset(axis),
     6             size_tr3(axis),
     7             d_rr4(axis),d_tr4(axis+dynaxis),k_tr4_offset(axis),
     8             size_tr4(axis))
              call deletefile(d_rr4(axis))
              call deletefile(d_rr3(axis))
              call deletefile(d_rr2(axis))
              call deletefile(d_rr1(axis))
              if (nodezero) call util_flush(LuOut)
            enddo ! iter loop
          call errquit('tce_property: maxiter exceeded',iter,CALC_ERR)
 2438 continue
c
          enddo ! omegasign loop
          endif ! respaxis(axis)
          enddo ! axis loop
c
c         Evaluate Dipole Polarizability
c
          do axisA = 1, 3
          do axisB = 1, axisA
          if (respaxis(axisA).and.respaxis(axisB)) then
            irrep_a=sym_abelian_axis(geom,axisA)
            irrep_b=sym_abelian_axis(geom,axisB)
            irrep_y=irrep_g
c
c            if (nodezero) write(LuOut,*) "axisA = ",axisA
c            if (nodezero) write(LuOut,*) "axisB = ",axisB
c
            alpha(axisA,axisB)=0.0d0
c
            call tce_filename('a0',filename)
            call createfile(filename,d_a0,size_a0)
c
              alpha1=0.0d0
              alpha2=0.0d0
c
              if (omega1.ne.0.0d0) then
                dynaxis = 3
              else
                dynaxis = 0
              endif
c
              irrep_c=irrep_a
              irrep_oa=irrep_a
              irrep_ob=irrep_b
              irrep_tra=irrep_a
              irrep_trb=irrep_b
c              if (nodezero) write(LuOut,*) "ccsdtq_lr_alpha"
              call ccsdtq_lr_alpha(d_f1,d_a0,d_d1(axisA),d_d1(axisB),
     1             d_t1,d_t2,d_t3,d_t4,
     2             d_tr1(axisA+dynaxis),d_tr2(axisA+dynaxis),
     3             d_tr3(axisA+dynaxis),d_tr4(axisA+dynaxis),
     4             d_tr1(axisB),d_tr2(axisB),d_tr3(axisB),d_tr4(axisB),
     5             d_v2,d_lambda1,d_lambda2,d_lambda3,d_lambda4,
     6             k_f1_offset,k_a0_offset,k_d1_offset(axisA),
     7             k_d1_offset(axisB),k_t1_offset,k_t2_offset,
     8             k_t3_offset,k_t4_offset,k_tr1_offset(axisA),
     9             k_tr2_offset(axisA),k_tr3_offset(axisA),
     1             k_tr4_offset(axisA),k_tr1_offset(axisB),
     2             k_tr2_offset(axisB),k_tr3_offset(axisB),
     3             k_tr4_offset(axisB),k_v2_offset,k_l1_offset,
     4             k_l2_offset,k_l3_offset,k_l4_offset)
c
              call reconcilefile(d_a0,size_a0)
              call get_block(d_a0,alpha1,1,0)
              call tce_zero(d_a0,size_a0)
c              write(LuOut,*) "alpha1 = ",alpha1
c
              if (omega1.eq.0.0d0) then
                alpha2=alpha1
              else
c                if (nodezero) write(LuOut,*) "ccsdtq_lr_alpha"
                call ccsdtq_lr_alpha(d_f1,d_a0,d_d1(axisA),d_d1(axisB),
     1             d_t1,d_t2,d_t3,d_t4,
     2             d_tr1(axisA),d_tr2(axisA),d_tr3(axisA),d_tr4(axisA),
     3             d_tr1(axisB+dynaxis),d_tr2(axisB+dynaxis),
     4             d_tr3(axisB+dynaxis),d_tr4(axisB+dynaxis),
     5             d_v2,d_lambda1,d_lambda2,d_lambda3,d_lambda4,
     6             k_f1_offset,k_a0_offset,k_d1_offset(axisA),
     7             k_d1_offset(axisB),k_t1_offset,k_t2_offset,
     8             k_t3_offset,k_t4_offset,k_tr1_offset(axisA),
     9             k_tr2_offset(axisA),k_tr3_offset(axisA),
     1             k_tr4_offset(axisA),k_tr1_offset(axisB),
     2             k_tr2_offset(axisB),k_tr3_offset(axisB),
     3             k_tr4_offset(axisB),k_v2_offset,k_l1_offset,
     4             k_l2_offset,k_l3_offset,k_l4_offset)
c
                call reconcilefile(d_a0,size_a0)
                call get_block(d_a0,alpha2,1,0)
                call tce_zero(d_a0,size_a0)
              endif ! axisA.eq.axisB
c              write(LuOut,*) "alpha2 = ",alpha2
c
              alpha(axisA,axisB)=(-0.5d0)*(alpha1+alpha2)
c
            call deletefile(d_a0)
c
c            write(LuOut,*) "alpha(axisA,axisB) = ",alpha(axisA,axisB)
c            if (nodezero) write(LuOut,9020) cpu, wall
c
          endif ! respaxis(axis)
          enddo ! axisB loop
          enddo ! axisA loop
c
          if (nodezero) write(LuOut,9434) "CCSDTQ Linear Response",
     1        afreq(omegacount),
     2        alpha(1,1),alpha(2,1),alpha(3,1),
     3        alpha(2,1),alpha(2,2),alpha(3,2),
     4        alpha(3,1),alpha(3,2),alpha(3,3)
          if (nodezero) write(LuOut,9020) cpu, wall
          call util_flush(LuOut)
c
          enddo ! omegacount loop
c
        endif ! lineresp
c
      endif ! model
  100 continue
c
      if (nodezero) call util_flush(LuOut)
c
      tce_property=.true.
c
c      endif
c
c     ===========================
c     End of all TCE calculations
c     ===========================
c
c->d3p975
      do i = 1, ipol
        if (.not.ga_destroy(g_movecs(i)))
     1    call errquit('tce_property: GA problem',0,GA_ERR)
      enddo
c<-d3p975
c
      call deletefile(d_v2)
c      if (multipole.gt.0) then
c        do l_shell = multipole,1,-1
c          l_sh_size = (l_shell+1)*(l_shell+2)/2
c          do l_subshell = 1, l_sh_size
cccc            call deletefile(d_mo_mp1(l_shell,l_subshell))
c          enddo
c        enddo
c      endif
      if (left) then
        do axis=3,1,-1
          call deletefile(d_d1(axis))
        enddo
      endif
c      call deletefile(d_f1)
      if (needt4) then
        if (leftresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_yr4(axis))
            call deletefile(d_yr4(axis+3))
            if (.not.ma_pop_stack(l_yr4_offset(axis)))
     1        call errquit("tce_property: MA problem",86,MA_ERR)
          endif
          enddo ! axis
        endif ! leftresp
        if (lineresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_tr4(axis))
            call deletefile(d_tr4(axis+3))
            if (.not.ma_pop_stack(l_tr4_offset(axis)))
     1        call errquit("tce_property: MA problem",89,MA_ERR)
          endif
          enddo ! axis
        endif ! lineresp
        if (left) then
          call deletefile(d_lambda4)
          if (.not.ma_pop_stack(l_l4_offset))
     1      call errquit("tce_property: MA problem",26,MA_ERR)
        endif
        call deletefile(d_t4)
        if (.not.ma_pop_stack(l_t4_offset))
     1    call errquit("tce_property: MA problem",26,MA_ERR)
      endif
      if (needt3) then
        if (leftresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_yr3(axis))
            call deletefile(d_yr3(axis+3))
            if (.not.ma_pop_stack(l_yr3_offset(axis)))
     1        call errquit("tce_property: MA problem",86,MA_ERR)
          endif
          enddo ! axis
        endif ! leftresp
        if (lineresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_tr3(axis))
            call deletefile(d_tr3(axis+3))
            if (.not.ma_pop_stack(l_tr3_offset(axis)))
     1        call errquit("tce_property: MA problem",88,MA_ERR)
          endif
          enddo ! axis
        endif ! lineresp
        if (left) then
          call deletefile(d_lambda3)
          if (.not.ma_pop_stack(l_l3_offset))
     1      call errquit("tce_property: MA problem",25,MA_ERR)
        endif
        call deletefile(d_t3)
        if (.not.ma_pop_stack(l_t3_offset))
     1    call errquit("tce_property: MA problem",25,MA_ERR)
      endif
      if (needt2) then
        if (leftresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_yr2(axis))
            call deletefile(d_yr2(axis+3))
            if (.not.ma_pop_stack(l_yr2_offset(axis)))
     1        call errquit("tce_property: MA problem",86,MA_ERR)
          endif
          enddo ! axis
        endif ! leftresp
        if (lineresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_tr2(axis))
            call deletefile(d_tr2(axis+3))
            if (.not.ma_pop_stack(l_tr2_offset(axis)))
     1        call errquit("tce_property: MA problem",87,MA_ERR)
          endif
          enddo ! axis
        endif ! lineresp
        if (left) then
          call deletefile(d_lambda2)
          if (.not.ma_pop_stack(l_l2_offset))
     1      call errquit("tce_property: MA problem",0,MA_ERR)
        endif
        call deletefile(d_t2)
        if (.not.ma_pop_stack(l_t2_offset))
     1    call errquit("tce_property: MA problem",0,MA_ERR)
      endif
      if (needt1) then
        if (leftresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_yr1(axis))
            call deletefile(d_yr1(axis+3))
            if (.not.ma_pop_stack(l_yr1_offset(axis)))
     1        call errquit("tce_property: MA problem",86,MA_ERR)
          endif
          enddo ! axis
        endif ! leftresp
        if (lineresp) then
          do axis = 3, 1, -1
          if (respaxis(axis)) then
            call deletefile(d_tr1(axis))
            call deletefile(d_tr1(axis+3))
            if (.not.ma_pop_stack(l_tr1_offset(axis)))
     1        call errquit("tce_property: MA problem",86,MA_ERR)
          endif
          enddo ! axis
        endif ! lineresp
        if (left) then
          call deletefile(d_lambda1)
          if (.not.ma_pop_stack(l_l1_offset))
     1      call errquit("tce_property: MA problem",1,MA_ERR)
        endif
        call deletefile(d_t1)
        if (.not.ma_pop_stack(l_t1_offset))
     1    call errquit("tce_property: MA problem",1,MA_ERR)
      endif
      if(intorb) then
       if (.not.ma_pop_stack(l_v2spin_offset))
     1  call errquit("tce_property: MA problem",59,MA_ERR)
c--       if (.not.ma_pop_stack(l_o2ot_offset))
c--     1  call errquit("tce_property: MA problem",58,MA_ERR)
c--       if (.not.ma_pop_stack(l_o2o_offset))
c--     1  call errquit("tce_property: MA problem",57,MA_ERR)
       if (.not.ma_pop_stack(l_v2_alpha_offset))
     1  call errquit("tce_property: MA problem",56,MA_ERR)
      end if
      if(.not.intorb) then
      if (.not.ma_pop_stack(l_v2_offset))
     1  call errquit("tce_property: MA problem",2,MA_ERR)
      end if
c      if (.not.ma_pop_stack(l_f1_offset))
c     1  call errquit("tce_property: MA problem",3,MA_ERR)
c      if (multipole.gt.0) then
c        do l_shell = multipole,1,-1
c          l_sh_size = (l_shell+1)*(l_shell+2)/2
c          if(nodezero) write(LuOut,*) 'l_shell = ',l_shell
c          if(nodezero) write(LuOut,*) 'l_sh_size = ',l_sh_size
c          do l_subshell = 1, l_sh_size
c            if(nodezero) write(LuOut,*) 'l_subshell = ',l_subshell
cccc            if (.not.ma_pop_stack(l_mo_mp1_offset(l_shell,l_subshell)))
cccc     1        call errquit("tce_property: MA problem",100,MA_ERR)
c          enddo
c        enddo
c      endif
      if (left) then
        do axis=3,1,-1
          if (.not.ma_pop_stack(l_d1_offset(axis)))
     1      call errquit("tce_property: MA problem",3,MA_ERR)
        enddo
      endif
      if(intorb) then
       if (.not.ma_pop_stack(l_offset_alpha))
     1  call errquit("tce_property: MA problem",55,MA_ERR)
       if (.not.ma_pop_stack(l_range_alpha))
     1  call errquit("tce_property: MA problem",54,MA_ERR)
       if (.not.ma_pop_stack(l_sym_alpha))
     1  call errquit("tce_property: MA problem",53,MA_ERR)
       if (.not.ma_pop_stack(l_spin_alpha))
     1  call errquit("tce_property: MA problem",52,MA_ERR)
       if (.not.ma_pop_stack(l_b2am))
     1  call errquit("tce_property: MA problem",51,MA_ERR)
      end if
c ---
      if (.not.ma_pop_stack(l_alpha))
     1  call errquit("tce_property: MA problem",4,MA_ERR)
      if (.not.ma_pop_stack(l_offset))
     1  call errquit("tce_property: MA problem",5,MA_ERR)
      if (.not.ma_pop_stack(l_range))
     1  call errquit("tce_property: MA problem",6,MA_ERR)
      if (.not.ma_pop_stack(l_sym))
     1  call errquit("tce_property: MA problem",7,MA_ERR)
      if (.not.ma_pop_stack(l_spin))
     1  call errquit("tce_property: MA problem",8,MA_ERR)
      if (.not.ma_pop_stack(l_evl_sorted))
     1  call errquit("tce_property: MA problem",9,MA_ERR)
      if (.not.ma_pop_stack(l_irs_sorted))
     1  call errquit("tce_property: MA problem",10,MA_ERR)
      if (.not.ma_pop_stack(l_spin_sorted))
     1  call errquit("tce_property: MA problem",11,MA_ERR)
      if (.not.ma_pop_stack(l_movecs_sorted))
     1  call errquit("tce_property: MA problem",12,MA_ERR)
c
c     ===============
c     Destroy a mutex
c     ===============
c
      if (.not.ga_destroy_mutexes())
     1  call errquit('tce_property: GA problem',1,GA_ERR)
c
c     =========
c     Terminate
c     =========
c
      call tce_tidy(rtdb)
      call util_print_pop
      return
c
c     ======
c     Format
c     ======
c
 9000 format(1x,A,' file size   = ',i16)
 9010 format(1x,A,' file name   = ',A)
 9090 format(1x,A,' file handle = ',i10)
 9020 format(1x,'Cpu & wall time / sec',2f15.1)
 9480 format(1x,'Cpu & wall time / sec for ',A,2f15.1)
 9110 format(1x,'MBPT(0) energy / hartree             = ',f25.15)
 9030 format(/,1x,'MBPT(2) correlation energy / hartree = ',f25.15)
 9040 format(1x,'MBPT(2) total energy / hartree       = ',f25.15)
 9050 format(/,1x,A,' iterations',/,
     1  1x,'--------------------------------------------------------',/
     2  1x,'Iter          Residuum       Correlation     Cpu    Wall',/
     3  1x,'--------------------------------------------------------')
 9060 format(
     1  1x,'--------------------------------------------------------',/
     2  1x,'Iterations converged')
 9070 format(1x,A,' correlation energy / hartree = ',f25.15)
 9080 format(1x,A,' total energy / hartree       = ',f25.15)
 9085 format(1x,A,' excitation energy (eV)       = ',f12.5)
 9100 format(1x,i4,2f18.13,2f8.1)
 9120 format(1x,A)
 9123 format(1x,'4-index algorithm nr.',i4,1x,'is used') 
 9124 format(1x,'imaxsize = ',2x,i6)
 9125 format(1x,'imaxsize ichop = ',2x,2i6)
 9250 format(1x,'Ground-state symmetry is ',A4)
 9200 format(1x,'=========================================',/,
     1       1x,'Excited-state calculation ( ',A4,'symmetry)',/,
     2       1x,'=========================================')
 9210 format(/,1x,'Iteration ',i3,' using ',i4,' trial vectors')
 9220 format(/,1x,A,' iterations',/,1x,
     1'--------------------------------------------------------------'
     2,/,1x,
     3'     Residuum       Omega / hartree  Omega / eV    Cpu    Wall'
     4,/,1x,
     5'--------------------------------------------------------------')
 9230 format(1x,f17.13,f18.13,f11.5,2f8.1)
 9240 format(1x,
     1'--------------------------------------------------------------'
     2,/,1x,'Iterations converged')
 9300 format(' Target root     =',i3)
 9340 format(' Target symmetry =',1x,a4)
 9310 format(1x,A,' ground state energy / hartree  =',f25.15)
 9320 format(1x,A,' excitation energy / hartree    =',f25.15)
 9330 format(1x,A,' excited state energy / hartree =',f25.15)
 9350 format(1x,'Evaluating ',A)
 9400 format(/,1x,A,' iterations',/,
     1  1x,'--------------------------------------',/
     2  1x,'Iter          Residuum     Cpu    Wall',/
     3  1x,'--------------------------------------')
 9410 format(
     1  1x,'--------------------------------------',/
     2  1x,'Iterations converged')
 9420 format(1x,i4,f18.13,2f8.1)
 9430 format(/,1x,A,' dipole moments / hartree & Debye',/,
     1  1x,'--------------------------------',/
     2  1x,'X ',2f15.7,/
     3  1x,'Y ',2f15.7,/
     4  1x,'Z ',2f15.7,/
     5  1x,'--------------------------------')
 9431 format(/,1x,'Frequency = ',f7.5,' / au')
 9434 format(/,1x,A,' polarizability / au ',/
     1  1x,'Frequency = ',f7.5,' / au',/
     2  1x,'      X              Y              Z',/
     3  1x,'-----------------------------------------------',/
     4  1x,'X ',3f15.7,/
     5  1x,'Y ',3f15.7,/
     6  1x,'Z ',3f15.7,/
     7  1x,'-----------------------------------------------')
 9440 format(1x,A1,' axis ( ',A4,'symmetry)')
 9450 format(1x,'(T) & [T] code has been provided by ',
     1  'A.A.Auer (Waterloo)')
 9460 format(/,1x,'Excited state root',i3,/
     1       1x,'Excitation energy / hartree =',f25.15,/
     2       1x,'                  / eV      =',f25.15)
 9470 format(/,1x,A,' transition moments / hartree',/
     1  1x,'--------------------------------------------',/
     2  1x,'X',f13.7,' Y',f13.7,' Z',f13.7,/
     3  1x,'Oscillator Strength            ',f13.7,/
     4  1x,'--------------------------------------------')
 9501 format(/,1x,A,' hyperpolarizability / au ')
c Use 9431 for frequency
 9502 format(1x,'-----------------------------------------------')
 9503 format(1x,'beta(',a1,',',a1,',',a1,') = ',f13.7,a)
 9504 format(1x,'Static Hyperpolarizability')
 9505 format(1x,'Second Harmonic Generation (SHG)')
 9506 format(1x,'Optical Rectification (OR)')
 9507 format(1x,'Electro-Optic Pockels Effect (EOPE)')
 9508 format(1x,'beta(',f1.5,',',f1.5,',',f1.5,')')
      end
