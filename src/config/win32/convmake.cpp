// $Id: convmake.cpp,v 1.1 2000-07-27 15:54:44 bjohnson Exp $

/*
 * Program for converting an NWChem GNUmakefile to a WIN32 nmake MakeFile
 *
 * BGJ (7/00)
 */

#include "TokenList.h"
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sys/stat.h>

#include <assert.h>
#define ASSERT assert

using namespace std;

string GetFileAsString(const string& Filename);
string GetSection(const string& Filename, const string& SecName);
void ConvertSection(ostream& os, const string& Sec);
void PrintSection(ostream& os, const string& Sec, bool SetNewline = false);
void PrintSectionSpecial(ostream& os, const string& Sec, const string& SecName,
                         bool SetNewline = false);
string ConvertToken(const string& T);

bool DoNewline = false;
void ProcessNewline(ostream& os)
{
  if (DoNewline) {
    os << endl;
    DoNewline = false;
  }
}

int main(int argc, char* argv[])
{
  string InFilename = "GNUmakefile";
  string OutFilename = "MakeFile";

  // Key that tells us a MakeFile has been automatically generated
  string AutoKey = "#\n# Automatically generated WIN32 MakeFile - do not edit\n#\n";

  // Check whether output file already exists, and if so, whether it was auto-generated
  bool PreExists, AutoGenerated;
  {
    ifstream is(OutFilename.c_str());
    PreExists = is.good();
  }
  if (PreExists) {
    string S = GetFileAsString(OutFilename);
    string::size_type pos = S.find(AutoKey);
    AutoGenerated = pos != string::npos;
    if (AutoGenerated)
      ASSERT(pos == 0); // Key should be at the start or something funny is going on

    if (!AutoGenerated)
      cout << "Special-case " << OutFilename << " exists - aborting" << endl;
  }

  if (PreExists && !AutoGenerated) return 0;

  ofstream os(OutFilename.c_str());
  ASSERT(os);

  // Identify this MakeFile as auto-generated
  os << AutoKey << endl;

  PrintSection(os,GetSection(InFilename,"SUBDIRS"),true);
  ProcessNewline(os);

  // Easy way to convert commented-out object lists
//  ConvertSection(os,GetSection(InFilename,"OBJ_COMMENT"));
//  ConvertSection(os,GetSection(InFilename,"OBJ_OPTIMIZE_COMMENT"));

  ConvertSection(os,GetSection(InFilename,"OBJ_OPTIMIZE"));
  ConvertSection(os,GetSection(InFilename,"OBJ"));
  ConvertSection(os,GetSection(InFilename,"HEADERS"));

  TokenList TL(GetSection(InFilename,"LIBRARY")," =\\\n");
  if (!TL.empty()) {
    int LibLen = TL[1].length() - 5;
    ASSERT(LibLen > 0);
    os << "LIBRARY = " << TL[1].substr(3,LibLen) << ".lib" << endl;
  }

  PrintSectionSpecial(os,GetSection(InFilename,"LIB_DEFINES"),"LIB_DEFINES");
  PrintSection(os,GetSection(InFilename,"LIB_INCLUDES"));
  os << endl;
  PrintSection(os,GetSection(InFilename,"LIB_TARGETS"),true);
  PrintSection(os,GetSection(InFilename,"TESTLIBS"),true);
  ProcessNewline(os);

  string IncludeSec = GetSection(InFilename,"include");
  TL.assign(IncludeSec," /");
  string DotDots;
  for (TokenList::const_iterator i = TL.begin()+1; *i == ".."; ++i)
    DotDots += "..\\";
  os << "!INCLUDE " << DotDots << "config\\NTmakefile.h" << endl;
  os << "!INCLUDE " << DotDots << "config\\NTmakelib.h" << endl;

#if 0
  // Dump input file contents into comment section so we can edit if necessary

  os << endl << "!IF 0\n" << endl;
  ifstream is(InFilename);
  ASSERT(is);
  char c;
  while (is.get(c))
    os << c;
  os << "\n!ENDIF" << endl;
#endif

  return 0;
}

string GetFileAsString(const string& Filename)
{
  // Create string of correct length at the outset - avoids inefficiency
  // of frequent resizing as the string grows
  struct _stat stats;
  int ret = _stat(Filename.c_str(), &stats);
  ASSERT(ret == 0);
  string s(stats.st_size, ' ');

  // Read the file contents into the pre-set string
  ifstream is(Filename.c_str());
  ASSERT(is);
  string::iterator i = s.begin();
  while (is.get(*i++))
    ;

  return s;
}

string GetSection(const string& Filename, const string& Sec)
{
  ifstream is(Filename.c_str());
  ASSERT(is);

  TokenList TL;
  bool Found = false;
  do {
    is >> TL;
    if (!TL.empty()) {
      TokenList TL2(TL[0],"=\\");
      Found = TL2[0] == Sec;
    }
  } while(!Found && is);

  if (Found) { // Get the rest of the lines in the section
    while (*(TL.rbegin()->rbegin()) == '\\') {
      TokenList TL2;
      is >> TL2;
      TL += TL2;
    }
  }

  return TL.getString();
}

void ConvertSection(ostream& os, const string& Sec)
{
  if (Sec.length() == 0) return;
  TokenList TL(Sec," =\\\n");
  string S1, S2;
  for (TokenList::const_iterator i = TL.begin()+1; i != TL.end(); ++i) {
    S1 = (i == TL.begin()+1) ? (TL[0] + " = ") : " ";
    S2 = (i == TL.end()-1) ? "" : " \\";
    left(os);
    os << setw(15) << S1 << ConvertToken(*i) << S2 << endl;
  }
  os << endl;
}

void PrintSection(ostream& os, const string& Sec, bool SetNewline)
{
  if (Sec.length() == 0) return;
  TokenList TL(Sec," =\\\n");
  // Don't print an empty list
  if (TL.size() < 2) return;
  os << TL[0] << " =";
  for (TokenList::const_iterator i = TL.begin()+1; i != TL.end(); ++i)
    os << " " << ConvertToken(*i);
  os << endl;
  if (SetNewline) DoNewline = true;
}

void PrintSectionSpecial(ostream& os, const string& Sec, const string& SecName,
                         bool SetNewline)
{
  if (Sec.length() == 0) return;
  TokenList TL(Sec," \\\n");
  TokenList::const_iterator i = TL.begin();
  bool Stop;
  do {
    Stop = *(i->rbegin()) == '=';
    ++i;
  } while (!Stop && i != TL.end());
  // Don't print an empty list
  if (i == TL.end()) return;
  os << SecName << " =";
  for (; i != TL.end(); ++i)
    os << " " << ConvertToken(*i);
  os << endl;
  if (SetNewline) DoNewline = true;
}

string ConvertToken(const string& T)
{
  string S = T;
  string S1(""), S2("");
  if (T.length() > 2 && T.substr(T.length()-2,2) == ".o") {
    S1 = "$(OBJDIR)\\";
    S2 = "bj";
  }
  for (string::iterator i = S.begin(); i != S.end(); ++i)
    if (*i == '/') *i = '\\';
  return S1 + S + S2;
}
