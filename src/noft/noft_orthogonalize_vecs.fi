!-----------------------------------------------------------------------
!
!>
!>    \brief Orthonormalize the vectors 
!>
!>    This subroutine ortho-normalizes all vectors making up the 
!>    wavefunction, i.e. the natural orbitals as well as the correlation
!>    functions. 
!>
      subroutine noft_orthogonalize(noft_wavefunction)
      implicit none
!>    The wavefunction
      type(noft_wavefunction_tp), intent(inout) :: noft_wavefunction
!
      integer :: idum  ! dummy variable
!
      idum = 0
      call noft_orthogonalize_vecs(noft_wavefunction%to_a,idum,.false.)
      call noft_orthogonalize_vecs(noft_wavefunction%to_b,idum,.false.)
      call noft_orthogonalize_vecs(noft_wavefunction%mo_a,idum,.false.)
      call noft_orthogonalize_vecs(noft_wavefunction%mo_b,idum,.false.)
!
      end subroutine noft_orthogonalize
!
!-----------------------------------------------------------------------
!
!> \brief Orthogonalize a set of complex or double vectors
!>
!> Orthogonalize a set of vectors in either an orthogonal basis or 
!> a non-orthogonal basis:
!> - ometric = .false. the vectors are given in an orthogonal basis
!>   and `g_over` is not used
!> - ometric = .true.  the vectors are given in a non-orthogonal bais
!>   in which `g_over` contains the overlap matrix
!> The vector may be real or complex:
!> - if `g_vecs` is real then g_over is also real
!> - if `g_vecs` is complex then g_over is also complex and Hermitian
!>
      subroutine noft_orthogonalize_vecs(g_vecs, g_over, ometric)
      implicit none
#include "errquit.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "msgids.fh"
      integer, intent(in) :: g_vecs, g_over
      logical, intent(in) :: ometric
!
      character(len=22), parameter :: pname = "noft_orthogonalize_vecs:"
!
      integer ulo, uhi, itypv, ityps, ni, nu, uchunk, ld
      integer mu, mv
      integer l_tmp, l_s, l_over, l_w
      integer k_tmp, k_s, k_over, k_w
!
      real(kind=dp),    allocatable :: dvec(:,:)
      real(kind=dp),    allocatable :: dovl(:,:)
      real(kind=dp),    allocatable :: dsij(:)
      real(kind=dp),    allocatable :: dw(:)
!
      complex(kind=dp), allocatable :: zvec(:,:)
      complex(kind=dp), allocatable :: zovl(:,:)
      complex(kind=dp), allocatable :: zsij(:)
      complex(kind=dp), allocatable :: zw(:)
!     
!     Redistribute the input matrix ... block the leading
!     dimension, leave second dimension undistributed
!     ... each process has a(ulo:uhi,1:ni).  If
!
!     nu = no. of basis functions
!     ni = no. of vectors
!
!     overlap should be (nu,nu)
!
      call ga_inquire(g_vecs, itypv, nu, ni)
      if (ometric) then
        call ga_inquire(g_over, ityps, mu, mv)
        if (itypv.ne.ityps) then
          call errquit(pname//' vectors and overlap not '//
     &                 'of same type',10,UERR)
        endif
      endif
      uchunk = max(8, (nu+ga_nnodes()-1)/ga_nnodes())
      ulo  = ga_nodeid()*uchunk + 1
      uhi  = min(ulo + uchunk - 1, nu)
      ld   = uhi - ulo + 1
      if (ulo .gt. uhi) then
         ulo = 0
         uhi = -1
         ld  = 1
      end if
!
!     Allocate local workspace
!
      if      (itypv.eq.MT_DBL) then
        if (ulo.gt.0) then
          allocate(dvec(ulo:uhi,1:ni))
          if (ometric) then
            allocate(dovl(1:nu,ulo:uhi))
          endif
          allocate(dsij(1:ni))
          allocate(dw(1:nu))
        endif
      else if (itypv.eq.MT_DCPL) then
        if (ulo.gt.0) then
          allocate(zvec(ulo:uhi,1:ni))
          if (ometric) then
            allocate(zovl(1:nu,ulo:uhi))
          endif
          allocate(zsij(1:ni))
          allocate(zw(1:nu))
        endif
      else
        call errquit(pname//" unsupported type",20,UERR)
      endif
!
      call ga_sync()
      if (uhi.ge.ulo) then
        if      (itypv.eq.MT_DBL) then
          call ga_get(g_vecs, ulo, uhi, 1, ni, dvec, ld)
          if (ometric) call ga_get(g_over, 1, nu, ulo, uhi, dovl, nu)
        else if (itypv.eq.MT_DCPL) then
          call ga_get(g_vecs, ulo, uhi, 1, ni, zvec, ld)
          if (ometric) call ga_get(g_over, 1, nu, ulo, uhi, zovl, nu)
        else
          call errquit(pname//" unsupported type",30,UERR)
        endif
      endif
!
!     Do the deed
!
      if (itypv.eq.MT_DBL) then
        call noft_orthog_dvecs(dvec, ld, ni, ulo, uhi, dsij,
     &       dovl, nu, dw, ometric)
      else if (itypv.eq.MT_DCPL) then
        call noft_orthog_zvecs(zvec, ld, ni, ulo, uhi, zsij,
     &       zovl, nu, zw, ometric)
      else
        call errquit(pname//" unsupported type",40,UERR)
      endif
!
!     Put results back
!
      if (itypv.eq.MT_DBL) then
        if (uhi .ge. ulo) then
          call ga_put(g_vecs, ulo, uhi, 1, ni, dvec, ld)
        endif
      else if (itypv.eq.MT_DCPL) then
        if (uhi .ge. ulo) then
          call ga_put(g_vecs, ulo, uhi, 1, ni, zvec, ld)
        endif
      else
        call errquit(pname//" unsupported type",50,UERR)
      endif
!
!     Tidy up memory
!
      if (itypv.eq.MT_DBL) then
        if (ulo.gt.0) then
          deallocate(dvec)
          if (ometric) then
            deallocate(dovl)
          endif
          deallocate(dsij)
          deallocate(dw)
        endif
      else if (itypv.eq.MT_DCPL) then
        if (ulo.gt.0) then
          deallocate(zvec)
          if (ometric) then
            deallocate(zovl)
          endif
          deallocate(zsij)
          deallocate(zw)
        endif
      else
        call errquit(pname//" unsupported type",60,UERR)
      endif
!
      call ga_sync
!
      end subroutine noft_orthogonalize_vecs
!
!-----------------------------------------------------------------------
!
!> \brief Orthonormalize a set of vectors using local memory
!>
!> The vectors are stored in local memory. Each vector is distributed
!> across multiple processors. Each processor holds the same rows of 
!> all vectors. The vectors are real.
!>
!> The repeated Gramm-Schmidt algorithm is used.
!>
      subroutine noft_orthog_dvecs(vecs, ld, ni, ulo, uhi, s,
     &                                    o, nu, w, ometric)
      implicit none
#include "errquit.fh"
#include "msgids.fh"
c     
      integer, intent(in) :: ld, ni, ulo, uhi, nu
      real(kind=dp), intent(inout) :: 
!          Local patch of vectors
     &     vecs(ulo:(ulo+ld-1),1:ni),
!          workspace for making overlap
     &     s(ni),
!          workspace for making overlap
     &     w(nu)
      real(kind=dp), intent(in) :: 
!          metric matrix if (ometric)
     &     o(1:nu,ulo:(ulo+ld-1))
      logical, intent(in) :: ometric
!
      integer i, j, u, npass
      real(kind=dp) si, scale
!     
!     Orthogonalize columns of a matrix distributed so that
!     each process has vecs(ulo:uhi,1:ni) ... uses global sums only.
!     
      do i = 1, ni
        npass = 0
   10   npass = npass + 1
!     
!       If have a metric then first form overlap*vec(i)
!     
        if (ometric) then
          call dfill(nu, 0.0d0, w, 1)
          if ((uhi-ulo+1) .gt. 0) 
     &      call dgemv('n', nu, (uhi-ulo+1), 1.0d0, o, nu,
     &           vecs(ulo,i), 1, 0.0d0, w, 1)
          call ga_dgop(msg_orthog_1, w, nu, '+') ! Actually only need ulo:hi local
        else
          do u = ulo, uhi
            w(u) = vecs(u,i)
          end do
        end if
!     
!       Now form overlap between vector i and vectors 1...i
!     
        call dfill(i, 0.0d0, s, 1)
        if ((uhi-ulo+1) .gt. 0) then
          call dgemv('t', (uhi-ulo+1), i, 1.0d0,
     &         vecs(ulo,1), ld, w(ulo), 1, 0.0d0, s(1), 1)
        endif
        call ga_dgop(msg_orthog_2, s, i, '+')
!
!       Apply the projection
!     
        if ((uhi-ulo+1).gt.0 .and. i.gt.1) then
          call dgemv('n', (uhi-ulo+1), i-1, -1.0d0,
     &         vecs(ulo,1), ld, s(1), 1, 1.0d0, vecs(ulo,i), 1)
        end if
!     
!       Renormalize vector i
!     
        si = s(i)
        do j = 1, i-1
          si = si - s(j)*s(j)
        end do
        if (si .eq. 0.0d0) then
          call errquit('noft_orthog_dvecs: hard zero', i, GA_ERR)
        endif
        if (si .lt. 0.0d0) then
          write(6,*) 'Negative value orthog: ',si
          call errquit('noft_orthog_dvecs: negative', i, 0)
        endif
        scale = 1.0d0/sqrt(si)
        do u = ulo, uhi
          vecs(u,i) = vecs(u,i) * scale
        end do
!     
!       If the vector norm changed a lot then repeat
!     
        if (i .gt. 1) then
          scale = si/s(i)
          if (scale .lt. 0.9d0) then
            if (npass .lt. 3) then
              goto 10
            else
              call errquit('noft_orthog_dvecs: failed to orthog vector',
     &                     i, GA_ERR)
            end if
          end if
        end if
!
      end do
!
      end subroutine noft_orthog_dvecs
!
!-----------------------------------------------------------------------
!
!> \brief Orthonormalize a set of vectors using local memory
!>
!> The vectors are stored in local memory. Each vector is distributed
!> across multiple processors. Each processor holds the same rows of 
!> all vectors. The vectors are complex.
!>
!> The repeated Gramm-Schmidt algorithm is used.
!>
      subroutine noft_orthog_zvecs(vecs, ld, ni, ulo, uhi, s,
     &                                    o, nu, w, ometric)
      implicit none
#include "errquit.fh"
#include "msgids.fh"
c     
      integer, intent(in) :: ld, ni, ulo, uhi, nu
      complex(kind=8), intent(inout) :: 
!     Local patch of vectors
     &     vecs(ulo:(ulo+ld-1),1:ni),
!     workspace for making overlap
     &     s(ni),
!     workspace for making overlap
     &     w(nu)
      complex(kind=dp), intent(in) :: 
!          metric matrix if (ometric)
     &     o(1:nu,ulo:(ulo+ld-1))
      logical, intent(in) :: ometric
!
      integer i, j, u, npass
      complex(kind=dp) :: si, scale
      complex(kind=dp), parameter :: zero = complex(0.0d0,0.0d0)
      complex(kind=dp), parameter :: one  = complex(1.0d0,0.0d0)
!     
!     Orthogonalize columns of a matrix distributed so that
!     each process has vecs(ulo:uhi,1:ni) ... uses global sums only.
!     
      do i = 1, ni
        npass = 0
   10   npass = npass + 1
!     
!       If have a metric then first form overlap*vec(i)
!     
        if (ometric) then
          w = zero
          if ((uhi-ulo+1) .gt. 0) 
     &      call zgemv('n', nu, (uhi-ulo+1), one, o, nu,
     &           vecs(ulo,i), 1, zero, w, 1)
          call ga_zgop(msg_orthog_1, w, nu, '+') ! Actually only need ulo:hi local
        else
          do u = ulo, uhi
            w(u) = vecs(u,i)
          end do
        end if
!     
!       Now form overlap between vector i and vectors 1...i
!     
        s = zero
        if ((uhi-ulo+1) .gt. 0) then
          call zgemv('c', (uhi-ulo+1), i, one,
     &         vecs(ulo,1), ld, w(ulo), 1, zero, s(1), 1)
        endif
        call ga_zgop(msg_orthog_2, s, i, '+')
!
!       Apply the projection
!     
        if ((uhi-ulo+1).gt.0 .and. i.gt.1) then
          call zgemv('n', (uhi-ulo+1), i-1, -one,
     &         vecs(ulo,1), ld, s(1), 1, one, vecs(ulo,i), 1)
        end if
!     
!       Renormalize vector i
!     
        si = s(i)
        do j = 1, i-1
          si = si - s(j)*conjg(s(j))
        end do
!     
        if (abs(si) .eq. 0.0d0) then
          call errquit('noft_orthog_zvecs: hard zero', i, GA_ERR)
        endif
        scale = one/sqrt(si)
        do u = ulo, uhi
          vecs(u,i) = vecs(u,i) * scale
        end do
!     
!       If the vector norm changed a lot then repeat
!     
        if (i .gt. 1) then
          scale = si/s(i)
          if (abs(scale) .lt. 0.9d0) then
            if (npass .lt. 3) then
              goto 10
            else
              call errquit('noft_orthog_zvecs: failed to orthog vector',
     &                     i, GA_ERR)
            end if
          end if
        end if
!
      end do
!
      end subroutine noft_orthog_zvecs
!
!-----------------------------------------------------------------------
!
!>
!>    \brief Test routine for noft_ortho
!>
!>    This routine simply calls noft_ortho but then checks the results
!>    to make sure that the orbitals returned are actually orthonormal.
!>
      subroutine noft_tst_ortho(noft_wavefunction,g_bfmo,
     &                          gd_momo,gz_momo)
      implicit none
#include "stdio.fh"
#include "global.fh"
!     the wave function
      type(noft_wavefunction_tp),  intent(inout) :: noft_wavefunction
!
      integer, intent(inout) :: g_bfmo  ! temporary matrix nbf x nmo
      integer, intent(inout) :: gd_momo ! temporary MT_DBL matrix nmo x nmo
      integer, intent(inout) :: gz_momo ! temporary MT_DCPL matrix nmo x nmo
!
      integer :: nbf   ! the number of basis functions
      integer :: nmo   ! the number of MOs
      integer :: itype ! the GA type
      integer :: iproc ! the current processor rank
      integer :: ii    ! counter
!
      integer :: ilo, ihi ! local matrix block limits
      integer :: jlo, jhi ! local matrix block limits
!
      real(kind=dp)    :: dnormT  ! norm of temporary matrix
      complex(kind=dp) :: znormT  ! norm of temporary matrix
!
      call noft_orthogonalize(noft_wavefunction)
!
      iproc = ga_nodeid()
      call ga_inquire(noft_wavefunction%mo_a,itype,nbf,nmo)
!
!     Check alpha natural orbitals Na^T S Na = I
!
!     call ga_dgemm('n','n',nbf,nmo,nbf,1.0d0,wfn1_mat%g_s,
!    &              wfn1_wave%g_na,0.0d0,g_bfmo)
      call ga_dgemm('t','n',nmo,nmo,nbf,1.0d0,
     &              noft_wavefunction%mo_a,
     &              noft_wavefunction%mo_a,
     &              0.0d0,gd_momo)
      call ga_distribution(gd_momo,iproc,ilo,ihi,jlo,jhi)
      do ii = max(ilo,jlo),min(ihi,jhi)
        call ga_acc(gd_momo,ii,ii,ii,ii,-1.0d0,1,1.0d0)
      enddo
      call ga_norm_infinity(gd_momo,dnormT)
      if (dnormT.gt.1.0d-10) then
        if (iproc.eq.0) then
          write(LuOut,'(" Error in noft_ortho: Na: ",f24.15)')
     &          dnormT
        endif
      endif
!
!     Check beta natural orbitals Nb^T S Nb = I
!
!     call ga_dgemm('n','n',nbf,nmo,nbf,1.0d0,wfn1_mat%g_s,
!    &              wfn1_wave%g_nb,0.0d0,g_bfmo)
      call ga_dgemm('t','n',nmo,nmo,nbf,1.0d0,
     &              noft_wavefunction%mo_b,
     &              noft_wavefunction%mo_b,
     &              0.0d0,gd_momo)
      call ga_distribution(gd_momo,iproc,ilo,ihi,jlo,jhi)
      do ii = max(ilo,jlo),min(ihi,jhi)
        call ga_acc(gd_momo,ii,ii,ii,ii,-1.0d0,1,1.0d0)
      enddo
      call ga_norm_infinity(gd_momo,dnormT)
      if (dnormT.gt.1.0d-10) then
        if (iproc.eq.0) then
          write(LuOut,'(" Error in noft_ortho: Nb: ",f24.15)')
     &          dnormT
        endif
      endif
!
!     Check alpha correlation functions Ca^T Ca = I
!
      call ga_zgemm('t','n',nmo,nmo,nmo,complex(1.0d0,0.0d0),
     &              noft_wavefunction%to_a,
     &              noft_wavefunction%to_a,complex(0.0d0,0.0d0),
     &              gz_momo)
      call ga_distribution(gz_momo,iproc,ilo,ihi,jlo,jhi)
      do ii = max(ilo,jlo),min(ihi,jhi)
        call ga_acc(gz_momo,ii,ii,ii,ii,complex(-1.0d0,0.0d0),
     &              1,complex(1.0d0,0.0d0))
      enddo
      call ga_norm_infinity(gz_momo,znormT)
      if (abs(znormT).gt.1.0d-10) then
        if (iproc.eq.0) then
          write(LuOut,'(" Error in noft_ortho: Ca: ",f24.15)')
     &          znormT
        endif
      endif
!
!     Check beta correlation functions Cb^T Cb = I
!
      call ga_zgemm('t','n',nmo,nmo,nmo,complex(1.0d0,0.0d0),
     &              noft_wavefunction%to_b,
     &              noft_wavefunction%to_b,complex(0.0d0,0.0d0),
     &              gz_momo)
      call ga_distribution(gz_momo,iproc,ilo,ihi,jlo,jhi)
      do ii = max(ilo,jlo),min(ihi,jhi)
        call ga_acc(gz_momo,ii,ii,ii,ii,complex(-1.0d0,0.0d0),
     &              1,complex(1.0d0,0.0d0))
      enddo
      call ga_norm_infinity(gz_momo,znormT)
      if (abs(znormT).gt.1.0d-10) then
        if (iproc.eq.0) then
          write(LuOut,'(" Error in noft_ortho: Cb: ",f24.15)')
     &          znormT
        endif
      endif
      end subroutine noft_tst_ortho
!
!-----------------------------------------------------------------------
!
!> \brief Call noft_orthog and test whether the resulting vectors are 
!>        orthogonal
!>
      subroutine noft_tst_orthog(g_vecs,g_over,ometric)
      implicit none
#include "errquit.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "msgids.fh"
!>    The GA with the vectors
      integer, intent(in) :: g_vecs 
!>    The GA with the overlap
      integer, intent(in) :: g_over 
!>    Flag if .true. there is an overlap matrix, .false. there is not.
      logical, intent(in) :: ometric
!
      integer :: itypv, itypo
      integer :: ii, jj
      integer :: nbf, nmo
      integer :: g_bfmo, g_momo
!
      character(len=1) :: tn 
      character(len=1) :: tt 
!
      call ga_inquire(g_vecs,itypv,nbf,nmo)
      if (ometric) then
        call ga_inquire(g_over,itypo,ii,nbf)
        if (itypv.ne.itypo) then
          call errquit("noft_tst_orthog: mismatching types",0,UERR)
        endif
      endif
      if (itypv.eq.MT_DBL) then
        tn = 'n'
        tt = 't'
      else if (itypv.eq.MT_DCPL) then
        tn = 'n'
        tt = 'c'
      else
        call errquit("noft_tst_orthog: invalid type",itypv,MA_ERR)
      endif
!
      call noft_orthogonalize_vecs(g_vecs,g_over,ometric)
!
      if (.not.ga_create(itypv,nbf,nmo,"g_bfmo",-1,-1,g_bfmo)) then
        call errquit("noft_tst_orthog: g_bfmo create failed",0,MA_ERR)
      endif
      if (.not.ga_create(itypv,nmo,nmo,"g_momo",-1,-1,g_momo)) then
        call errquit("noft_tst_orthog: g_momo create failed",0,MA_ERR)
      endif
      if (ometric) then
        call noft_gemm(tn,tn,nbf,nmo,nbf,1.0d0,g_over,g_vecs,
     &                                   0.0d0,g_bfmo)
        call noft_gemm(tt,tn,nmo,nmo,nbf,1.0d0,g_vecs,g_bfmo,
     &                                   0.0d0,g_momo)
      else
        call noft_gemm(tt,tn,nmo,nmo,nbf,1.0d0,g_vecs,g_vecs,
     &                                   0.0d0,g_momo)
      endif
      call ga_print(g_momo)
      if (.not.ga_destroy(g_momo)) then
        call errquit("noft_tst_orthog: g_momo destroy failed",0,MA_ERR)
      endif
      if (.not.ga_destroy(g_bfmo)) then
        call errquit("noft_tst_orthog: g_bfmo destroy failed",0,MA_ERR)
      endif
!
      end subroutine noft_tst_orthog
!
!-----------------------------------------------------------------------
!
!> \brief Orthogonalize 1 vector from X against nvec vectors from M
!>
!> The global arrays X and M may be the same, but neither need to have
!> normalized vectors. Also the resulting orthogonalized vector in 
!> X is not normalized.
!>
!> The modified Gramm-Schmidt algorithm is used. The performance can
!> be improved by implementing the Gramm-Schmidt algorithm as in
!> wfn1_orthog_vecs.
!>
!> Orthogonalize X(:,j) to M(:,1:nvec).
!>
      subroutine noft_orthog_vec(g_m,nvec,g_x,j)
      implicit none
#include "global.fh"
#include "errquit.fh"
!>    Global array g_m
      integer, intent(in) :: g_m
!>    The number of vectors in g_m
      integer, intent(in) :: nvec
!>    Global array g_x
      integer, intent(in) :: g_x
!>    The index of the vector in g_x
      integer, intent(in) :: j
!
      integer :: nn ! vector length
      integer :: nm ! vector length
      integer :: nx ! vector length
      integer :: ii ! counter
!
      real(kind=dp) :: xm ! overlap X(j).M(ii)
      real(kind=dp) :: mm ! norm    M(ii).M(ii)
!
      call ga_inquire(g_m,ii,nm,nn)
      call ga_inquire(g_x,ii,nx,nn)
      if (nm.ne.nx) then
        call errquit("noft_orthog_vec: g_m and g_x have "//
     &               "different lengths",0,UERR)
      endif
      nn = nm
      do ii = 1, nvec
        xm = ga_ddot_patch(
     &       g_x, 'n', 1, nn, j,  j,
     &       g_m, 'n', 1, nn, ii, ii)
        mm = ga_ddot_patch(
     &       g_m, 'n', 1, nn, ii, ii,
     &       g_m, 'n', 1, nn, ii, ii)
        call ga_dadd_patch(
     &       1.0d0,  g_x, 1, nn, j,  j,
     &       -xm/mm, g_m, 1, nn, ii, ii,
     &               g_x, 1, nn, j,  j)
      enddo
!
      end subroutine noft_orthog_vec
!
!-----------------------------------------------------------------------
