!-----------------------------------------------------------------------
!> \brief Minimize the energy with Monte Carlo
!>
!> Minimize the energy with a Monte Carlo method. The steps are
!> expressed in terms of rotation angles. The rotation is then given by
!> \f{eqnarray*}{
!>    R &=& \begin{pmatrix}
!>          \cos\theta & -\sin\theta \\
!>          \sin\theta &  \cos\theta
!>          \end{pmatrix}
!> \f}
!> To construct a rotation matrix the \f$\theta\f$-s are randomly
!> chosen. Therefore for every \f$\theta\f$ holds that in the extreme
!> case \f$\theta\in\left[-\pi,\pi\right]\f$.
!> In the algorithm we keep ranges
!> \f$p_{ij}\in\left[0,\pi\right]\f$ and randomly choose
!> \f$\theta_{ij}\in\left[-p_{ij},p_{ij}\right]\f$. The average step
!> over many draws is 0, but the average absolute value of the step
!> is \f$p_{ij}/2\f$.
!>
!> We need an algorithm that ensures we choose the largest step to 
!> make progress quickly. But the algorithm also needs to shrink the
!> step size if the goal is reached. When the goal is reached the step
!> size for a successful step is 0. In that case the step range should
!> shrink.
!>
!> If the state is far from the goal and therefore the average step
!> \f$s\f$ is around \f$p_{ij}/2\f$ then the range should grow.
!> If the state is close to the goal and therefore the average step
!> size for successful steps is smaller than \f$p_{ij}/2\f$ then
!> the range should shrink. 
!> In MonteCarlo.py we have used this expression to update the range:
!> \f{eqnarray*}{
!>   p^{i+1} &=& p^i \cdot a + [ b (2 |s| - p^i) + c \cdot p^i ] (1-a)
!> \f}
!> with the parameters: a=0.9; b=2.0; c=1.5. 
!> In addition we maintain a minimum value of the range. This value is
!> smaller than the convergence criterion but larger than 0. 
!>
!> Yet, because Monte Carlo is a probablistic optimizer these
!> considerations are not enough. In a real Monte Carlo simulation you
!> can accidentally guess the right answer in a particular dimension.
!> This leaves no option to find an improvement but the range is still
!> large. Hence we need an additional criterion, one that says that
!> if we have many failed attempts to find a step that improves the
!> state then we must be closer to the answer than we thought, and 
!> based on that shrink the range. In MonteCarlo.py this notion is 
!> implemented scaling the range down every 10 consecutive attempts at
!> guessing a successful step.
!>
!> The final consideration is that MonteCarlo.py minimizes a parabolic
!> energy expression and therefore a valid range runs from \f$-\infty\f$
!> to \f$+\infty\f$. As stated above the case that is considered here
!> involves rotations, and therefore sensible ranges are limited to 
!> the range from \f$-\pi\f$ to \f$+\pi\f$. In fact a rotation by
!> \f$\pi\f$ corresponds to an interchange of two states rather than an
!> update of those states. So more realistically the ranges should be 
!> limited to \f$\[-\pi/2,+\pi/2\]\f$.
!>
      subroutine noft_solve_monte_carlo(noft_params,noft_instances,
     &           noft_operators,noft_wavefunction)
      implicit none
#include "errquit.fh"
#include "mafdecls.fh"
      type(noft_parameter_tp),    intent(in)    :: noft_params
      type(noft_instances_tp),    intent(in)    :: noft_instances
      type(noft_operators_tp),    intent(inout) :: noft_operators
      type(noft_wavefunction_tp), intent(inout) :: noft_wavefunction
!
!     Local
!
      type(noft_monte_carlo_range_tp)    :: noft_range
      type(noft_monte_carlo_rotation_tp) :: noft_rotation
      type(noft_monte_carlo_step_tp)     :: noft_step
      type(noft_energy_tp)               :: noft_energy
      type(noft_energy_tp)               :: noft_energy_step
      type(noft_wavefunction_tp)         :: noft_wavefunction_step
      real(kind=dp) :: range_init
      real(kind=dp) :: range_max
      real(kind=dp) :: threshold
      integer :: attempt_count
      integer :: consecutive_fails
      integer :: iteration
!
      consecutive_fails = noft_params%monte_carlo%consecutive_fails
      range_init = noft_params%monte_carlo%step_maximum/10.0_dp
      threshold = noft_params%monte_carlo%step_threshold
      call noft_create_wavefunction(noft_params,noft_wavefunction_step)
      call noft_monte_carlo_range_create(noft_params,noft_range)
      call noft_monte_carlo_rotation_create(noft_params,noft_rotation)
      call noft_monte_carlo_step_create(noft_params,noft_step)
      call noft_monte_carlo_range_init(noft_range,range_init)
      call noft_monte_carlo_range_max(noft_range,range_max)
      call noft_eval_energy(noft_params,noft_operators,
     &                      noft_wavefunction,noft_energy)
      attempt_count = 0
      iteration = 0
      do while (range_max.gt.threshold)
        attempt_count = attempt_count + 1
        iteration = iteration + 1
        call noft_monte_carlo_step_choose(noft_step,noft_range)
        call noft_monte_carlo_compute_rotation(noft_rotation,noft_step)
        call noft_monte_carlo_rotate_wavefunction(
     &           noft_wavefunction_step,noft_rotation,noft_wavefunction)
        call noft_eval_energy(noft_params,noft_operators,
     &           noft_wavefunction_step,noft_energy_step)
        if (noft_energy_step%e_total.lt.noft_energy%e_total) then
          !
          ! Take the step
          !
          attempt_count = 0
          call noft_monte_carlo_range_update(noft_params,noft_range,
     &                                       noft_step)
          call noft_monte_carlo_range_max(noft_range,range_max)
          call noft_swap_wavefunction(noft_wavefunction,
     &                                noft_wavefunction_step)
          noft_energy = noft_energy_step
        else if (mod(attempt_count,consecutive_fails).eq.0) then
          !
          ! Scale the range
          !
          call noft_monte_carlo_range_scale(noft_params,noft_range)
          call noft_monte_carlo_range_max(noft_range,range_max)
        endif
      enddo
      call noft_monte_carlo_step_destroy(noft_step)
      call noft_monte_carlo_rotation_destroy(noft_rotation)
      call noft_monte_carlo_range_destroy(noft_range)
      call noft_destroy_wavefunction(noft_wavefunction_step)
!
      end subroutine noft_solve_monte_carlo
!
!-----------------------------------------------------------------------
