!-----------------------------------------------------------------------
!
!>
!> \brief Guess the correlation functions 
!>
!> Currently it is believed that it is important that the correlation
!> function coefficients are non-zero everywhere so that all functions
!> will mix if fractional occupation numbers are beneficial. At the
!> same time it is important that the correlation functions 
!> coefficients decay as a function of energy so that the calculation
!> starts reasonably close to the expected answer. 
!>
!> To guess the correlation function coefficients the eigenvalues of
!> the natural orbitals are used. For each orbital it is assumed that
!> the coefficients decay exponentially as a function of the energy
!> difference with the current function. In the case guess functions
!> are degenerate some additional tricks are needed to ensure 
!> orthogonality within the degenerate set. Basically we assume that the
!> weights are multiplied with a plane wave style phase factor.
!>
!> Considering the coefficients as a function of the natural orbital
!> energies we assume they are proportional to 
!> \f{eqnarray}{
!>   C^s_i \propto \exp(|\epsilon_s-\epsilon_i|/(2T))
!> \f}
!> In addition a degenerate set is defined as the set of functions such
!> all functions within the set are connected to all other functions
!> through a path
!> \f$i\rightarrow k = i\rightarrow j \land j\rightarrow k\f$ such that
!> the probability \f$\exp(|\epsilon_j-\epsilon_i|/T)\f$ associated with
!> \f$i\rightarrow j\f$ exceeds \f$1/2\f$. This means there should be
!> at least one other vector in the degenerate set such that
!> \f{eqnarray}{
!>   -|\epsilon_j-\epsilon_i| \geq T \ln(1/2)
!> \f}
!> Within a degenerate set the coefficients are multiplied with a 
!> phase factor that depends on the distance to the lowest energy
!> natural orbital within the degenerate set.
!>
!> In addition it is assumed that the natural orbitals that constitute
!> a degenerate set appear in a consecutive sequence of orbitals.
!>
!> See also wfn1_nxt_init_occ
!>
      subroutine noft_guess_tilde(noft_params,noft_wavefunction,
     &                            eig,neig)
      implicit none
#include "mafdecls.fh"
#include "global.fh"
!>    The calculation parameters
      type(noft_parameter_tp),    intent(in)    :: noft_params
!>    The wave function
      type(noft_wavefunction_tp), intent(inout) :: noft_wavefunction
!>    The number of eigenvalues
      integer,       intent(in)    :: neig
!>    The eigenvalues of the natural orbitals
      real(kind=dp), intent(in)    :: eig(neig)
!
      integer nproc   ! the number of ranks
      integer iproc   ! the number of the current rank
      integer ii      ! counter
      integer jj      ! counter
      integer kk      ! counter
      integer ll      ! counter
      integer ilo,ihi ! loop limits
      integer jlo,jhi ! loop limits
!
      integer nea     ! local number of alpha electrons
      integer neb     ! local number of alpha electrons
      integer nmo     ! local number of molecular orbitals
      integer ncorea  ! local number of alpha core orbitals
      integer ncoreb  ! local number of beta core orbitals
      integer nvirta  ! local number of alpha virtual orbitals
      integer nvirtb  ! local number of beta virtual orbitals
!
      real(kind=dp) :: Tinitial
!
      real(kind=dp), allocatable :: rndm(:) ! random numbers of norm 1.0
!
      integer :: ideglo ! the bottom end of a degenerate set
      integer :: ideghi ! the top end of a degenerate set
      integer :: ndeg   ! the number of degenerate set functions
!
      nproc = ga_nnodes()
      iproc = ga_nodeid()
!
      nea      = noft_params%ne_a
      neb      = noft_params%ne_b
      nmo      = noft_params%nmo
      ncorea   = noft_params%ncore_a
      ncoreb   = noft_params%ncore_b
      nvirta   = noft_params%nvirtual_a
      nvirtb   = noft_params%nvirtual_b
      Tinitial = noft_params%temperature
!
!     Set up random numbers of norm 1.0
!
      allocate(rndm(1:nmo))
      if (ga_nodeid().eq.0) then
        call random_number(rndm)
        do ii = 1, nmo
          rndm(ii) = 2.0d0*rndm(ii)-1.0d0
          rndm(ii) = rndm(ii)/abs(rndm(ii))
        enddo
      endif
      call ga_brdcst(100,rndm,ma_sizeof(MT_DBL,nmo,MT_BYTE),0)
      call ga_sync()
!
!     Setup the alpha correlation functions
!
      call noft_guess_tilde_spin(nmo,ncorea,nvirta,
     &                           noft_wavefunction%to_a,
     &                           eig,neig,rndm,Tinitial)
!
!     Setup the beta correlation functions
!
      call noft_guess_tilde_spin(nmo,ncoreb,nvirtb,
     &                           noft_wavefunction%to_b,
     &                           eig,neig,rndm,Tinitial)
!
      call ga_sync()
      deallocate(rndm)
!
!     Orthonormalize the vectors
!
      call noft_orthogonalize_vecs(noft_wavefunction%to_a,ii,.false.)
      call noft_orthogonalize_vecs(noft_wavefunction%to_a,ii,.false.)
!
      end subroutine noft_guess_tilde
!
!-----------------------------------------------------------------------
!
      subroutine noft_guess_tilde_spin(nmo,ncore,nvirt,g_c,
     &                                 eig,neig,rndm,Tt)
      implicit none
#include "global.fh"
      integer,       intent(in) :: nmo
      integer,       intent(in) :: ncore
      integer,       intent(in) :: nvirt
      integer,       intent(in) :: g_c
      integer,       intent(in) :: neig
      real(kind=dp), intent(in) :: eig(neig)
      real(kind=dp), intent(in) :: rndm(:)
      real(kind=dp), intent(in) :: Tt      ! temperature
!
!     Local variables
!
      integer :: ilo, ihi, jlo, jhi ! delimiters of local patch of g_c
      integer :: ii, jj             ! counters
      integer :: iproc              ! this processor's rank
!
      integer :: ideglo ! the bottom end of a degenerate set
      integer :: ideghi ! the top end of a degenerate set
      integer :: ndeg   ! the number of degenerate set functions
!
      real(kind=dp) :: delta
      real(kind=dp) :: pi
      real(kind=dp) :: x
!
      real(kind=dp), allocatable :: buf(:,:)  ! buffer 
      real(kind=dp), allocatable :: dnrm(:)   ! vector norms
!
!     Setup the alpha correlation functions
!
      iproc = ga_nodeid()
      call ga_distribution(g_c,iproc,ilo,ihi,jlo,jhi)
      allocate(buf(ilo:ihi,jlo:jhi))
      allocate(dnrm(1:nmo))
!
!     Put initial values in (just weights, no phases)
!
      delta = 0.0d0
      pi = acos(-1.0d0)
      buf = 0.0d0
      do jj = jlo, jhi
        if (jj.le.ncore) then
          if (jj.ge.ilo.and.jj.le.ihi) then
            buf(jj,jj) = 1.0d0
          endif
        else if (jj.gt.nmo-nvirt) then
          if (jj.ge.ilo.and.jj.le.ihi) then
            buf(jj,jj) = 1.0d0
          endif
        else
          if (Tt.lt.1.0d-10) then
            do ii = max(ncore+1,ilo), min(ihi,nmo-nvirt)
              if (ii.eq.jj) then
                buf(ii,jj) = 1.0d0
              else
                buf(ii,jj) = 1.0d0
              endif
            enddo
          else
            do ii = max(ncore+1,ilo), min(ihi,nmo-nvirt)
              buf(ii,jj) = exp(-abs(eig(ii)-eig(jj))/(2*Tt))
            enddo
          endif
        endif
      enddo
!
!     Next adjust the phases to avoid all correlation functions within
!     a degenerate set becoming linearly dependent
!
      ideglo = 0
      ideghi = 0
      do while (ideglo.lt.nmo)
        ideglo = ideglo + 1
        ideghi = ideglo
        do while(ideghi.gt.ncore.and.ideghi.le.nmo-nvirt.and.
     &           (-abs(eig(ideghi+1)-eig(ideglo)).gt.Tt*log(0.5d0)
     &            .or.
     &            -abs(eig(ideghi+1)-eig(ideghi)).gt.Tt*log(0.5d0)
     &          ))
          ideghi = ideghi + 1
        enddo ! ideghi
        ndeg = ideghi-ideglo+1
        if (ndeg.eq.1) then
          delta = 0.0d0
        else
          delta = pi/ndeg
        endif
        do jj = max(ideglo,jlo), min(ideghi,jhi)
          do ii = ilo, ihi
            x = (ii-ideglo+0.5d0)*(jj-ideglo)*delta
            if (abs(cos(x)).lt.0.1d0) then
              buf(ii,jj) = 0.0d0
            else if (cos(x).lt.0.0d0) then
              buf(ii,jj) = -buf(ii,jj)
            endif
          enddo ! ii
        enddo ! jj
        ideglo = ideghi
      enddo ! ideglo
!
!     Normalize vectors
!
      dnrm = 0.0d0
      do jj = jlo, jhi
        do ii = ilo, ihi
          dnrm(jj) = dnrm(jj) + buf(ii,jj)*buf(ii,jj)
        enddo
      enddo
      call ga_dgop(1600,dnrm,nmo,"+")
      do jj = jlo, jhi
        dnrm(jj) = 1.0d0/dsqrt(dnrm(jj))
      enddo
      do jj = jlo, jhi
        do ii = ilo, ihi
          buf(ii,jj) = dnrm(jj) * buf(ii,jj) * rndm(ii)
        enddo
      enddo
      if (ihi.ge.ilo.and.jhi.ge.jlo) then
        call ga_put(g_c,ilo,ihi,jlo,jhi,buf,ihi-ilo+1)
      else
!       This process hold no part of g_c
      endif
      deallocate(dnrm)
      deallocate(buf)
!
      end subroutine noft_guess_tilde_spin
!
!-----------------------------------------------------------------------
