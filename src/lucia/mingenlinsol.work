      SUBROUTINE MINGENLINSOL(MTV,PRECTV,IPREC_FORM,
     &                  VEC1,VEC2,VEC3,LU1,LU2,RNRM,MAXIT,
     &                  NVAR,LU3,LU4,LUDIAM,LUB,MAXVEC,
     &                  APROJ,AVEC,WORK,IPRT,SHFT,
     &                  I_DO_PRECOND)
*
* Iterative routine for linear equations
*
* (M + SHFT) X = B
*
* Where M does not need to be symmetric 
*
* Subspace matrices are set up until max dimension is set, 
* then suspaces are flushed ( not the most efficient but I need results)
*
*
* Version requiring 3 vectors in core 
*
* Jeppe Olsen March 2004 at St. Simons Island for Sanibel
*
* Input :
* =======
*        MTV : Name of routine performing matrix*vector calculations
*        PRECTV : Name of precondtioner used if IPREC_FORM = 1
*        IPREC_FORM = 1 : use simple diagonal preconditioner 
*                   = 2 : Use external routine PRECTV to perform precond.
*        LU1 : Initial approximation to solution
*        VEC1,VEC2,VEC3 : Vectors,each must be dimensioned to hold
*                    complete vector
*        LU2,LU3   : Scatch files
*        LUDIAM    : File containing diagonal of matrix M
*        LUB    : File containing right hand side 
*        MAXVEC    : Largest allowed number of vectors
*
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
       DIMENSION VEC1(*),VEC2(*), VEC3(*)
       REAL * 8   INPROD
       DIMENSION RNRM(MAXIT)
       DIMENSION APROJ(*),AVEC(*),WORK(*)
*
* Dimensioning required of local vectors
*      APROJ  : MAXVEC*MAXVEC
*      AVEC   : MAXVEC
*      WORK   : 2*MAXVEC*MAXVEC + MAXVEC
*
       LOGICAL CONVER
* MTV : Routine for matrix times vector
* PRECTV : Routine for preconditioner times vector
       EXTERNAL MTV, PRECTV
*
       ONE = 1.0D0
       ONEM = -1.0D0
       ZERO = 0.0D0
*
       KMSUB = KFREE
       KFREE = KFREE + MAXVEC*MAXVEC
*
       KBSUB = KFREE
       KFREE = KFREE + MAXVEC
*
       KSCRMAT = KFREE
       KFREE   = KFREE + MAXVEC*MAXVEC
*
       TEST = 1.0D-7
       CONVER = .FALSE.
*
*.   INITAL ITERATION
*
       ITER = 1
*
       WRITE(6,*) ' IPRT, NVAR,MAXVEC  = ' , IPRT, NVAR, MAXVEC
       IF(IPRT.GE.100) THEN
        WRITE(6,*) ' Initial vector in LU1 '
        CALL REWINO(LU1)
        CALL WRTVCD(VEC1,LU1,1,-1)
       END IF
* Initial 1x1 matrix 
       CALL REWINO(LU1)
       CALL REWINO(LU2)
*. M times initial vector IVEC
       CALL VEC_FROM_DISC(VEC1,NVAR,0,-1,LU1)
       CALL MTV(VEC1,VEC2) 
       IF(SHFT.NE.0.0D0) CALL VECSUM(VEC2,VEC2,VEC1,ONE,SHFT,NVAR)
*. Save matrix times vector on disc
       CALL VEC_TO_DISC(VEC2,NVAR,0,-1,LU2)
* Update 1 x 1 projected matrix 
       APROJ(1) = INPROD(VEC1,VEC2,NVAR)
*
       IF( IPRT .GE.10 ) THEN
         WRITE(6,*) ' Initial matrix in subspace '
         CALL WRTMAT(APROJ,1,1,MAXVEC,MAXVEC)
       END IF
*. By definition initial guess is 1.0 times vector on LU1 so 
      AVEC(1) = 1.0D0
*
      ITER_EFF = 1
      NVEC = 1
      DO ITER = 2, MAXIT+1
*. (In iteration MAXIT + 1, only the residuals are obtained ...)
        IF(IPRT  .GE. 10 ) 
     &  WRITE(6,*) ' INFO FORM ITERATION .... ', ITER
*
** 1  New directions to be included
*
*   R = M*X - B
        CONVER = .FALSE.
*. H*X in VEC3
        CALL MVCSMD(LU2,AVEC,LU3,LU4,VEC1,VEC2,NVEC,1,-1)
        CALL VEC_FROM_DISC(VEC1,NVAR,1,-1,LU3)
        IF(IPRT.GE.600) THEN
          WRITE(6,*) ' MX '
          CALL WRTMAT(VEC1,1,NVAR,1,NVAR)
        END IF
*. M*X - B  in VEC1
        CALL VEC_FROM_DISC(VEC2,NVAR,1,-1,LUB)
        CALL VECSUM(VEC1,VEC1,VEC2,ONE,ONEM,NVAR)
        IF ( IPRT  .GE.600 ) THEN
          WRITE(6,*) '  ( MX - B ) '
          CALL WRTMAT(VEC1,1,NVAR,1,NVAR)
        END IF
*  STRANGE PLACE TO TEST CONVERGENCE , BUT ....
        RNORM = SQRT(INPROD(VEC1,VEC1,NVAR))
        RNRM(ITER-1) = RNORM
        IF(RNORM.LT. TEST ) THEN
          CONVER = .TRUE.
        END IF
        IF(ITER.LE.MAXIT.AND. .NOT. CONVER ) THEN
          IF(I_DO_PRECOND.EQ.1) THEN 
            IF(IPREC_FORM.EQ.1) THEN
*. Just use simple diagonal preconditioner
*.Multiply with diag(M-SHFT) to get new direction 
              CALL VEC_FROM_DISC(VEC2,NVAR,1,-1,LUDIAM)
              CALL DIAVC2(VEC1,VEC1,VEC2,SHFT,NVAR)
C                  DIAVC2(VECOUT,VECIN,DIAG,SHIFT,NDIM)
              IF ( IPRT  .GE. 600) THEN
                WRITE(6,*) '  (Diag(M)-SHFT)-1 *( MX - B ) '
                CALL WRTMAT(VEC1,1,NVAR,1,NVAR)
              END IF
            ELSE 
*.  Perform more advanced preconditioning by using a 
*. external preconditionings routine 
              CALL PRECTV(VEC1,VEC2,SHFT,LUDIAM,LUDIAS)
              CALL COPVEC(VEC2,VEC1,NVAR)
            END IF
          END IF
*. VEC1 contains now new direction 
*. ORTHOGONALIZE TO ALL PREVIOUS VECTORS on LU1
*
* I do not think this is neccessary, but I am a bit careful with general matrices
*
          XNRMI = INPROD(VEC1,VEC1,NVAR)
          CALL REWINO(LU1)
          DO IVEC = 1,NVEC
            CALL VEC_FROM_DISC(VEC3,NVAR,0,-1,LU1)
            OVLAP = INPROD(VEC3,VEC2,NVAR)
            CALL VECSUM(VEC1,VEC1,VEC3,1.0D0,-OVLAP,NVAR)
          END DO
*. 1.4 Normalize vector and check for linear dependency
          SCALE = INPROD(VEC1,VEC1,NVAR)
          IF(ABS(SCALE)/XNRMI .LT. 1.0D-10) THEN
*. Linear dependency
            WRITE(6,*) '  Trial vector linear dependent so OUT !!'
*.  Here subspace should be reset to current approx
            STOP ' Linear dependency, not programmed ... '
          ELSE
            FACTOR = 1.0D0/SQRT(SCALE)
            CALL SCALVE(VEC1,FACTOR,NVAR)
            CALL VEC_TO_DISC(VEC1,NVAR,0,-1,LU1)
*. And enroll it among the free independent vectors ...
            NVEC = NVEC + 1
            IF ( IPRT  .GE.600 ) THEN
              WRITE(6,*) 
     &        ' Orthonormalized Precond *( MX - B ) '
              CALL WRTMAT(VEC1,1,NVAR,1,NVAR)
            END IF
          END IF
*         ^ End if no singularity
        END IF
*       ^ End if not converged
* 
        IF( CONVER ) GOTO  1001
*
**  2 : OPTIMAL COMBINATION OF NEW AND OLD DIRECTION
*
        IF(.NOT.CONVER.AND.ITER.LE.MAXIT) THEN 
          ITER_EFF = ITER_EFF + 1
*   Augment projected matrices, current direction is in VEC1
           CALL MTV(VEC1,VEC2)
           IF(SHFT.NE.0.0D0) CALL VECSUM(VEC2,VEC2,VEC1,ONE,SHFT,NVAR)
           CALL VEC_TO_DISC(VEC2,NVAR,0,-1,LU2)
*.Matrix times NEW is in VEC2
*A(I,NEW) for I = 1, NVEC
           CALL REWINO( LU1)
           DO JVEC = 1, NVEC
             CALL VEC_FROM_DISC(VEC3,NVAR,0,-1,LU1)
             IJ = (NVEC-1)*MAXVEC + JVEC
             APROJ(IJ) = INPROD(VEC3,VEC2,NVAR)
           END DO
*A(NEW,I) for I = 1, NVEC-1, NEW is in VEC1
           CALL REWINO( LU2)
           DO JVEC = 1, NVEC
             CALL VEC_FROM_DISC(VEC3,NVAR,0,-1,LU2)
             IJ = (JVEC-1)*MAXVEC + NVEC
             APROJ(IJ) = INPROD(VEC3,VEC1,NVAR)
           END DO
          IF(IPRT.GE.10) THEN
            WRITE(6,*) ' Subspace M matrix '
            CALL WRTMAT(APROJ,NVEC,NVEC,MAXVEC,MAXVEC)
          END IF
*. and the Bvector times new direction
          CALL REWINO(LUB)
          CALL VEC_FROM_DISC(VEC3,NVAR,0,-1,LUB)
          WORK(KBSUB-1+NVEC) = INPROD(VEC3,VEC1,NVAR)
*. We should now solve the reduced linear equations MSUB XSUB = BSUB
*. Obtain inverse of MSUB
C COPMAT(AIN,AOUT,NIN,NOUT)
          CALL COPMAT(APROJ,WORK(KMSUB),MAXVEC,NVEC)
          CALL INVMAT(WORK(KMSUB),WORK(KSCRMAT),NVEC,ISING)
C              INVMAT(A,B,MATDIM,NDIM,ISING)
*. And multiply inverted matrix on BSUB
C MATVCB(MATRIX,VECIN,VECOUT,MATDIM,NDIM,ITRNSP)
          CALL MATVCB(WORK(KMSUB),WORK(KBSUB),AVEC,NVEC,NVEC,0)
*
          IF( IPRT  .GE. 5 ) THEN
            WRITE(6,*) ' Subspace M and B and solution vector'
            CALL WRTMAT(APROJ,NVEC,NVEC,NVEC,NVEC)
            CALL WRTMAT(AVEC,1,NVEC,1,NVEC)
          END IF
        END IF
*       ^ End if not converged
*. Reset space 
        IF(NVEC.GT.MAXVEC.OR.CONVER) THEN
*. Reset to one vector 
*. solution vector
           CALL REWINO(LU3)
           CALL MVECSUM(AVEC,NVEC,NVAR,VEC1,VEC2,LU1,1,1)
           CALL REWINO(LU1)
           CALL VEC_TO_DISC(VEC1,NVAR,0,-1,LU1)
*. and the matrix times vector
           CALL REWINO(LU3)
           CALL MVECSUM(AVEC,NVEC,NVAR,VEC1,VEC2,LU2,1,1)
           CALL REWINO(LU2)
           CALL VEC_TO_DISC(VEC1,NVAR,0,-1,LU2)
           NVEC = 1
*. new subspace matrix 
          CALL VEC_FROM_DISC(VEC1,NVAR,1,-1,LU1)
          CALL VEC_FROM_DISC(VEC2,NVAR,1,-1,LU2)
          APROJ(1) = INPROD(VEC1,VEC2,NVAR)
          CALL VEC_FROM_DISC(VEC3,NVAR,1,-1,LUB)
          WORK(KBSUB-1+1) = INPROD(VEC1,VEC3,NVAR)
          AVEC(1) = ONE
        END IF
*       ^ End if Reset was required
      END DO
*     ^ End of loop over iterations
 1001 CONTINUE
*     ^ Statement to which we skip if converged
*. Well, the last iteration was used to to construct the residual, 
*. and does therefore not really count so 
      ITER = ITER_EFF 
*
      IF( .NOT. CONVER ) THEN
*        CONVERGENCE WAS NOT OBTAINED
         IF(IPRT .GE. 2 )
     &   WRITE(6,1170) MAXIT
 1170    FORMAT('0  Convergence was not obtained in ',I3,' iterations')
      ELSE
*        CONVERGENCE WAS OBTAINED
C        ITER = ITER - 1
         IF (IPRT .GE. 2 )
     &   WRITE(6,1180) ITER
 1180    FORMAT(1H0,' Convergence was obtained in ',I3,' iterations')
      END IF
*
      IF ( IPRT .GT. 1 ) THEN
          WRITE(6,*)
          WRITE(6,'(A,I3)')
     &  ' Information about convergence '
          WRITE(6,*)
     &    '============================='
          WRITE(6,*)
          WRITE(6,'(A)') ' Summary of iterations '
          WRITE(6,'(A)') ' ----------------------'
          WRITE(6,'(A)')
     &    ' Iteration point        Residual '
          DO I=1,ITER
            WRITE(6,1340) I,RNRM(I)
          END DO
 1340     FORMAT(1H ,6X,I4,8X,F20.13)
      END IF
*
      RETURN
      END
