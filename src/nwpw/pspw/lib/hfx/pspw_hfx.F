*
* $Id: pspw_hfx.F,v 1.12 2005-06-24 19:24:18 bylaska Exp $
*

*     *************************
*     *                       *
*     *     pspw_init_HFX     *
*     *                       *
*     *************************
      subroutine pspw_init_HFX(rtdb,ispin0,ne)
      implicit none
      integer rtdb
      integer ispin0
      integer ne(2)

#include "mafdecls.fh"
#include "rtdb.fh"
#include "errquit.fh"
#include "pspw_hfx.fh"

*     **** local variables ****
      logical value
      integer ma_type
      integer n1,n2,n3,mapping,ms

*     **** external functions ****
      integer  control_version,control_mapping
      external control_version,control_mapping

      ispin = ispin0
      norbs(1) = 0
      norbs(2) = 0
      ehfx = 0.0d0
      hfx_on = .false.

      if (.not.rtdb_get(rtdb,'pspw:HFX',mt_log,1,hfx_on))
     >   hfx_on = .false.

*     **** get the number of HFX orbitals ****
      if (hfx_on) then
         !hfx_on = .true.
         do ms=1,ispin
           norbs(ms) = ne(ms)
           if(.not.MA_alloc_get(mt_int,norbs(ms),
     >       'orbital_list',orbital_list(2,ms),orbital_list(1,ms)))
     >        call errquit('pspw_init_HFX:out of heap memory',0,MA_ERR)
          
            do n1=1,norbs(ms)
               int_mb(orbital_list(1,ms)+n1-1) = n1 + (ms-1)*ne(1)
            end do
         end do

      else if (rtdb_ma_get(rtdb, 'pspw:HFX_up_orbitals', ma_type,
     >                norbs(1), orbital_list(2,1))) then

            if (.not.MA_get_index(orbital_list(2,1),orbital_list(1,1))) 
     >        call errquit(
     >       'pspw_init_HFX: ma_get_index failed for actlist',911,
     >        MA_ERR)

         if (rtdb_ma_get(rtdb, 'pspw:HFX_down_orbitals', ma_type,
     >                norbs(2), orbital_list(2,2))) then

           if (.not.MA_get_index(orbital_list(2,2),orbital_list(1,2))) 
     >        call errquit(
     >       'pspw_init_HFX: ma_get_index failed for actlist',911,
     >         MA_ERR)
         end if

         hfx_on = .true.

      end if


      if (hfx_on) then

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_screening_radius',
     >                      mt_dbl,1,rcut)) 
     >       rcut = 8.0d0

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_screening_power',
     >                      mt_dbl,1,pp)) 
     >       pp = 8.0d0

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_screening_type',
     >                      mt_int,1,flag)) 
     >       flag = 0

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_relax',
     >                      mt_log,1,relaxed)) 
     >       relaxed = .true.

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_solver_type',
     >                      mt_int,1,solver_type)) then

            if (control_version().eq.3) solver_type = 1
            if (control_version().eq.4) solver_type = 2
         end if

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_parameter',
     >                       mt_dbl,1,HFX_parameter))
     >       HFX_parameter = 1.0d0

         if (.not. rtdb_get(rtdb,
     >                      'pspw:HFX_print_orbital_contribution',
     >                       mt_log,1,orb_contribution))
     >       orb_contribution = .false.
 

*        **** initialize coulomb_screened ****
         if (solver_type.eq.1) then
              call coulomb_screened_init(flag,rcut,pp)

*        **** initialize free-space coulomb if necessary ****
         else
            if (control_version().eq.3) then
               call D3dB_nx(1,n1)
               call D3dB_ny(1,n2)
               call D3dB_nz(1,n3)
               mapping = control_mapping()
               call D3dB_Init(2,2*n1,2*n2,2*n3,mapping)
               call coulomb2_init()
            end if

         end if

*        **** initialize orb_contribution ****
         do ms=1,ispin
           value = MA_alloc_get(mt_dbl,norbs(ms),
     >                'ehfx_orb',ehfx_orb(2,ms),ehfx_orb(1,ms))
           if (.not. value)   
     >       call errquit('pspw_init_HFX: out of heap memory',1, MA_ERR)
         end do

      end if

   
      return
      end


*     *************************
*     *                       *
*     *     pspw_end_HFX      *
*     *                       *
*     *************************
      subroutine pspw_end_HFX()
      implicit none

#include "mafdecls.fh"
#include "pspw_hfx.fh"
#include "errquit.fh"

*     **** local variables ****
      integer MASTER,taskid
      parameter(MASTER=0)
      logical value
      integer i,ms

*     **** external functions ****
      integer  control_version
      external control_version

      if ((norbs(1)+norbs(2)).gt.0) then

*       **** print out orbital contributions ****
        if (orb_contribution) then
           call Parallel_taskid(taskid)
           if (taskid.eq.MASTER) then
              write(6,487)
              write(6,488)
              do ms=1,ispin
              do i=1,norbs(ms)
                write(6,489) 
     >            ms,
     >            int_mb(orbital_list(1,ms)+i-1),
     >            dbl_mb(ehfx_orb(1,ms)+i-1)
              end do
              end do
           end if
  487   format(//,'== Orbital Contributions to HFX ==')
  488   format(/1x,'orbital',15x,
     >         'HF_Exchange') 	
  489   format(1x,i3,i7,2x,e18.6)
        end if


*       **** deallocate memory ****
        value = .true.
        do ms=1,ispin
          value = value.and.MA_free_heap(orbital_list(2,ms)) 
          value = value.and.MA_free_heap(ehfx_orb(2,ms))
        end do
        if (.not. value)
     >  call errquit('pspw_end_HFX:error freeing heap memory',0, MA_ERR)


*        **** end coulomb_screened ****
        if (solver_type.eq.1) then
          call coulomb_screened_end()

*        **** end free-space coulomb if necessary ****
        else
           if (control_version().eq.3) then
              call coulomb2_end()
              call D3dB_end(2)
           end if
        end if

      end if

      return
      end

*     *************************
*     *                       *
*     *     pspw_print_HFX    *
*     *                       *
*     *************************
      subroutine pspw_print_HFX(unit)
      implicit none
      integer unit

#include "mafdecls.fh"
#include "pspw_hfx.fh"

*     **** local variables ****
      integer i,ms

      if (hfx_on) then
        if (relaxed) then
          write(unit,1001)
        else
          write(unit,1002)
        end if
        if (ispin.eq.1) then
         write(unit,1003) (int_mb(orbital_list(1,1)+i-1),i=1,norbs(1))
        else
         write(unit,1004) (int_mb(orbital_list(1,1)+i-1),i=1,norbs(1))
         write(unit,1005) (int_mb(orbital_list(1,2)+i-1),i=1,norbs(2))
        end if

        if (solver_type.eq.1) then
          write(unit,1006)
           if (rcut.ge.0.0d0) write(unit,1008) rcut
           if (rcut.ge.0.0d0) write(unit,1009) pp
           if (rcut.ge.0.0d0) write(unit,1011) flag
        else
          write(unit,1007)
        end if
        if (hfx_parameter.ne.1.0d0) write(unit,1010) hfx_parameter
        write(unit,*)

      end if

      return
 1001 FORMAT(6x,"- HFX relaxed")
 1002 FORMAT(6x,"- HFX unrelaxed")
 1003 FORMAT(6x,"- HFX restricted orbitals :",10I5)
 1004 FORMAT(6x,"- HFX alpha orbitals:",10I5)
 1005 FORMAT(6x,"- HFX beta orbitals :",10I5)

 1006 FORMAT(6x,"- HFX screened coulomb solver")
 1007 FORMAT(6x,"- HFX free-space coulomb solver")
 1008 FORMAT(6x,"- HFX screening radius(pspw:HFX_screening_radius):",
     >       E10.3)
 1009 FORMAT(6x,"- HFX screening power (pspw:HFX_screening_power) :",
     >       E10.3)
 1010 FORMAT(6x,"- HFX scaling parameter (pspw:HFX_parameter)     :",
     >       E10.3)
 1011 FORMAT(6x,"- HFX screening type (pspw:HFX_screening_type)   :",
     >       I2)
      end

*     ****************************
*     *                    	 *
*     *     pspw_potential_HFX   *
*     *                          *
*     ****************************
      subroutine pspw_potential_HFX(ispin0,psi_r,Hpsi_r)
      implicit none
      integer    ispin0
      real*8     psi_r(*)
      real*8     Hpsi_r(*)

#include "mafdecls.fh"
#include "pspw_hfx.fh"
#include "errquit.fh"

*     **** local variables ****
      logical value
      integer i,j,n2ft3d,n1,n2,n3,ms
      integer dn(2),vij(2),tmp1(2),tmp2(2),index1,index2
      real*8  scal1,scal2,dv,eh,ph

*     **** external functions ****
      integer  control_gga
      real*8   lattice_omega,coulomb_screened_e
      external control_gga
      external lattice_omega,coulomb_screened_e


      ehfx = 0.0d0
      phfx = 0.0d0
      if (((norbs(1)+norbs(2)).ne.0).and.relaxed) then
        call D3dB_nx(1,n1)
        call D3dB_ny(1,n2)
        call D3dB_nz(1,n3)
        call D3dB_n2ft3d(1,n2ft3d)
        value = MA_push_get(mt_dbl,(n2ft3d),'dn_hfx',dn(2),dn(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'vij_hfx',vij(2),vij(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'tmp1_hfx',tmp1(2),tmp1(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'tmp2_hfx',tmp2(2),tmp2(1))
        if (.not. value) call errquit('out of stack memory',0, MA_ERR)

        scal1 = 1.0d0/dble(n1*n2*n3)
        scal2 = 1.0d0/lattice_omega()
        dv = scal1/scal2

        do ms=1,ispin0
        do i=1,norbs(ms)
         dbl_mb(ehfx_orb(1,ms)+i-1) = 0.0d0
         do j=1,i
           index1 = (int_mb(orbital_list(1,ms)+i-1)-1)*n2ft3d + 1
           index2 = (int_mb(orbital_list(1,ms)+j-1)-1)*n2ft3d + 1

*          **** generate dnij for Vij  ****
           call D3dB_rr_Mul(1,psi_r(index2),psi_r(index1),dbl_mb(dn(1)))
           call D3dB_r_SMul(1,scal2,dbl_mb(dn(1)),dbl_mb(dn(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(dn(1)))
   

*          ***** screened coulomb solver ****
           if (solver_type.eq.1) then

             call D3dB_r_SMul(1,scal1,dbl_mb(dn(1)),
     >                              dbl_mb(dn(1)))
             !call D3dB_rc_fft3f(1,dbl_mb(dn(1)))
             call D3dB_rc_pfft3f(1,0,dbl_mb(dn(1)))
             call Pack_c_pack(0,dbl_mb(dn(1)))

*            **** get Ecoul energy ****
             eh = coulomb_screened_e(dbl_mb(dn(1)))


*            **** generate Vcoul ****
             call coulomb_screened_v(dbl_mb(dn(1)),dbl_mb(vij(1)))
             call Pack_c_unpack(0,dbl_mb(vij(1)))
             !call D3dB_cr_fft3b(1,dbl_mb(vij(1)))
             call D3dB_cr_pfft3b(1,0,dbl_mb(vij(1)))
        


*          ***** free-space coulomb solver ****
           else

              call coulomb2_v(dbl_mb(dn(1)),dbl_mb(vij(1)))
              call D3dB_rr_dot(1,dbl_mb(dn(1)),dbl_mb(vij(1)),eh)
              eh = 0.5d0*eh*dv
           end if

*          **** apply hfx_parameter, double eh for restricted, and calculcate ph ****
           eh = eh*hfx_parameter
           call D3dB_r_SMul(1,hfx_parameter,
     >                      dbl_mb(vij(1)),
     >                      dbl_mb(vij(1)))
           if (ispin0.eq.1) eh = eh + eh
           ph = 2.0d0*eh


           ehfx = ehfx - eh
           phfx = phfx - ph
           dbl_mb(ehfx_orb(1,ms)+i-1) = dbl_mb(ehfx_orb(1,ms)+i-1) - eh

*          **** generate (Vij)*psi_r ***
           call D3dB_rr_Mul(1,dbl_mb(vij(1)),
     >                        psi_r(index2),
     >                        dbl_mb(tmp1(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(tmp1(1)))


*          **** add -(Vij)*psi_r to Hpsi_r ***
           call D3dB_rr_Sub(1,Hpsi_r(index1),
     >                        dbl_mb(tmp1(1)),
     >                        Hpsi_r(index1))



           !**** include off diagonal terms ****
           if (i.ne.j) then
              ehfx = ehfx - eh
              phfx = phfx - ph
              dbl_mb(ehfx_orb(1,ms)+i-1) = dbl_mb(ehfx_orb(1,ms)+i-1)
     >                                   - eh

*             **** generate (Vij)*psi_r ***
              call D3dB_rr_Mul(1,dbl_mb(vij(1)),
     >                        psi_r(index1),
     >                        dbl_mb(tmp2(1)))
              call D3dB_r_Zero_Ends(1,dbl_mb(tmp2(1)))

*             **** add -(Vij)*psi_r to Hpsi_r ***
              call D3dB_rr_Sub(1,Hpsi_r(index2),
     >                        dbl_mb(tmp2(1)),
     >                        Hpsi_r(index2))
           end if


         end do
        end do
        end do

        value =           MA_pop_stack(tmp2(2))
        value = value.and.MA_pop_stack(tmp1(2))
        value = value.and.MA_pop_stack(vij(2))
        value = value.and.MA_pop_stack(dn(2))
        if (.not. value) 
     >    call errquit('pspw_potential_HFX:popping stack memory',0,
     &       MA_ERR)

      end if
      return
      end




*     *************************
*     *                       *
*     *     pspw_energy_HFX   *
*     *                       *
*     *************************
      subroutine pspw_energy_HFX(ispin0,psi_r,ehfx_out,phfx_out)
      implicit none
      integer ispin0
      real*8  psi_r(*)
      real*8 ehfx_out
      real*8 phfx_out

#include "mafdecls.fh"
#include "pspw_hfx.fh"
#include "errquit.fh"

*     **** local variables ****
      logical value
      integer i,j,n2ft3d,n1,n2,n3,ms
      integer dn(2),tmp1(2),index1,index2
      real*8  scal1,scal2,dv,eh,ph

*     **** external functions ****
      integer  control_gga
      real*8   lattice_omega,coulomb_screened_e
      external control_gga
      external lattice_omega,coulomb_screened_e

      
      if (((norbs(1)+norbs(2)).ne.0).and.(.not.relaxed)) then
        ehfx = 0.0d0
        phfx = 0.0d0

        call D3dB_nx(1,n1)
        call D3dB_ny(1,n2)
        call D3dB_nz(1,n3)
        call D3dB_n2ft3d(1,n2ft3d)
        value = MA_push_get(mt_dbl,(2*n2ft3d),'dn_hfx',dn(2),dn(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'tmp1_hfx',tmp1(2),tmp1(1))
        if (.not. value) call errquit('out of stack memory',0, MA_ERR)

        scal1 = 1.0d0/dble(n1*n2*n3)
        scal2 = 1.0d0/lattice_omega()
        dv = scal1/scal2

        do ms=1,ispin
        do i=1,norbs(ms)
         dbl_mb(ehfx_orb(1,ms)+i-1) = 0.0d0
         do j=1,i

           index1 = (int_mb(orbital_list(1,ms)+i-1)-1)*n2ft3d + 1
           index2 = (int_mb(orbital_list(1,ms)+j-1)-1)*n2ft3d + 1

*          **** generate dnij ****
           call D3dB_rr_Mul(1,psi_r(index1),psi_r(index2),dbl_mb(dn(1)))
           call D3dB_r_SMul(1,scal2,dbl_mb(dn(1)),dbl_mb(dn(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(dn(1)))


*          ***** screened coulomb solver ****
           if (solver_type.eq.1) then

*            **** generate dng ****
             call D3dB_r_SMul(1,scal1,dbl_mb(dn(1)),
     >                                dbl_mb(dn(1)))
             !call D3dB_rc_fft3f(1,dbl_mb(dn(1)))
             call D3dB_rc_pfft3f(1,0,dbl_mb(dn(1)))
             call Pack_c_pack(0,dbl_mb(dn(1)))

*            **** get Ecoul energy ****
             eh = coulomb_screened_e(dbl_mb(dn(1)))
       

*          ***** free-space coulomb solver ****
           else
              call coulomb2_v(dbl_mb(dn(1)),dbl_mb(tmp1(1)))
              call D3dB_rr_dot(1,dbl_mb(dn(1)),dbl_mb(tmp1(1)),eh)
              eh = 0.5d0*eh*dv
           end if

*          **** apply hfx_parameter, double eh for restricted, and calculcate ph ****
           eh = eh*hfx_parameter
           if (ispin0.eq.1) eh = eh + eh
           ph = 2.0d0*eh


           ehfx = ehfx - eh
           phfx = phfx - ph
           dbl_mb(ehfx_orb(1,ms)+i-1) = dbl_mb(ehfx_orb(1,ms)+i-1) - eh

           !**** include off diagonal terms ****
           if (i.ne.j) then
              ehfx = ehfx - eh
              phfx = phfx - ph
              dbl_mb(ehfx_orb(1,ms)+i-1) = dbl_mb(ehfx_orb(1,ms)+i-1)
     >                                   - eh
           end if

         end do
        end do
        end do

        value =           MA_pop_stack(tmp1(2))
        value = value.and.MA_pop_stack(dn(2))
        if (.not. value) 
     >     call errquit('pspw_energy_HFX:popping stack memory',0,
     &       MA_ERR)

      end if
      ehfx_out = ehfx
      phfx_out = phfx

      return
      end




*     ********************************
*     *                    	     *
*     *     pspw_potential_HFX_orb   *
*     *                              *
*     ********************************
      subroutine pspw_potential_HFX_orb(ms,psi_r,
     >                                  orb_r,Horb_r)
      implicit none
      integer    ms
      real*8     psi_r(*)
      real*8     orb_r(*)
      real*8     Horb_r(*)

#include "mafdecls.fh"
#include "pspw_hfx.fh"
#include "errquit.fh"

*     **** local variables ****
      logical value
      integer i,j,n2ft3d,n1,n2,n3
      integer dn(2),vij(2),tmp1(2),tmp2(2),index2
      real*8  scal1,scal2,dv,eh,ph

*     **** external functions ****
      integer  control_gga
      real*8   lattice_omega,coulomb_screened_e
      external control_gga
      external lattice_omega,coulomb_screened_e


      if (((norbs(1)+norbs(2)).ne.0).and.relaxed) then
        call D3dB_nx(1,n1)
        call D3dB_ny(1,n2)
        call D3dB_nz(1,n3)
        call D3dB_n2ft3d(1,n2ft3d)
        value = MA_push_get(mt_dbl,(n2ft3d),'dn_hfx',dn(2),dn(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'vij_hfx',vij(2),vij(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'tmp1_hfx',tmp1(2),tmp1(1))
        value = value.and.
     >          MA_push_get(mt_dbl,(n2ft3d),'tmp2_hfx',tmp2(2),tmp2(1))
        if (.not. value) call errquit('out of stack memory',0, MA_ERR)

        scal1 = 1.0d0/dble(n1*n2*n3)
        scal2 = 1.0d0/lattice_omega()
        dv = scal1/scal2

        
        do j=1,norbs(ms)
           index2 = (int_mb(orbital_list(1,ms)+j-1)-1)*n2ft3d + 1

*          **** generate dnij for Vij  ****
           call D3dB_rr_Mul(1,psi_r(index2),orb_r,dbl_mb(dn(1)))
           call D3dB_r_SMul(1,scal2,dbl_mb(dn(1)),dbl_mb(dn(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(dn(1)))
   

*          ***** screened coulomb solver ****
           if (solver_type.eq.1) then
             call D3dB_r_SMul(1,scal1,dbl_mb(dn(1)),
     >                                dbl_mb(dn(1)))
             !call D3dB_rc_fft3f(1,dbl_mb(dn(1)))
             call D3dB_rc_pfft3f(1,0,dbl_mb(dn(1)))
             call Pack_c_pack(0,dbl_mb(dn(1)))

*            **** get Ecoul energy ****
             eh = coulomb_screened_e(dbl_mb(dn(1)))

*            **** generate Vcoul ****
             call coulomb_screened_v(dbl_mb(dn(1)),dbl_mb(vij(1)))
             call Pack_c_unpack(0,dbl_mb(vij(1)))
             !call D3dB_cr_fft3b(1,dbl_mb(vij(1)))
             call D3dB_cr_pfft3b(1,0,dbl_mb(vij(1)))


*          ***** free-space coulomb solver ****
           else
              call coulomb2_v(dbl_mb(dn(1)),dbl_mb(vij(1)))
              call D3dB_rr_dot(1,dbl_mb(dn(1)),dbl_mb(vij(1)),eh)
              eh = 0.5d0*eh*dv
           end if

*          **** apply hfx_parameter, double eh for restricted, and calculcate ph ****
           eh = eh*hfx_parameter
           call D3dB_r_SMul(1,hfx_parameter,
     >                      dbl_mb(vij(1)),
     >                      dbl_mb(vij(1)))
           if (ispin.eq.1) eh = eh + eh
           ph = 2.0d0*eh


*          **** generate (Vij)*psi_r ***
           call D3dB_rr_Mul(1,dbl_mb(vij(1)),
     >                        psi_r(index2),
     >                        dbl_mb(tmp1(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(tmp1(1)))

*          **** add -(Vij)*psi_r to Hpsi_r ***
           call D3dB_rr_Sub(1,Horb_r,
     >                        dbl_mb(tmp1(1)),
     >                        Horb_r)

        end do

        value =           MA_pop_stack(tmp2(2))
        value = value.and.MA_pop_stack(tmp1(2))
        value = value.and.MA_pop_stack(vij(2))
        value = value.and.MA_pop_stack(dn(2))
        if (.not. value) 
     >    call errquit('pspw_potential_HFX_orb:popping stack memory',0,
     &       MA_ERR)
      end if
      return
      end



*     *************************
*     *                       *
*     *     pspw_HFX          *
*     *                       *
*     *************************
      logical function pspw_HFX()
      implicit none

#include "pspw_hfx.fh"

      pspw_HFX= hfx_on
      return
      end

*     *************************
*     *                       *
*     *   pspw_HFX_relaxed    *
*     *                       *
*     *************************
      logical function pspw_HFX_relaxed()
      implicit none

#include "mafdecls.fh"
#include "pspw_hfx.fh"

      pspw_hfx_relaxed = relaxed
      return
      end






*     *****************************
*     *                           *
*     *     pspw_energy_euv_HFX   *
*     *                           *
*     *****************************
      subroutine pspw_energy_euv_HFX(ispin0,psi_r,stress)
      implicit none
      integer ispin0
      real*8  psi_r(*)
      real*8 stress(3,3)

#include "mafdecls.fh"
#include "pspw_hfx.fh"
#include "errquit.fh"

*     **** local variables ****
      logical value
      integer i,j,n2ft3d,n1,n2,n3,ms,u,v
      integer dn(2),index1,index2
      real*8  scal1,scal2,dv,eh,ph
      real*8  tstress(3,3)

*     **** external functions ****
      real*8   lattice_omega
      external lattice_omega

      
      call dcopy(9,0.0d0,0,stress,1)
      if (((norbs(1)+norbs(2)).ne.0)) then
        call coulomb_screened_euv_init(flag,rcut,pp)


        call D3dB_nx(1,n1)
        call D3dB_ny(1,n2)
        call D3dB_nz(1,n3)
        call D3dB_n2ft3d(1,n2ft3d)
        value = MA_push_get(mt_dbl,(2*n2ft3d),'dn_hfx',dn(2),dn(1))
        if (.not. value) call errquit('out of stack memory',0, MA_ERR)

        scal1 = 1.0d0/dble(n1*n2*n3)
        scal2 = 1.0d0/lattice_omega()
        dv = scal1/scal2

        do ms=1,ispin
        do i=1,norbs(ms)
         do j=1,i

           index1 = (int_mb(orbital_list(1,ms)+i-1)-1)*n2ft3d + 1
           index2 = (int_mb(orbital_list(1,ms)+j-1)-1)*n2ft3d + 1

*          **** generate dnij ****
           call D3dB_rr_Mul(1,psi_r(index1),psi_r(index2),dbl_mb(dn(1)))
           call D3dB_r_SMul(1,scal2,dbl_mb(dn(1)),dbl_mb(dn(1)))
           call D3dB_r_Zero_Ends(1,dbl_mb(dn(1)))


*          ***** screened coulomb solver ****
           if (solver_type.eq.1) then

*            **** generate dng ****
             call D3dB_r_SMul(1,scal1,dbl_mb(dn(1)),
     >                                dbl_mb(dn(1)))
             !call D3dB_rc_fft3f(1,dbl_mb(dn(1)))
             call D3dB_rc_pfft3f(1,0,dbl_mb(dn(1)))
             call Pack_c_pack(0,dbl_mb(dn(1)))

*            **** get Ecoul energy ****
             call coulomb_screened_euv(dbl_mb(dn(1)),tstress)
             if (ispin.eq.1) call dscal(9,2.0d0,tstress,1)

*            **** apply the hfx_parameter ****
             call dscal(9,hfx_parameter,tstress,1)

*          ***** free-space coulomb solver ****
           else
             write(*,*) "ERROR free-space coulomb solver called"
             call errquit('error: not periodic boundary conditions',0,0)
           end if

           do v=1,3
           do u=1,3
              stress(u,v) = stress(u,v) - tstress(u,v)
           end do
           end do

           !**** include off diagonal terms ****
           if (i.ne.j) then
             do v=1,3
             do u=1,3
                stress(u,v) = stress(u,v) - tstress(u,v)
             end do
             end do
           end if


         end do
        end do
        end do


        call coulomb_screened_euv_end()
        value = MA_pop_stack(dn(2))
        if (.not. value) 
     >     call errquit('pspw_energy_euv_HFX:popping stack memory',0,
     &       MA_ERR)

      end if

      return
      end


