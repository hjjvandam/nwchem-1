C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
c
c
c atw - 8/25/94
c
c This was the very first algorithm + auxiliary routines
c
c
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
#ifdef OLD_ALGORITHM
       subroutine moints_1st_half(basis,mo_indx_lo,mo_indx_hi,
     $                            g_movecs,
     $                            g_jhalf,ocoul,
     $                            g_khalf,oexch)
       implicit none
#include "tcgmsg.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
#include "schwarz.fh"
       integer MOINTS_SCHWARZ_STAT
       parameter(MOINTS_SCHWARZ_STAT=1921)
c
c
       integer basis                          ! Basis handle
       integer mo_indx_lo, mo_indx_hi         ! 1st pair of MO indices
       integer g_movecs                       ! MO coefficients
       integer g_jhalf                        ! Half-transformed Coulomb operator
       integer g_khalf                        ! Half-transformed exchange operator
       logical ocoul,oexch                    ! Type selection
c
c Local
c
       integer noper,nbf
       integer g_mocols
       integer g_j1idx, g_k1idx
       integer g_j2idx, g_k2idx
       integer l_jsssi,k_jsssi,l_tsssi,k_tsssi,l_ksssi,k_ksssi
       integer l_jssni,k_jssni
       integer l_iscr,k_iscr,l_eri,k_eri,l_erit,k_erit
       integer l_mov,k_mov
       integer mem2,max2e,sssi_block,ssni_block,maxbf_shell
       integer nsh,ish,jsh,ksh,lsh
       integer ish_bflo,ish_bfhi,jsh_bflo,jsh_bfhi
       integer ksh_bflo,ksh_bfhi,lsh_bflo,lsh_bfhi
       integer ileng,jleng,kleng
       integer ncol_tij,row_dist,col_dist,nbf_sh_oper
       integer num_nodes, jk, next
       double precision tol2e,dschw_done,schw_ratio
       double precision tt,t1qtr,t2qtr,thalf
       logical status
       data tol2e/1.d-10/
c
c
c Get general info
c
       call ga_sync()
       thalf = tcgtime()
       status = bas_numbf(basis,nbf)
       status = status.and.bas_numcont(basis,nsh)
       status = status.and.bas_nbf_cn_max(basis,maxbf_shell)
       if (.not.status) call errquit('moints: cannot get basis info',0)
       noper = mo_indx_hi - mo_indx_lo + 1
       if (ga_nodeid().eq.0) then
         write(6,927) nsh,maxbf_shell
 927     format(10x,'Number of shells:',19x,i5,/,
     $          10x,'Maximum shell length:',15x,i5)
         call util_flush(6)
       endif
c
c Ints allocation
c
       call int_mem_2e4c(max2e, mem2)
       status = ma_push_get(MT_DBL, max2e, 'moints: buf', l_eri, k_eri)
       status = status.and.ma_push_get(MT_DBL,max2e,'moints: buf2',
     $          l_erit,k_erit)
       status = status.and.ma_push_get(MT_DBL, mem2,
     $          'moints: scr', l_iscr, k_iscr)
c
c Allocate and get local & global MO coefficients !!!! FIX with ga_patch routines !!!!
c
       status = status.and.ma_push_get(MT_DBL,(noper*nbf),
     $          'movecs cols',l_mov,k_mov)
       status = status.and.ga_create(MT_DBL,nbf,noper,'MO cols',
     $          nbf,1,g_mocols)
       if (.not.(status)) call errquit('failed allocate MO vectors',0)
       call ga_get(g_movecs,1,nbf,mo_indx_lo,mo_indx_hi,
     $             dbl_mb(k_mov),nbf)
       call ga_copy_patch('n',g_movecs,1,nbf,mo_indx_lo,mo_indx_hi,
     $                        g_mocols,1,nbf,1,noper)
c
c Allocate local shell-shell-shell-active blocks
c
       sssi_block = noper*maxbf_shell*maxbf_shell*maxbf_shell
       ssni_block = noper*maxbf_shell*maxbf_shell*nbf
       status = status.and.ma_push_get(MT_DBL,sssi_block,
     $          'J sssi block',l_jsssi,k_jsssi)
       status = status.and.ma_push_get(MT_DBL,sssi_block,
     $          'J Tsssi block',l_tsssi,k_tsssi)
       status = status.and.ma_push_get(MT_DBL,sssi_block,
     $          'K sssi block',l_ksssi,k_ksssi)
       status = status.and.ma_push_get(MT_DBL,ssni_block,
     $          'J ssni block',l_jssni,k_jssni)
       if (.not.status) call
     $          errquit('moints: cannot allocate local memory',0)
c
c Global arrays for accumulating intermediates
c
       nbf_sh_oper = nbf*maxbf_shell*noper
       col_dist = 1
       row_dist = 1
       if (ocoul) then
         status = status.and.ga_create(MT_DBL,nbf,nbf_sh_oper,
     $        'J 1indx',row_dist,col_dist,g_j1idx)
         status = status.and.ga_create(MT_DBL,nbf_sh_oper,noper,
     $        'J 2indx',nbf_sh_oper,col_dist,g_j2idx)
       endif
       if (oexch) then
         status = status.and.ga_create(MT_DBL,nbf,nbf_sh_oper,
     $        'K 1indx',row_dist,col_dist,g_k1idx)
         status = status.and.ga_create(MT_DBL,nbf_sh_oper,noper,
     $        'K 2indx',nbf_sh_oper,col_dist,g_k2idx)
       endif
       if (.not.(status)) call
     $      errquit('moints_1st_half: cannot allocate global memory',0)
c
c Start 4-fold shell loop
c
       t1qtr = 0.d0
       t2qtr = 0.d0
       dschw_done = 0.d0
       num_nodes = ga_nnodes()
       do ish=1,nsh
         if (.not. bas_cn2bfr(basis,ish,ish_bflo,ish_bfhi))
     $        call errquit('mo_ints: bas_cn2bfr',ish)
         ileng = ish_bfhi - ish_bflo + 1
         if (ocoul) call ga_zero(g_j1idx)
         if (oexch) call ga_zero(g_k1idx)
         call ga_sync()
         tt = tcgtime()         
         jk = 0
         next = nxtval(num_nodes)
         do jsh=1,nsh
           if (.not. bas_cn2bfr(basis,jsh,jsh_bflo,jsh_bfhi))
     $          call errquit('mo_ints: bas_cn2bfr',jsh)
           jleng = jsh_bfhi - jsh_bflo + 1
           if (schwarz_shell(ish,jsh)*schwarz_max().ge.tol2e) then
             do ksh=1,nsh
c
c Parallelize over JK index here.
c
               if (jk.eq.next) then
                 if (.not. bas_cn2bfr(basis,ksh,ksh_bflo,ksh_bfhi))
     $                call errquit('mo_ints: bas_cn2bfr',ksh)
                 kleng = ksh_bfhi - ksh_bflo + 1
                 call dfill(sssi_block,0.d0,dbl_mb(k_jsssi),1)
                 call dfill(ssni_block,0.d0,dbl_mb(k_jssni),1)
#ifdef PERMUT_SYMM
                 do lsh=1,ksh
#else
                 do lsh=1,nsh
#endif                  
                   if (schwarz_shell(ish,jsh)*schwarz_shell(ksh,lsh)
     $               .ge.tol2e) then
                     call dfill(sssi_block,0.d0,dbl_mb(k_tsssi),1)
                     dschw_done = dschw_done + 1.d0
                     if (.not. bas_cn2bfr(basis,lsh,lsh_bflo,lsh_bfhi))
     $                    call errquit('mo_ints: bas_cn2bfr',lsh)
                     call int_2e4c(basis, ish, jsh, basis, ksh, lsh,
     $                    mem2, dbl_mb(k_iscr), max2e, dbl_mb(k_eri))
#ifndef MOINTS_INTS_DUMMY
c      
c Transform 1st index for range lsh_bflo<->lsh_bfhi
c
                     call moints_1idx_trf( ish_bflo, ish_bfhi,
     $                                     jsh_bflo, jsh_bfhi,
     $                                     ksh_bflo, ksh_bfhi,
     $                                     lsh_bflo, lsh_bfhi,
     $                                     dbl_mb(k_eri),
     $                                     dbl_mb(k_mov), nbf,
     $                                     mo_indx_lo, mo_indx_hi,
     $                                     dbl_mb(k_jsssi) )
#ifdef PERMUT_SYMM
c
c Transform 1st index for range ksh_bflo<->ksh_bfhi
c
                     if (lsh.ne.ksh) then
                       call eri_tr( ish_bflo, ish_bfhi,
     $                              jsh_bflo, jsh_bfhi,
     $                              ksh_bflo, ksh_bfhi,
     $                              lsh_bflo, lsh_bfhi,
     $                              dbl_mb(k_eri),
     $                              dbl_mb(k_erit))

                       call moints_1idx_trf( ish_bflo, ish_bfhi,
     $                                       jsh_bflo, jsh_bfhi,
     $                                       lsh_bflo, lsh_bfhi,
     $                                       ksh_bflo, ksh_bfhi,
     $                                       dbl_mb(k_erit),
     $                                       dbl_mb(k_mov), nbf,
     $                                       mo_indx_lo, mo_indx_hi,
     $                                       dbl_mb(k_tsssi) )

                       call moints_1idx_move( nbf, ish_bflo, ish_bfhi,
     $                                        jsh_bflo, jsh_bfhi,
     $                                        lsh_bflo, lsh_bfhi,
     $                                        mo_indx_lo, mo_indx_hi,
     $                                        dbl_mb(k_tsssi),
     $                                        dbl_mb(k_jssni) )
                     endif
#endif
                   endif
#endif
                 enddo

c
c Push into global memory
c
#ifndef MOINTS_INTS_DUMMY
                 if (oexch) then
                   call moints_ktransp(kleng,jleng,ileng,noper,
     $                                 dbl_mb(k_jsssi),dbl_mb(k_ksssi))
                   call moints_push_1idx( nbf, ish_bflo, ish_bfhi,
     $                                    ksh_bflo, ksh_bfhi,
     $                                    jsh_bflo, jsh_bfhi,
     $                                    mo_indx_lo, mo_indx_hi,
     $                                    dbl_mb(k_ksssi), g_k1idx )
#ifdef PERMUT_SYMM
                   call moints_push_1idx_b( nbf, ish_bflo, ish_bfhi,
     $                                     ksh_bflo, ksh_bfhi,
     $                                     mo_indx_lo, mo_indx_hi,
     $                                     dbl_mb(k_jssni), g_k1idx )
#endif
                 endif
                 if (ocoul) then
                   call moints_push_1idx( nbf, ish_bflo, ish_bfhi,
     $                                    jsh_bflo, jsh_bfhi,
     $                                    ksh_bflo, ksh_bfhi,
     $                                    mo_indx_lo, mo_indx_hi,
     $                                    dbl_mb(k_jsssi), g_j1idx )
#ifdef PERMUT_SYMM
                   call moints_push_1idx_a( nbf, ish_bflo, ish_bfhi,
     $                                     jsh_bflo, jsh_bfhi,
     $                                     mo_indx_lo, mo_indx_hi,
     $                                     dbl_mb(k_jssni), g_j1idx )
#endif
                 endif
#endif
                 next = nxtval(num_nodes)
               endif
               jk = jk + 1

c
c End ksh-loop & jsh-loop
c
             enddo
           endif
         enddo
         next = nxtval(-num_nodes)
         t1qtr = t1qtr + tcgtime() - tt
#ifndef MOINTS_INTS_DUMMY
c
c 2nd Index (global) transformation
c Push half-transformed integrals (for i-shell) into global 
c operator matrices
c
         tt = tcgtime()
         ncol_tij = noper*ileng*nbf
         if (ocoul) then
           call ga_dgemm('t','n',ncol_tij,noper,nbf,1.0d0,g_j1idx,
     $                   g_mocols,0.d0,g_j2idx)
           call moints_push_halftr(nbf,ish_bflo,ish_bfhi,noper,
     $                             g_j2idx,g_jhalf)
         endif
         if (oexch) then
           call ga_dgemm('t','n',ncol_tij,noper,nbf,1.0d0,g_k1idx,
     $                   g_mocols,0.d0,g_k2idx)
           call moints_push_halftr(nbf,ish_bflo,ish_bfhi,noper,
     $                             g_k2idx,g_khalf)
         endif
         t2qtr = t2qtr + tcgtime() - tt
#endif
c
c End loop over ish
c
       enddo

       call ga_sync()
       call ga_dgop(MOINTS_SCHWARZ_STAT,dschw_done,1,'+')
       schw_ratio = dschw_done/(nsh*nsh*nsh*nsh)*100.d0
       thalf = tcgtime() - thalf
       if (ga_nodeid().eq.0) then
         write(6,986) schw_ratio,t1qtr,t2qtr,thalf
 986     format(10x,'Shell-quartets percentage:',4x,f10.1,'%',//,
*
*     PGI compiler does not like ifdefs and continuation lines mixed
*#ifdef MOINTS_INTS_DUMMY
*     $          10x,'Integrals only time:',11x,f10.2,/,
*#else
     $          10x,'1st quarter time:',14x,f10.2,/,
*#endif
     $          10x,'2nd quarter time:',14x,f10.2,/,
     $          10x,'Total half time:',15x,f10.2,/)
         call util_flush(6)
       endif
#ifdef DEBUG_PRINT
C       if (ocoul) call moints_print_opermatrix(noper,nbf,g_jhalf)
C       if (oexch) call moints_print_opermatrix(noper,nbf,g_khalf)
#endif
c
c 
c
c Clean up
c
       status = ga_destroy(g_mocols)
       if (oexch) then
         status = status.and.ga_destroy(g_k2idx)
         status = status.and.ga_destroy(g_k1idx)
       endif
       if (ocoul) then
         status = status.and.ga_destroy(g_j2idx)
         status = status.and.ga_destroy(g_j1idx)
       endif
       if (.not.(status))
     $   call errquit('moints_1st_half: cannot release globals',0)
c
      if (.not. ma_pop_stack(l_jssni)) 
     $     call errquit('moints: failed to pop temp transf', l_jssni)
      if (.not. ma_pop_stack(l_ksssi)) 
     $     call errquit('moints: failed to pop temp transf', l_ksssi)
      if (.not. ma_pop_stack(l_tsssi)) 
     $     call errquit('moints: failed to pop temp transf', l_tsssi)
      if (.not. ma_pop_stack(l_jsssi)) 
     $     call errquit('moints: failed to pop temp transf', l_jsssi)
      if (.not. ma_pop_stack(l_mov)) 
     $     call errquit('moints: failed to pop movectors', l_mov)
      if (.not. ma_pop_stack(l_iscr)) 
     $     call errquit('moints: failed to pop int scratch', l_iscr)
      if (.not. ma_pop_stack(l_erit)) 
     $     call errquit('moints: failed to pop int buffer', l_erit)
      if (.not. ma_pop_stack(l_eri)) 
     $     call errquit('moints: failed to pop int buffer', l_eri)

       return
       end






c
c Performs straightforward two-index transformation on
c half-transformed integrals.
c
c This routines permits the aliasing of
c        g_jhalf -> g_coul
c        g_khalf -> g_exch
c Provided the distributions and array sizes are
c compatible.
c
c
c
        subroutine moints_2nd_half(noper,nbf,mo_lo,mo_hi,g_movecs,
     $                             g_jhalf,g_coul,ocoul,
     $                             g_khalf,g_exch,oexch)
        implicit none
#include "global.fh"
#include "mafdecls.fh"
#include "tcgmsg.fh"
        integer MOINTS_J_SUM, MOINTS_K_SUM
        parameter(MOINTS_J_SUM=1973,MOINTS_K_SUM=1974)
        integer noper
        integer nbf
        integer mo_lo,mo_hi
        integer g_movecs
        integer g_jhalf
        integer g_khalf
        integer g_coul
        integer g_exch
        logical ocoul, oexch
c
c Local
c
        integer l_tmp, k_tmp, l_mov, k_mov
        integer ij, jnonzero, knonzero, my_id, jlo, jhi
        integer k_src, ld_src, k_dest, ld_dest
        integer nn,n2,n2n2
        double precision tt,t3qtr,t4qtr,thalf
        logical status,oalias
        integer moints_integ_count
        external moints_integ_count
        logical ga_check_moblocked
        external ga_check_moblocked
c
c Allocate local scratch space
c
        nn = nbf*nbf
        n2 = mo_hi - mo_lo + 1
        n2n2 = n2*n2
        status = ma_push_get(MT_DBL,(n2*nbf),'scratch 1',l_tmp,k_tmp)
        status = status.and.ma_push_get(MT_DBL,(n2*nbf),'MO vectors',
     $                                 l_mov,k_mov)
        if (.not.(status))
     $      call errquit('moints_2nd_half: not enough local memory',0)
        call ga_get(g_movecs,1,nbf,mo_lo,mo_hi,dbl_mb(k_mov),nbf)
        jnonzero = 0
        knonzero = 0
        my_id = ga_nodeid()
        thalf = tcgtime()
        t3qtr = 0.d0
        t4qtr = 0.d0
c
c Coulomb 
c
        if (ocoul) then
          oalias = g_jhalf.eq.g_coul
          if (.not.ga_check_moblocked(g_jhalf,noper,nbf,jlo,jhi))
     $      call errquit(
     $      'moints_2nd_half: wrong dimensions/distrib half Coul',0)
          if ((.not.(oalias)).and.
     $        (.not.ga_check_moblocked(g_coul,noper,n2,jlo,jhi)))
     $      call errquit(
     $      'moints_2nd_half: wrong dimensions/distrib Coul',0)
          do ij=jlo,jhi
            tt = tcgtime()
            call ga_access(g_jhalf,1,nn,ij,ij,k_src,ld_src)
            call sgemm('n','n',nbf,n2,nbf,1.d0,dbl_mb(k_src),nbf,
     $                 dbl_mb(k_mov),nbf,0.d0,dbl_mb(k_tmp),nbf)
            t3qtr = t3qtr + tcgtime() - tt
            tt = tcgtime()
            if (oalias) then
              k_dest = k_src
            else
              call ga_release(g_jhalf,1,nn,ij,ij)
              call ga_access(g_coul,1,n2n2,ij,ij,k_dest,ld_dest)
            endif
            call sgemm('t','n',n2,n2,nbf,1.d0,dbl_mb(k_mov),nbf,
     $                 dbl_mb(k_tmp),nbf,0.d0,dbl_mb(k_dest),n2)
            jnonzero = jnonzero +
     $                 moints_integ_count(n2,dbl_mb(k_dest))
            call ga_release_update(g_coul,1,n2n2,ij,ij)
            t4qtr = t4qtr + tcgtime() - tt
          enddo
          call ga_sync()
        endif
c
c Exchange
c
        if (oexch) then
          oalias = g_khalf.eq.g_exch
          if (.not.ga_check_moblocked(g_khalf,noper,nbf,jlo,jhi))
     $      call errquit(
     $      'moints_2nd_half: wrong dimensions/distrib half exch',0)
          if ((.not.(oalias)).and.
     $        (.not.ga_check_moblocked(g_exch,noper,n2,jlo,jhi)))
     $      call errquit(
     $      'moints_2nd_half: wrong dimensions/distrib exch',0)
          do ij=jlo,jhi
            tt = tcgtime()
            call ga_access(g_khalf,1,nn,ij,ij,k_src,ld_src)
            call sgemm('n','n',nbf,n2,nbf,1.d0,dbl_mb(k_src),nbf,
     $                 dbl_mb(k_mov),nbf,0.d0,dbl_mb(k_tmp),nbf)
            t3qtr = t3qtr + tcgtime() - tt
            tt = tcgtime()
            if (oalias) then
              k_dest = k_src
            else
              call ga_release(g_khalf,1,nn,ij,ij)
              call ga_access(g_exch,1,n2n2,ij,ij,k_dest,ld_dest)
            endif
            call sgemm('t','n',n2,n2,nbf,1.d0,dbl_mb(k_mov),nbf,
     $                 dbl_mb(k_tmp),nbf,0.d0,dbl_mb(k_dest),n2)
            knonzero = knonzero +
     $                 moints_integ_count(n2,dbl_mb(k_dest))
            call ga_release_update(g_exch,1,n2n2,ij,ij)
            t4qtr = t4qtr + tcgtime() - tt
          enddo
          call ga_sync()
        endif
c
c Clean up
c
        if (.not. ma_pop_stack(l_mov)) 
     $     call errquit('moints: failed to pop temp transf', l_mov)
        if (.not. ma_pop_stack(l_tmp)) 
     $     call errquit('moints: failed to pop temp transf', l_tmp)
        thalf = tcgtime() - thalf
c
c Statistics
c
        if (ocoul) call ga_igop(MOINTS_J_SUM,jnonzero,1,'+')
        if (oexch) call ga_igop(MOINTS_K_SUM,knonzero,1,'+')
        if (ga_nodeid().eq.0) then
          write(6,973) t3qtr,t4qtr,thalf
 973      format(10x,'3rd quarter time:',14x,f10.2,/,
     $           10x,'4th quarter time:',14x,f10.2,/,
     $           10x,'Total half time:',15x,f10.2)
          call util_flush(6)
          ij = n2*n2*(noper*(noper+1))/2
          if ((ocoul).and.(oexch)) ij = ij*2
          write(6,901) ij
          if (ocoul) write(6,902) jnonzero
          if (oexch) write(6,903) knonzero
 901      format(/,10x,'Total number of integrals:',5x,i10)
 902      format(  10x,'Non-zero Coulomb integrals:',4x,i10)
 903      format(  10x,'Non-zero exchange integrals:',3x,i10)
        endif
        return
        end




















c
c Auxiliary routines to manage and manipulate memory
c

       subroutine moints_1idx_trf( ilo, ihi, jlo, jhi, klo, khi,
     $                             llo, lhi, eri, c, nbf,
     $                             mo_lo, mo_hi, x )
       implicit none
       integer nbf
       integer ilo,ihi,jlo,jhi,klo,khi,llo,lhi,mo_lo,mo_hi
       double precision eri( llo:lhi, klo:khi, jlo:jhi, ilo:ihi )
       double precision c( 1:nbf, mo_lo: mo_hi )
       double precision x( klo:khi, jlo:jhi, ilo:ihi, mo_lo:mo_hi )
       integer nn,mm,ll

       nn = (ihi-ilo+1)*(jhi-jlo+1)*(khi-klo+1)
       mm = mo_hi-mo_lo+1
       ll = lhi - llo + 1
       call sgemm('t','n',nn,mm,ll,1.d0,eri,ll,c(llo,1),nbf,1.d0,x,nn)
       return
       end






       subroutine moints_push_halftr(nbf,mulo,muhi,noper,g_j2idx,
     $                               g_joper)
       implicit none
#include "global.fh"
#include "mafdecls.fh"
       integer nbf, mulo, muhi, noper
       integer g_j2idx, g_joper
       integer i,j,ij,mu,muleng,nopert
       integer l_scr, k_scr, k_local, ld_local
       integer j_off,mu_off,nu_off
       integer jlo,jhi
       logical ga_check_moblocked
       external ga_check_moblocked
       
       muleng = muhi - mulo + 1
       nopert = (noper*(noper+1))/2
       if (.not.ga_check_moblocked(g_joper,noper,nbf,jlo,jhi))
     $      call errquit('moints_push_halftr: wrong distrib',0)
       if (.not.ma_push_get(MT_DBL,nbf,'scr',l_scr,k_scr))
     $      call errquit('moints_push_halftr: cannot allocate',0)
       do i=1,noper
         do j=1,i
           ij = (i*(i-1))/2 + j
           if ((ij.ge.jlo).and.(ij.le.jhi)) then
             call ga_access(g_joper,1,(nbf*nbf),ij,ij,k_local,ld_local)
             j_off = (j-1)*muleng
             do mu=mulo,muhi
               nu_off = (j_off+(mu-mulo))*nbf
               mu_off = (mu-1)*nbf
               call ga_get(g_j2idx,nu_off+1,nu_off+nbf,i,i,
     $                     dbl_mb(k_scr),nbf)
               call scopy(nbf,dbl_mb(k_scr),1,dbl_mb(k_local+mu_off),1)
C               call ga_put(g_joper,mu_off+1,mu_off+nbf,ij,ij,
C     $                     dbl_mb(k_scr),nbf)
             enddo
             call ga_release_update(g_joper,1,(nbf*nbf),ij,ij)
           endif
         enddo
       enddo
       call ga_sync()
       if (.not.ma_pop_stack(l_scr))
     $   call errquit('moints_push_halftr: pop stack failed',0)
       return
       end





       subroutine moints_push_1idx( nbf, ilo, ihi, jlo, jhi, klo, khi,
     $                              mo_lo, mo_hi, x, g_j1idx )
       implicit none
#include "global.fh"
#include "mafdecls.fh"
       integer nbf,ilo,ihi,jlo,jhi,klo,khi,mo_lo,mo_hi
       double precision x(klo:khi, jlo:jhi, ilo:ihi, mo_lo:mo_hi)
       integer g_j1idx
       integer t, i, j
       integer ileng, kleng, ti, tij

       ileng = ihi - ilo + 1
       kleng = khi - klo + 1
       do t=mo_lo,mo_hi
         do i=ilo,ihi
           ti = (t-mo_lo)*ileng + (i-ilo+1)
           do j=jlo,jhi
             tij = (ti-1)*nbf + j
             call ga_acc(g_j1idx,klo,khi,tij,tij,x(klo,j,i,t),
     $                   kleng,1.d0)
C             call ga_put(g_j1idx,klo,khi,tij,tij,x(klo,j,i,t),kleng)
           enddo
         enddo
       enddo
       end





       subroutine moints_ktransp(k,l,m,n,x,y)
       implicit none
       integer k,l,m,n
       double precision x(k,l,m,n),y(l,k,m,n)
       integer a,b,c,d

       do a=1,n
         do b=1,m
           do c=1,k
             do d=1,l
               y(d,c,b,a) = x(c,d,b,a)
             enddo
           enddo
         enddo
       enddo
       return
       end












        integer function moints_integ_count(nbf,xx)
        implicit none
        integer nbf
        double precision xx(nbf,nbf)
        integer i,j,count
        
        count = 0
        do i=1,nbf
          do j=1,nbf
            if (abs(xx(j,i)).gt.1.d-12) then
              count = count + 1
            endif
          enddo
        enddo
        moints_integ_count = count
        return
        end

              








       






       subroutine eri_tr(ilo,ihi,jlo,jhi,klo,khi,llo,lhi,x,y)
       implicit none
       integer ilo,ihi,jlo,jhi,klo,khi,llo,lhi
       double precision x(llo:lhi,klo:khi,jlo:jhi,ilo:ihi)
       double precision y(klo:khi,llo:lhi,jlo:jhi,ilo:ihi)
       integer i,j,k,l

       do i=ilo,ihi
         do j=jlo,jhi
           do k=klo,khi
             do l=llo,lhi
               y(k,l,j,i) = x(l,k,j,i)
             enddo
           enddo
         enddo
       enddo
       return
       end







       subroutine moints_1idx_move(nbf,ilo,ihi,jlo,jhi,llo,lhi,mo_lo,
     $                             mo_hi,x,y)
       implicit none
       integer nbf,ilo,ihi,jhi,jlo,llo,lhi,mo_lo,mo_hi
       double precision x( llo:lhi, jlo:jhi, ilo:ihi, mo_lo:mo_hi)
       double precision y( nbf, jlo:jhi, ilo:ihi, mo_lo:mo_hi )
       integer t,i,j,l

       do t=mo_lo,mo_hi
         do i=ilo,ihi
           do j=jlo,jhi
             do l=llo,lhi
               y(l,j,i,t) = x(l,j,i,t)
             enddo
           enddo
         enddo
       enddo
       return
       end






       subroutine moints_push_1idx_a(nbf,ilo,ihi,jlo,jhi,
     $                               mo_lo,mo_hi,x,g_j1idx)
       implicit none
       integer nbf,ilo,ihi,jlo,jhi,mo_lo,mo_hi
       double precision x(nbf,jlo:jhi,ilo:ihi,mo_lo:mo_hi)
       integer g_j1idx
       integer ileng
       integer t,i,j,ti,tij
       
       ileng = ihi - ilo + 1
       do t=mo_lo,mo_hi
         do i=ilo,ihi
           ti = (t-mo_lo)*ileng + (i-ilo+1)
           do j=jlo,jhi
             tij = (ti-1)*nbf + j
             call ga_acc(g_j1idx,1,nbf,tij,tij,x(1,j,i,t),
     $                   nbf,1.d0)
           enddo
         enddo
       enddo
       end





       subroutine moints_push_1idx_b( nbf,ilo,ihi,jlo,jhi,mo_lo,mo_hi,
     $                                x, g_k1idx )
       implicit none
       integer nbf,ilo,ihi,jlo,jhi,mo_lo,mo_hi
       double precision x(nbf,jlo:jhi,ilo:ihi,mo_lo:mo_hi)
       integer g_k1idx
       integer ileng
       integer t,i,j,l,ti,til

       ileng = ihi - ilo + 1
       do t=mo_lo,mo_hi
         do i=ilo,ihi
           ti = (t-mo_lo)*ileng + (i-ilo+1)
           do l=1,nbf
             til = (ti-1)*nbf + l
             do j=jlo,jhi
               call ga_acc(g_k1idx,j,j,til,til,x(l,j,i,t),
     $                     1,1.d0)
             enddo
           enddo
         enddo
       enddo
       return
       end

#endif





               

#ifdef DEBUG_PRINT
       subroutine moints_print_opermatrix(noper,nbf,g_a)
       implicit none
#include "global.fh"
#include "mafdecls.fh"       
       integer noper,nbf
       integer g_a
       integer j,k,jk
       integer my_id, ilo, ihi, jlo, jhi
       integer k_local, ld_local

       my_id = ga_nodeid()
       call ga_distribution(g_a,my_id,ilo,ihi,jlo,jhi)
       do j=1,noper
         do k=1,j
           jk = (j*(j-1))/2 + k
           if ((jk.ge.jlo).and.(jk.le.jhi)) then
             write(6,901) j,k
 901         format(//,'Operator: [',i2,',',i2,']',/)
             print*,my_id,'  ',ilo,ihi,'  ',jk
             call ga_access(g_a,ilo,ihi,jk,jk,k_local,ld_local)
             call moints_print_square(nbf,dbl_mb(k_local))
           endif
           call ga_sync()
         enddo
       enddo

       return
       end
       



       subroutine moints_print_square(n,x)
       implicit none
       integer n,i,j
       double precision x(n,n)
       
       do i=1,n
         write(6,901) (x(i,j),j=1,n)
 901     format(15f9.4)
       enddo
       call util_flush(6)
       end
       





       subroutine moints_print_1(ilo,ihi,jlo,jhi,
     $                           klo,khi,mo_lo,mo_hi,x)
       implicit none
       integer ilo,ihi,jlo,jhi,klo,khi,mo_lo,mo_hi
       double precision x(klo:khi,jlo:jhi,ilo:ihi,mo_lo:mo_hi)
       integer m,i,j,k

       do m=mo_lo,mo_hi
         do i=ilo,ihi
           write(6,933) ((x(k,j,i,m),k=klo,khi),j=jlo,jhi)
 933       format(15f9.4)
         enddo
         write(6,*)
       enddo

       return
       end

#endif



C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
c
c
c atw - 8/25/94
c
c  This is an alternate algorithm for the
c  half-transformed Coulomb operator, (the
c  obvious algorithm from Whiteside et al).
c  Uses 4-fold permutation symmetry.
c
c
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
       subroutine moints_1st_half_a(basis,mo_indx_lo,mo_indx_hi,
     $                              g_movecs,
     $                              g_jhalf,ocoul,
     $                              g_khalf,oexch)
       implicit none
#include "tcgmsg.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
#include "schwarz.fh"
       integer MOINTS_SCHWARZ_STAT
       parameter(MOINTS_SCHWARZ_STAT=1921)
c
c
       integer basis                          ! Basis handle
       integer mo_indx_lo, mo_indx_hi         ! 1st pair of MO indices
       integer g_movecs                       ! MO coefficients
       integer g_jhalf                        ! Half-transformed Coulomb operator
       integer g_khalf                        ! Half-transformed exchange operator (UNUSED !)
       logical ocoul,oexch                    ! Type selection 
c
c Local
c
       integer noper,nbf
       integer ssbb_block, ssba_block, ssaa_block
       integer l_jssbb,k_jssbb
       integer l_jssba,k_jssba
       integer l_jssaa,k_jssaa
       integer l_zssaa,k_zssaa, l_yssaa, k_yssaa
       integer ssn, ssa
       integer l_iscr,k_iscr,l_eri,k_eri
       integer l_mov,k_mov
       integer mem2,max2e,maxbf_shell
       integer nsh,ish,jsh,ksh,lsh
       integer ish_bflo,ish_bfhi,jsh_bflo,jsh_bfhi
       integer ksh_bflo,ksh_bfhi,lsh_bflo,lsh_bfhi
       integer ileng,jleng
       integer num_nodes, next, ij
       double precision tol2e,dschw_done,schw_ratio
       double precision t1qtr,t2qtr,thalf,tzz,tint
       logical status
       data tol2e/1.d-10/
c
c
c Get general info
c
       call ga_sync()
       thalf = tcgtime()
       status = bas_numbf(basis,nbf)
       status = status.and.bas_numcont(basis,nsh)
       status = status.and.bas_nbf_cn_max(basis,maxbf_shell)
       if (.not.status) call errquit('moints: cannot get basis info',0)
       noper = mo_indx_hi - mo_indx_lo + 1
       if (ga_nodeid().eq.0) then
         write(6,927) nsh,maxbf_shell
 927     format(10x,'Number of shells:',19x,i5,/,
     $          10x,'Maximum shell length:',15x,i5)
         call util_flush(6)
       endif
c
c Ints allocation
c
       call int_mem_2e4c(max2e, mem2)
       status = ma_push_get(MT_DBL, max2e, 'moints: buf', l_eri, k_eri)
       status = status.and.ma_push_get(MT_DBL, mem2,
     $          'moints: scr', l_iscr, k_iscr)
c
c Allocate and get local
c
       status = status.and.ma_push_get(MT_DBL,(noper*nbf),
     $          'movecs cols',l_mov,k_mov)
       if (.not.(status)) call errquit('failed allocate MO vectors',0)
       call ga_get(g_movecs,1,nbf,mo_indx_lo,mo_indx_hi,
     $             dbl_mb(k_mov),nbf)
c
c Allocate local shell-shell-basis-basis blocks
c
       ssbb_block = maxbf_shell*maxbf_shell*nbf*nbf
       ssba_block = maxbf_shell*maxbf_shell*nbf*noper
       ssaa_block = maxbf_shell*maxbf_shell*noper*noper
       status = status.and.ma_push_get(MT_DBL,ssbb_block,
     $          'J ssbb block',l_jssbb,k_jssbb)
       status = status.and.ma_push_get(MT_DBL,ssba_block,
     $          'J ssba block',l_jssba,k_jssba)
       status = status.and.ma_push_get(MT_DBL,ssaa_block,
     $          'J ssaa block',l_jssaa,k_jssaa)
       status = status.and.ma_push_get(MT_DBL,ssaa_block,
     $          'J transp 1 ssaa block',l_zssaa,k_zssaa)
       status = status.and.ma_push_get(MT_DBL,ssaa_block,
     $          'J transp 2 ssaa block',l_yssaa,k_yssaa)
       if (.not.status) call
     $          errquit('moints: cannot allocate local memory',0)
c
c Start 4-fold shell loop
c
       if (ocoul) call ga_zero(g_jhalf)
       t1qtr = 0.d0
       t2qtr = 0.d0
       tint = 0.d0
       dschw_done = 0.d0
       num_nodes = ga_nnodes()
       ij = 0
       next = nxtval(num_nodes)
c
c Four-fold shell loop
c
       do ish=1,nsh
         if (.not. bas_cn2bfr(basis,ish,ish_bflo,ish_bfhi))
     $        call errquit('mo_ints: bas_cn2bfr',ish)
         ileng = ish_bfhi - ish_bflo + 1
         do jsh=1,ish
           if (.not. bas_cn2bfr(basis,jsh,jsh_bflo,jsh_bfhi))
     $          call errquit('mo_ints: bas_cn2bfr',jsh)
           jleng = jsh_bfhi - jsh_bflo + 1
           ssn = ileng*jleng*nbf
           ssa = ileng*jleng*noper
c
c Parallelize on (ij)
c
           if (ij.eq.next) then
             if (schwarz_shell(ish,jsh)*schwarz_max().ge.tol2e) then
               call dfill(ssbb_block,0.d0,dbl_mb(k_jssbb),1)
               tzz = tcgtime()
               do ksh=1,nsh
                 if (.not. bas_cn2bfr(basis,ksh,ksh_bflo,ksh_bfhi))
     $                call errquit('mo_ints: bas_cn2bfr',ksh)
                 do lsh=1,ksh
                   if (schwarz_shell(ish,jsh)*schwarz_shell(ksh,lsh)
     $               .ge.tol2e) then
c
c Compute shell-quartet integral block
c
                     dschw_done = dschw_done + 1.d0
                     if (.not. bas_cn2bfr(basis,lsh,lsh_bflo,lsh_bfhi))
     $                    call errquit('mo_ints: bas_cn2bfr',lsh)
                     call int_2e4c(basis, ish, jsh, basis, ksh, lsh,
     $                    mem2, dbl_mb(k_iscr), max2e, dbl_mb(k_eri))
                     call moints_push_ints1( ish_bflo, ish_bfhi,
     $                                       jsh_bflo, jsh_bfhi,
     $                                       ksh_bflo, ksh_bfhi,
     $                                       lsh_bflo, lsh_bfhi,
     $                                       dbl_mb(k_eri),
     $                                       nbf, dbl_mb(k_jssbb))
                   endif
                 enddo
               enddo
c
c First half-transformation
c
               tint = tint + tcgtime() - tzz
               call sgemm('t','n',noper,ssn,nbf,1.d0,dbl_mb(k_mov),
     $                    nbf,dbl_mb(k_jssbb),nbf,0.d0,
     $                    dbl_mb(k_jssba),noper)
               t1qtr = t1qtr + tcgtime() - tzz
               tzz = tcgtime()
c
c Second half-transformation
c
               call moints_2ndi_tr( nbf, noper, jleng, ileng,
     $                              dbl_mb(k_jssba), dbl_mb(k_mov),
     $                              dbl_mb(k_jssaa))
               call moints_transp_ss( noper, ileng, jleng,
     $                                dbl_mb(k_jssaa),
     $                                dbl_mb(k_zssaa),
     $                                dbl_mb(k_yssaa) )
c
c Push half-transformed into global
c
               call moints_push_ints2( ish_bflo, ish_bfhi,
     $                                 jsh_bflo, jsh_bfhi,
     $                                 nbf, noper,
     $                                 dbl_mb(k_zssaa),
     $                                 dbl_mb(k_yssaa),
     $                                 g_jhalf )
               t2qtr = t2qtr + tcgtime() - tzz
             endif
             next = nxtval(num_nodes)
           endif
c
c End parallel task
c
           ij = ij + 1
         enddo
       enddo
       next = nxtval(-num_nodes)

       call ga_sync()
       call ga_dgop(MOINTS_SCHWARZ_STAT,dschw_done,1,'+')
       schw_ratio = dschw_done/(nsh*nsh*nsh*nsh)*100.d0
       thalf = tcgtime() - thalf
       if (ga_nodeid().eq.0) then
         write(6,986) schw_ratio,tint,t1qtr,t2qtr,thalf
 986     format(10x,'Shell-quartets percentage:',4x,f10.1,'%',//,
     $          10x,'Integrals time:',16x,f10.2,/,
     $          10x,'1st quarter time:',14x,f10.2,/,
     $          10x,'2nd quarter time:',14x,f10.2,/,
     $          10x,'Total half time:',15x,f10.2,/)
         call util_flush(6)
       endif
#ifdef DEBUG_PRINT
       if (ocoul) call moints_print_opermatrix(noper,nbf,g_jhalf)
#endif
c
c 
c
c Clean up
c
c
      if (.not. ma_pop_stack(l_yssaa)) 
     $     call errquit('moints: failed to pop temp transf', l_yssaa)
      if (.not. ma_pop_stack(l_zssaa)) 
     $     call errquit('moints: failed to pop temp transf', l_zssaa)
      if (.not. ma_pop_stack(l_jssaa)) 
     $     call errquit('moints: failed to pop temp transf', l_jssaa)
      if (.not. ma_pop_stack(l_jssba)) 
     $     call errquit('moints: failed to pop temp transf', l_jssba)
      if (.not. ma_pop_stack(l_jssbb)) 
     $     call errquit('moints: failed to pop temp transf', l_jssbb)
      if (.not. ma_pop_stack(l_mov)) 
     $     call errquit('moints: failed to pop movectors', l_mov)
      if (.not. ma_pop_stack(l_iscr)) 
     $     call errquit('moints: failed to pop int scratch', l_iscr)
      if (.not. ma_pop_stack(l_eri)) 
     $     call errquit('moints: failed to pop int buffer', l_eri)

       return
       end






c
c ====================================================================
c      Auxiliary routines to help manage array
c      addressing, transposition, etc.
c ====================================================================
c
c
c

c
c Copy integrals from shell-quartet offset addressing
c to absolute AO indices
c
       subroutine moints_push_ints1( ilo, ihi, jlo, jhi, klo, khi,
     $                               llo, lhi, eri, nbf, buf )
       implicit none
       integer ilo, ihi, jlo, jhi
       integer klo, khi, llo, lhi
       integer nbf
       double precision eri(llo:lhi,klo:khi,jlo:jhi,ilo:ihi)
       double precision buf(nbf,nbf,jlo:jhi,ilo:ihi)
       integer i,j,k,l

       do i=ilo,ihi
         do j=jlo,jhi
           do k=klo,khi
             do l=llo,lhi
               buf(l,k,j,i) = eri(l,k,j,i)
               buf(k,l,j,i) = eri(l,k,j,i)
             enddo
           enddo
         enddo
       enddo
       return
       end



c
c Push half-transformed integrals into global
c array. Copies strips of length: (jhi-jlo+1)
c      
       subroutine moints_push_ints2( ilo, ihi, jlo, jhi,
     $                               nbf, noper, x, y, g_half )
       implicit none
       integer ilo, ihi, jlo, jhi, nbf, noper
       double precision x(jlo:jhi,ilo:ihi,noper,noper)
       double precision y(ilo:ihi,jlo:jhi,noper,noper)
       integer g_half
       integer i,j,t,u,ij1,ij2,tu,ileng,jleng

       do t=1,noper
         do u=1,t
           tu = ((t-1)*t)/2 + u
           do i=ilo,ihi
             ij1 = (i-1)*nbf+jlo
             ij2 = (i-1)*nbf+jhi
             jleng = jhi - jlo + 1
             call ga_put(g_half,ij1,ij2,tu,tu,x(jlo,i,u,t),jleng)
           enddo
           do j=jlo,jhi
             ij1 = (j-1)*nbf+ilo
             ij2 = (j-1)*nbf+ihi
             ileng = ihi - ilo + 1
             call ga_put(g_half,ij1,ij2,tu,tu,y(ilo,j,u,t),ileng)
           enddo
         enddo
       enddo
       return
       end





c
c Loops over (ij)-shells and performs 2nd index
c transformation. (This cannot be done as in a
c single dgemm)
c
c
       subroutine moints_2ndi_tr( nbf, noper, jleng, ileng,
     $                            xx, yy, zz )
       implicit none
       integer nbf,noper,jleng,ileng
       double precision xx(noper,nbf,jleng,ileng)
       double precision yy(nbf,noper)
       double precision zz(noper,noper,jleng,ileng)
       integer i,j


       do i=1,ileng
         do j=1,jleng
           call sgemm('n','n',noper,noper,nbf,1.d0,xx(1,1,j,i),
     $                 noper,yy,nbf,0.d0,zz(1,1,j,i),noper)
         enddo
       enddo
       return
       end






c
c Transpose half-transformed integrals so AO-indices
c varies faster, to accomodate ga_put() using
c shell-strips.
c
       subroutine moints_transp_ss( noper, ileng, jleng, x, y, z)
       implicit none
       integer noper, ileng, jleng
       double precision x(noper,noper,jleng,ileng)
       double precision y(jleng,ileng,noper,noper)
       double precision z(ileng,jleng,noper,noper)
       integer i,j,k,l

       do i=1,ileng
         do j=1,jleng
           do k=1,noper
             do l=1,noper
               y(j,i,l,k) = x(l,k,j,i)
               z(i,j,l,k) = x(l,k,j,i)
             enddo
           enddo
         enddo
       enddo
       return
       end






C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
c
c
c atw - 8/25/94
c
c This is the first algorithm
c using 4-fold permutational symmetry.
c
c Had problems with synchronization, so ish-loop
c is split in latest version for load-balancing
c
c
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
C========================================================================
       subroutine moints_build(basis,
     $                         mo1_lo,mo1_hi,
     $                         mo2_lo,mo2_hi,
     $                         g_movecs,
     $                         g_coul,ocoul,
     $                         g_exch,oexch,
     $                         oprintstats,
     $                         chunk_factor )
       implicit none
#include "tcgmsg.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
#include "schwarz.fh"
c
c
c
       integer MOINTS_SCHWARZ_STAT
       parameter(MOINTS_SCHWARZ_STAT=1921)
c
c Arguments
c
       integer basis                          ! Basis handle
       integer mo1_lo, mo1_hi                 ! 1st Pair Index range
       integer mo2_lo, mo2_hi                 ! 2nd Pair Index range
       integer g_movecs                       ! MO coefficients
       integer g_coul                         ! Coulomb operator
       integer g_exch                         ! Exchange operator
       logical ocoul,oexch                    ! Type selection
       logical oprintstats                    ! Print flag
       double precision chunk_factor              
c
c Local variables
c
       integer nmo1,nmo2,nbf,nsh,maxbfsh
       integer ish,jsh,ksh,lsh
       integer ibflo,ibfhi,jbflo,jbfhi,kbflo,kbfhi,lbflo,lbfhi
       integer ileng,jleng,kleng,lleng
       integer g_k2idx,g_j2idx
       integer l_sssi,k_sssi
       integer l_ssni,k_ssni
       integer l_ssai,k_ssai
       integer l_ssji,k_ssji
       integer l_ab1, k_ab1, l_ab2, k_ab2
       integer l_eri,k_eri,l_erit,k_erit
       integer l_iscr,k_iscr
       integer l_mo,k_mo
       integer n_sssi,n_ssni,n_ssai,n_ssji,n_ab,nrow,ncol
       integer mem2,max2e
       integer num_nodes,ploop,next,next0,chunksiz
       integer my_id,i,nptasks,npcomm
       double precision tol2e,permscale,tri_shells
       double precision tt,t1qtr,t2qtr,t34,t4sh
       double precision schw_done,schw_ratio
       double precision tzz,tpush,tyy,tint,twait
       logical status
#ifdef DEBUG_PARALLEL
       integer taskstats(100),commstats(100)
#endif
c
c
c
       integer nxtask
       external nxtask
c
c
c
       data tol2e/1.d-12/
c
c
c  General basis info
c
       num_nodes = ga_nnodes()
       status = bas_numbf(basis,nbf)
       status = status.and.bas_numcont(basis,nsh)
       status = status.and.bas_nbf_cn_max(basis,maxbfsh)
       if (.not.status) call errquit('moints: cannot get basis info',0)
       nmo1 = mo1_hi - mo1_lo + 1
       nmo2 = mo2_hi - mo2_lo + 1
c
c  Integrals allocation
c
       call int_mem_2e4c(max2e, mem2)
       status = ma_push_get(MT_DBL, max2e, 'moints: buf', l_eri, k_eri)
       status = status.and.ma_push_get(MT_DBL, max2e,
     $          'moints: buf', l_erit, k_erit)
       status = status.and.ma_push_get(MT_DBL, mem2,
     $          'moints: scr', l_iscr, k_iscr)
c
c  Local MO coefficients
c
       status = status.and.ma_push_get(MT_DBL,(nbf*nbf),
     $                                 'movecs cols',l_mo,k_mo)
       call ga_get(g_movecs,1,nbf,1,nbf,dbl_mb(k_mo),nbf)
c
c  Temporary partially-transformed arrays
c
       n_sssi = maxbfsh*maxbfsh*maxbfsh*nmo1
       n_ssni = maxbfsh*maxbfsh*nbf*nmo1
       n_ssai = maxbfsh*maxbfsh*nmo2*nmo1
       n_ssji = max((maxbfsh*maxbfsh*nmo1*nmo1),(maxbfsh*nmo2))
       n_ab = max(nmo1,nmo2)*max(nmo1,nmo2)
       status = status.and.ma_push_get(MT_DBL,n_sssi,
     $          'K sssi block',l_sssi,k_sssi)
       status = status.and.ma_push_get(MT_DBL,n_ssni,
     $          'K ssni block',l_ssni,k_ssni)
       if (oexch) then
         status = status.and.ma_push_get(MT_DBL,n_ssai,
     $          'K ssai block',l_ssai,k_ssai)
       endif
       if (ocoul) then
         status = status.and.ma_push_get(MT_DBL,n_ssji,
     $          'K ssai block',l_ssji,k_ssji)
       endif
       status = status.and.ma_push_get(MT_DBL,n_ab,
     $          'K ab1 block',l_ab1,k_ab1)
       status = status.and.ma_push_get(MT_DBL,n_ab,
     $          'K ab2 block',l_ab2,k_ab2)
       if (.not.(status)) call errquit('cannot allocate local memory',0)
c
c  Globals for accumulating partially-transformed (& transposing)
c
       nrow = maxbfsh*nbf
       ncol = nmo1*nmo2
       if (oexch) then
         if (.not.ga_create(MT_DBL,nrow,ncol,'K2idx',nrow,1,g_k2idx))
     $    call errquit('moints: cannot allocate global',0)
       endif

       ncol = (nmo1*(nmo1+1))/2
       if (ocoul) then
         if (.not.ga_create(MT_DBL,nrow,ncol,'J2idx',nrow,1,g_j2idx))
     $     call errquit('moints: cannot allocate global',0)
       endif
c
c Initialize
c
       tri_shells = (nsh*(nsh+1))/2.d0
       chunksiz = tri_shells/chunk_factor
c$$$       if (num_nodes.gt.(2*nsh)) then
c$$$         chunksiz = tri_shells/2.d0
c$$$       else
c$$$         chunksiz = tri_shells
c$$$       endif
       t1qtr = 0.d0
       t2qtr = 0.d0
       t34 = 0.d0
       tint = 0.d0
       tpush = 0.d0
       twait = 0.d0
       schw_done = 0.d0
       nptasks = 0
       npcomm = 0
       if (oexch) call ga_zero(g_exch)
       if (ocoul) call ga_zero(g_coul)
c
c  4-fold shell loop
c
       t4sh = tcgtime()
       do ish=1,nsh
         if (.not. bas_cn2bfr(basis,ish,ibflo,ibfhi))
     $        call errquit('mo_ints: bas_cn2bfr',ish)
         ileng = ibfhi - ibflo + 1
         if (oexch) call ga_zero(g_k2idx)
         if (ocoul) call ga_zero(g_j2idx)
         ploop = 0
         next = nxtask(num_nodes,chunksiz)
         do jsh=1,ish
           if (.not. bas_cn2bfr(basis,jsh,jbflo,jbfhi))
     $          call errquit('mo_ints: bas_cn2bfr',jsh)
           jleng = jbfhi - jbflo + 1
           next0 = next
           if (schwarz_shell(ish,jsh)*schwarz_max().ge.tol2e) then
             tt = tcgtime()
             call dfill(n_ssni,0.d0,dbl_mb(k_ssni),1)
             do ksh=1,nsh
               if (.not. bas_cn2bfr(basis,ksh,kbflo,kbfhi))
     $                call errquit('mo_ints: bas_cn2bfr',ksh)
               kleng = kbfhi - kbflo + 1
               do lsh=1,ksh
                 if (next.eq.ploop) then
c
c Shell-quartet parallel task
c ---------------------------
c
                   nptasks = nptasks + 1
                   if (schwarz_shell(ish,jsh)*schwarz_shell(ksh,lsh)
     $                .ge.tol2e) then
                     if (.not. bas_cn2bfr(basis,lsh,lbflo,lbfhi))
     $                    call errquit('mo_ints: bas_cn2bfr',lsh)
                     lleng = lbfhi - lbflo + 1
                     schw_done = schw_done + 1.d0
                     tyy = tcgtime()
                     call int_2e4c(basis, ish, jsh, basis, ksh, lsh,
     $                             mem2, dbl_mb(k_iscr), max2e,
     $                             dbl_mb(k_eri))
                     tint = tint + tcgtime() - tyy
#ifndef INTS_ONLY
                     permscale = 1.d0
                     if (ksh.eq.lsh) permscale = 0.5d0
                     call moints_trf1idx( nbf, mo1_lo, mo1_hi,
     $                                    ileng, jleng, kbflo, kbfhi,
     $                                    lbflo, lbfhi, permscale,
     $                                    dbl_mb(k_eri), dbl_mb(k_mo),
     $                                    dbl_mb(k_sssi),
     $                                    dbl_mb(k_ssni))
                     call moints_inttrsp( ileng, jleng, kleng, lleng,
     $                                    dbl_mb(k_eri),
     $                                    dbl_mb(k_erit))
                     call moints_trf1idx( nbf, mo1_lo, mo1_hi,
     $                                    ileng, jleng, lbflo, lbfhi,
     $                                    kbflo, kbfhi, permscale,
     $                                    dbl_mb(k_erit), dbl_mb(k_mo),
     $                                    dbl_mb(k_sssi),
     $                                    dbl_mb(k_ssni))
#endif
                   endif
                   next = nxtask(num_nodes,chunksiz)
c
c ---------------------------
c
                 endif
                 ploop = ploop + 1
               enddo
             enddo
             t1qtr = t1qtr + tcgtime() - tt
#ifndef INTS_ONLY
c
c Only do 2nd quarter transformation &
c communication if a shell-quartet has been done
c
             if (next.ne.next0) then
               tt = tcgtime()
               npcomm = npcomm + 1
               permscale = 1.d0
               if (jsh.eq.ish) permscale = 0.5d0
c
c 2nd qtr transformation
c
               if (oexch)
     $           call moints_trf2idx( nbf, mo2_lo, mo2_hi, nmo1,
     $                                ileng, jleng, permscale,
     $                                dbl_mb(k_ssni), dbl_mb(k_mo),
     $                                dbl_mb(k_ssai))
               if (ocoul)
     $           call moints_trf2idx( nbf, mo1_lo, mo1_hi, nmo1,
     $                                ileng, jleng, permscale,
     $                                dbl_mb(k_ssni), dbl_mb(k_mo),
     $                                dbl_mb(k_ssji))
c
c Push intermediates into global
c
               tzz = tcgtime()
               if (oexch)
     $           call moints_push2idxK( nbf, mo1_lo, mo1_hi,
     $                                  mo2_lo, mo2_hi,
     $                                  ibflo, ibfhi, jbflo, jbfhi, 0, 
     $                                  dbl_mb(k_ssai), g_k2idx )
               if (ocoul)
     $           call moints_push2idxJ( nbf, mo1_lo, mo1_hi,
     $                                  mo2_lo, mo2_hi,
     $                                  ibflo, ibfhi, jbflo, jbfhi, 0, 
     $                                  dbl_mb(k_ssji), g_j2idx )
               tpush = tpush + tcgtime() - tzz
               t2qtr = t2qtr + tcgtime() - tt
             endif
#endif
           endif
         enddo
c
c Third and fourth qtr transformations can only be done
c when all 'jsh' contributions have been completed
c for some 'ish'. Must sync() and wait for all parallel
c tasks to finish.
c
         tyy = tcgtime()
         next = nxtask(-num_nodes,chunksiz)
         tt = tcgtime()
         twait = twait + tt - tyy
#ifndef INTS_ONLY
         if (oexch)
     $   call moints_trf34idx_K( nbf, mo1_lo, mo1_hi, mo2_lo, mo2_hi,
     $                           ibflo, ibfhi, 0, dbl_mb(k_mo),
     $                           g_k2idx, dbl_mb(k_ab1), dbl_mb(k_ab2),
     $                           dbl_mb(k_ssai), g_exch )
         if (ocoul)
     $   call moints_trf34idx_J( nbf, mo1_lo, mo1_hi, mo2_lo, mo2_hi,
     $                           ibflo, ibfhi, 0, dbl_mb(k_mo),
     $                           g_j2idx, dbl_mb(k_ab1), dbl_mb(k_ab2),
     $                           dbl_mb(k_ssji), g_coul )
         t34 = t34 + tcgtime() - tt
#endif
       enddo
       call ga_sync()
       t4sh = tcgtime() - t4sh
c
C       call moints_print_opermatrix(nmo1,nmo2,g_exch)
C       call moints_print_opermatrix(nmo1,nmo2,g_coul)
c
c Print statistics
c       
       if (oprintstats) then
         call ga_dgop(MOINTS_SCHWARZ_STAT,schw_done,1,'+')
         schw_ratio = (schw_done/(tri_shells*tri_shells))*100.d0
         if (ga_nodeid().eq.0) then
           write(6,986) schw_done,schw_ratio,chunksiz,
     $                  t1qtr,t2qtr,t34,t4sh,
     $                  tint,tpush,twait
 986       format(10x,'Shell-quartets done:',11x,f10.0,/,
     $            10x,'Shell-quartets percentage:',4x,f10.1,'%',//,
     $            10x,'Task chunksize:',19x,i7,/,
     $            10x,'1st quarter time:',14x,f10.2,/,
     $            10x,'2nd quarter time:',14x,f10.2,/,
     $            10x,'3rd and 4th quarter time:',6x,f10.2,/,
     $            10x,'Four-fold shell loop time:',5x,f10.2,/,
     $            10x,'Integral evaluation time:',6x,f10.2,/,
     $            10x,'Transposition time:',12x,f10.2,/
     $            10x,'Synchronization time:',10x,f10.2)
           call util_flush(6)
         endif
       endif


#ifdef DEBUG_PARALLEL
       call ga_sync()
       call brdcst_ivec( nptasks, taskstats )
       call brdcst_ivec( npcomm, commstats )
       if (ga_nodeid().eq.0) then
         write(6,966)
 966     format(/,'Number of tasks:')
         write(6,901) (taskstats(i),i=1,num_nodes)
         write(6,967)
 967     format(/,'Number of comms:')
         write(6,901) (commstats(i),i=1,num_nodes)
 901     format(12i6)
         write(6,*)
         write(6,*)
       endif
#endif
c
c Clean-up
c
      if (.not. ma_pop_stack(l_ab2))
     $     call errquit('moints: failed to pop', l_ab2)
      if (.not. ma_pop_stack(l_ab1))
     $     call errquit('moints: failed to pop', l_ab1)
      if ((ocoul).and.(.not. ma_pop_stack(l_ssji)))
     $     call errquit('moints: failed to pop', l_ssji)
      if ((oexch).and.(.not.ma_pop_stack(l_ssai)))
     $     call errquit('moints: failed to pop', l_ssai)
      if (.not. ma_pop_stack(l_ssni))
     $     call errquit('moints: failed to pop', l_ssni)
      if (.not. ma_pop_stack(l_sssi))
     $     call errquit('moints: failed to pop', l_sssi)
      if (.not. ma_pop_stack(l_mo))
     $     call errquit('moints: failed to pop', l_mo)
      if (.not. ma_pop_stack(l_iscr))
     $     call errquit('moints: failed to pop', l_iscr)
      if (.not. ma_pop_stack(l_erit))
     $     call errquit('moints: failed to pop', l_erit)
      if (.not. ma_pop_stack(l_eri))
     $     call errquit('moints: failed to pop', l_eri)
      if ((oexch).and.(.not.ga_destroy(g_k2idx)))
     $     call errquit('moints: cannot destroy global',g_k2idx)
      if ((ocoul).and.(.not.ga_destroy(g_j2idx)))
     $     call errquit('moints: cannot destroy global',g_j2idx)
       return
       end
