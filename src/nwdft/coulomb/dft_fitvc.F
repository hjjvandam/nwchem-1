      Subroutine dft_fitvc(rtdb, geom, AO_bas_han, CD_bas_han, CD_coef, 
     &     g_vc, Ecoul2, nbf_cd, g_2ceri,IOLGC,itol2e,incore,
     &     n_batch,n_bmax,iwhat,i3c_ERI,n3c_dbl,iwhat_max)
C     $Id: dft_fitvc.F,v 1.12 1997-02-26 19:46:57 d3h449 Exp $
      implicit none
      
c**** 
c**** nwchem handles
c**** 
      integer rtdb, geom, AO_bas_han, CD_bas_han
      integer g_vc    ! GA handle for V Coulomb [output]
      integer g_2ceri ! GA handle for repulsion int. [input]
      integer nbf_cd    ! no. CD functions [input]
      double precision Ecoul2 ! [output]
      integer itol2e ! bi-el int tolerance [input]
      logical incore ! true if 3c int are incore [input]
      integer n_batch        ! no. batches computed by this node [out]
      integer n_bmax  ! max no. batches
      integer iwhat(n_bmax) ! what batches have been computed [out]
      integer n3c_dbl
      double precision i3c_ERI(n3c_dbl)
c**** 
c      
c-->  Charge Density Expansion Coefficients
c      
      double precision CD_coef(nbf_cd)

      Logical IOLGC
      
#include "bas.fh"
#include "rtdb.fh"
#include "stdio.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "tcgmsg.fh"
#include "msgids.fh"
#include "schwarz.fh"
#include "util.fh"

#if defined(DFT_TIMER)
#include "timer.fh"
#endif
c     
c     Compute the fitted Coulomb potential. The fitting coefficients are
c     obtained by solving the normal equations for a standard linear least
c     squares problem.
c
      integer MXshbf_ao,nshells_ao,nshells_cd,MXshbf_cd
      integer me,nproc,i1,ishp,ishbf,lshbf,lmiss,ischw1,ischw2,
     ,     icount,Nao2,i,nERI,maxg,mscratch_2e3c,nscr,
     ,     n1,n2,ishc,ifirstc,ilastc,nshbfc,ishd,ifirstd,ilastd,
     ,     nshbfd,nfunz,ifirstp,ilastp,Nint,niter,next,nsh_blocks,
     ,     ntasks,nshbf_cd
      integer lcd_shell,icd_shell,lgvec,igvec,lsvec,isvec,
     ,     lsvec2,isvec2,iERI,lERI,lscr,iscr
      double precision THRESHOLD,CD_coef_max,shmax,
     ,     Vcoul_est,ERI_est,schw1,schw2
      integer iwhat_max, ishc_be, ishd_be, nlast
      integer nxtask
      logical dowork
      logical oprint_ioinfo
      integer ndone,ipoint,ipoint2
      external nxtask
c
#if defined(DFT_TIMER)
      call ga_sync
      call t_stat(10,-1)
      call dft_second(ts1)
#endif
      oprint_ioinfo = util_print('io info',print_debug)
      THRESHOLD=10.d0**(-itol2e)
c      
c     Determine the characteristics of the AO and CD Gaussian basis sets.
c      
      if( .not. bas_nbf_cn_max(AO_bas_han,MXshbf_ao) )then
        call errquit('Exiting in fitvcoul.',1)
      end if
      
      if( .not. bas_numcont(AO_bas_han,nshells_ao) )then
        call errquit('Exiting in fitvcoul.',2)
      end if
      
      if( .not. bas_numcont(CD_bas_han,nshells_cd) )then
        call errquit('Exiting in fitvcoul.',3)
      end if
      
      if( .not. bas_nbf_cn_max(CD_bas_han,MXshbf_cd) )then
        call errquit('Exiting in fitvcoul.',4)
      end if
      
      me=ga_nodeid()
      nproc  = ga_nnodes()
c      
c     Compute the fitted Vcoul.
c      
c     Allocate scratch space.
c      
      if(.not.MA_Push_Get(MT_Dbl,nshells_cd,'CD shell max',
     &  lcd_shell,icd_shell))
     &  call errquit('dft_fitvc: cannot allocate CD shell max',0)
c      
      if(.not.MA_Push_Get(MT_Dbl,MXshbf_cd,'gvec',lgvec,igvec))
     &  call errquit('dft_fitvc: cannot allocate gvec',0)
c      
c     Determine the largest magnitude of the CD expansion coefficients in
c     each shell.
c      
      CD_coef_max = 0.D0
      i1 = 1
      do 5 ishp = 1,nshells_cd
        if( .not. bas_cn2bfr(CD_bas_han,ishp,ishbf,lshbf) )then
          call errquit('Exiting in fitvcoul.',4)
        end if
        shmax = 0.D0
        do 2 i = ishbf,lshbf
          shmax = max(abs(CD_coef(i)), shmax)
    2   continue
        Dbl_MB((icd_shell-1)+ishp) = shmax
        CD_coef_max = max(shmax, CD_coef_max)
    5 continue
      if(IOLGC) then
        call gacrea(geom,CD_bas_han,
     &       nbf_cd,nbf_cd,'CD 2cERI',g_2ceri,'row')
        if (me.eq.0)then
           lmiss = 0
           call dft_invio('CD',g_2ceri,nbf_cd,'READ',lmiss)
           if(lmiss.ne.0)call errquit
     &     (' dft_fitvc; dft_invio - abnormal read of CD ',0)
        endif
        call ga_sync
        if(me.eq.0.and.oprint_ioinfo)then
          write(6,*)' g_2ceri = ', g_2ceri
          call ga_print(g_2ceri)
        endif
      endif
c      
c     Parallelize the loop over the products of AO shells.
c      
      ischw1 = 0
      ischw2 = 0
      
      icount = (nshells_ao + mod(nshells_ao,2))/(2*nproc)
c      
c     check for zero ... must be at least 1
c
      icount = max(icount,1)
      if(nproc.eq.1)icount = 1
c      
      Nao2 = MXshbf_ao**2
      if(.not.MA_Push_Get(MT_Dbl,Nao2,'isvec',lsvec,isvec))
     &  call errquit('dft_fitvc: cannot allocate isvec',0)
      if(.not.MA_Push_Get(MT_Dbl,Nao2,'isvec2',lsvec2,isvec2))
     &  call errquit('dft_fitvc: cannot allocate isvec2',0)
      nERI    = Nao2*MXshbf_cd
      if(.not.MA_Push_Get(MT_Dbl,nERI,'ERI',lERI,iERI))
     &  call errquit('dft_fitvc: cannot allocate ERI',0)
c
      call int_mem_2e3c(maxg, mscratch_2e3c)
      nscr    = mscratch_2e3c
      if(.not.MA_Push_Get(MT_Dbl,nscr,'scr',lscr,iscr))
     &  call errquit('dft_fitvc: cannot allocate scr',0)

      call ga_zero(g_vc)
c
      if(.not.incore)then
        iwhat_max = -1
        goto 25
      endif
c      call ga_sync
c      do n1 = 0, nproc
c        if(me.eq.n1)then
c          write(LuOut,*)' me, n_batch ', me, n_batch
c          call util_flush(LuOut)
c          call i_output(iwhat, 1, n_batch, 1, 1, n_batch, 1, 1)
c          call util_flush(LuOut)
c        endif
c        call ga_sync
c      enddo
c      call ga_sync
c
c     Exhaust in-core 3c 2e- buffers first.
c
      ndone=1
      ipoint=1
c     
#if defined(DFT_TIMER)
      call dft_second(ts2)
      subsect(1)='  Pre-fit '
      call tcllct(t_sub(1,1),ts2,ts1)
      call dft_second(ts1)
#endif
      call ga_sync
c     
      do 24 ishc = 1, nshells_ao
        if (.not. bas_cn2bfr( AO_bas_han, ishc, ifirstc, ilastc))
     &       call errquit('Exiting in fitvcoul.',3)
        nshbfc=ilastc-ifirstc+1
c        
        do 23 ishd = 1, ishc
c          
          dowork=iwhat(ndone).eq.((ishc*(ishc-1))/2 + ishd-1)
          if(dowork) then
c
c            write(LuOut,*)
c     &      'me,ishc,ishd,ndone,iwhat(ndone),ipoint', 
c     &       me,ishc,ishd,ndone,iwhat(ndone),ipoint
c            call util_flush(LuOut)
c
            if (.not. bas_cn2bfr( AO_bas_han, ishd, ifirstd, ilastd))
     &           call errquit('Exiting in fitvcoul.',4)
            nshbfd=ilastd-ifirstd+1
            Nao2 = nshbfc*nshbfd
c           
c           Screen integral blocks using the Schwarz inequality:  (p|cd) .le. (cd|cd)
c           
            ERI_est=schwarz_shell(ishc,ishd)

            if( CD_coef_max*ERI_est.gt.THRESHOLD )then
              ischw1 = ischw1 + nshells_cd
              
              call dfill(Nao2,0.D0,dbl_mb(isvec),1)
              nfunz=0
              ipoint2=ipoint
c                 
c             Multiply the matrix of 3-ctr ERIs by the CD expansion coefficients.
c                 
              call dgemv('N',Nao2,nbf_cd,1.D0,
     &             i3c_ERI(ipoint),Nao2,
     &             CD_coef,1,1.D0,Dbl_MB(isvec),1)
c           
c             Scatter the computed values of Vcoul.
c           
              call sca_lab_mat(AO_bas_han,ishc,ishd,
     &             nshbfc,nshbfd,g_vc,DBL_MB(isvec),dbl_mb(isvec2))
c
            endif
c            
            ndone=ndone+1
            if(ndone.gt.n_batch)then
c
c             Finished processing integrals incore start computing
c             them.
c
              goto 25
            else
              ipoint=ipoint+Nao2*nbf_cd
            endif
c
c            write(LuOut,*)' Done with: ishc, ishd, n_batch, ndone: ',
c     &                                 ishc, ishd, n_batch, ndone
c            call util_flush(LuOut)
c
          end if
c
   23   continue
   24 continue
   25 continue
c
c     Next, process any 3c 2e- integrals on disk (not implemented yet).
c
c
c     Finally, process any 3c 2e- integrals still needed in direct mode.
c
c     Find last ishc and ishd; add 1 to iwhat_max since starting at 0.
c
      nlast = iwhat_max + 1
c
c     Determine total number of shell pairs.
c
      ntasks = (nshells_ao*(nshells_ao+1))/2
c
      if (nlast.eq.ntasks)goto 241
c
      do n1 = 1, nshells_ao
        if ((n1*(n1-1))/2.gt.nlast)then
          ishc_be = n1 - 1
          goto 219
        endif
      enddo
      ishc_be = nshells_ao
  219 continue
      ishd_be = nlast - (ishc_be*(ishc_be-1))/2
c
      ishd_be = ishd_be + 1
      if(ishd_be.gt.ishc_be)then
        ishc_be = ishc_be + 1
        ishd_be = 1
      endif
c
c      call ga_sync
c
      n1 = nxtask(nproc,icount)
      n2 = 0
c
      do 240 ishc = ishc_be, nshells_ao
        if( .not. bas_cn2bfr( AO_bas_han,ishc,ifirstc,ilastc))
     &    call errquit('Exiting in fitvcoul.',3)
        nshbfc=ilastc-ifirstc+1
c        
        do 230 ishd = ishd_be, ishc
          dowork=n1.eq.n2
          if(dowork) then
c
c            write(LuOut,*)'me,ishc,ishd,n1,n2', me,ishc,ishd,n1,n2
c            call util_flush(LuOut)
c
            if (.not. bas_cn2bfr( AO_bas_han, ishd, ifirstd, ilastd))
     &         call errquit('Exiting in fitvcoul.',4)
            nshbfd=ilastd-ifirstd+1
            Nao2 = nshbfc*nshbfd
c           
c           Screen integral blocks using the Schwarz inequality:  (p|cd) .le. (cd|cd)
c           
            ERI_est=schwarz_shell(ishc,ishd)

            if( CD_coef_max*ERI_est.gt.THRESHOLD )then
              ischw1 = ischw1 + nshells_cd
c              
              call dfill(Nao2,0.D0,dbl_mb(isvec),1)
              nfunz=0
              do 220 ishp = 1,nshells_cd
c                
                if( .not.bas_cn2bfr(CD_bas_han, ishp, ifirstp, ilastp))
     &            call errquit('Exiting in fitvcoul.',5)
                nshbf_cd=ilastp-ifirstp+1
                Nint=nshbf_cd*Nao2
                Vcoul_est = Dbl_MB((icd_shell-1)+ishp)*ERI_est
                if( Vcoul_est.gt.THRESHOLD )then
c                  
                  ischw2 = ischw2 + 1
c                   
c                 Compute 3-ctr ERIs between a given pair of AO shells and a CD shell.
c                   
                  call int_2e3c(CD_bas_han,ishp,AO_bas_han,
     &                 ishc,ishd,nscr,Dbl_MB(iscr),Nint,Dbl_MB(iERI))
c                   
c                 Multiply the matrix of 3-ctr ERIs by the CD expansion coefficients.
c                   
                  call dgemv('N',Nao2,nshbf_cd,1.D0,
     &                 Dbl_MB(iERI),Nao2,
     &                 CD_coef(1+nfunz),1,1.D0,Dbl_MB(isvec),1)
                endif
c
                nfunz=nfunz+nshbf_cd
c               
  220         continue
c
c             Scatter the computed values of Vcoul.
c           
              call sca_lab_mat(AO_bas_han,ishc,ishd,
     &             nshbfc,nshbfd,g_vc,DBL_MB(isvec),dbl_mb(isvec2))
            endif
c            
c            write(*,*)' Done with: ishc,ishd; n1,n2 ',
c     &                             ishc,ishd, n1,n2
c            call util_flush(LuOut)
c
            n1 = nxtask(nproc,icount)
c
          endif
c          
          n2 = n2 + 1
c
  230   continue
c
c       Reset ishd_be to 1.
c
        ishd_be = 1
  240 continue
  241 continue
      
      if(.not.ma_pop_stack(lscr))
     &  call errquit('dft_fitvc: cannot pop stack',0)
      if(.not.ma_pop_stack(lERI))
     &  call errquit('dft_fitvc: cannot pop stack',0)
      if(.not.ma_pop_stack(lsvec2))
     &  call errquit('dft_fitvc: cannot pop stack',0)
      if(.not.ma_pop_stack(lsvec))
     &  call errquit('dft_fitvc: cannot pop stack',0)
c
#if defined(DFT_TIMER)
      call dft_second(ts2)
      subsect(2)='  Vcoul   '
      call tcllct(t_sub(1,2),ts2,ts1)
      call dft_second(ts1)
#endif
c
      n1 = nxtask(-nproc,icount)
c      
      if(.not.ma_pop_stack(lgvec))
     &  call errquit('dft_fitvc: cannot pop stack',0)
      if(.not.ma_pop_stack(lcd_shell))
     &  call errquit('dft_fitvc: cannot pop stack',0)
c      
c     Compute the Coulombic self-energy of the fitted charge density.
c      
c     Obtain the matrix of 2-ctr ERIs.
c      
      if(.not.MA_Push_Get(MT_Dbl,nbf_cd,'scr',lscr,iscr))
     &  call errquit('dft_fitvc: cannot allocate scr',0)
      Ecoul2=0.D0
      next=nxtval(nproc)+1
      do i=1,nbf_cd
        if(i.eq.next) then
          next=nxtval(nproc)+1
          call get_col(g_2ceri,nbf_cd,i,DBL_MB(iscr))
          Ecoul2 = Ecoul2+ddot(
     *         nbf_cd,CD_coef,1,Dbl_MB(iscr),1)*CD_coef(i)
        endif
      enddo
      
      next=nxtval(-nproc)
      
      Ecoul2=Ecoul2*0.5D0
      if(IOLGC) call gadest(g_2ceri)
      call ga_dgop(Msg_Ecoul2,Ecoul2,1,'+')
      if(.not.ma_pop_stack(lscr))
     &  call errquit('dft_fitvc: cannot pop stack',0)
c      
#if defined(DFT_TIMER)
      call dft_second(ts2)
      subsect(3)='  Ecoul2  '
      call tcllct(t_sub(1,3),ts2,ts1)
#endif
c      
#if defined(DFT_TIMER)
c      
      call ga_igop(Msg_schw2,ischw1,1,'+')
      call ga_igop(Msg_schw2,ischw2,1,'+')
      nsh_blocks = nshells_cd*((nshells_ao*(nshells_ao+1))/2)
      schw1 = (dble(nsh_blocks - ischw1)/dble(nsh_blocks))*100
      schw2 = (dble(nsh_blocks - ischw2)/dble(nsh_blocks))*100
      ltime = 7
      if( me.eq.0 )then
        niter  = (nshells_ao*(nshells_ao+1))/2
        ntasks = niter/icount
        write(ltime,*)
        write(ltime,9996) '      Analysis of FITVCOUL'
        write(ltime,*)
        write(ltime,9995) ' number of nodes:  ',nproc
        write(ltime,9995) ' number of tasks:  ',ntasks
        write(ltime,9995) ' chunk size     :  ',icount
        write(ltime,*)
        write(ltime,9996) 'Schwarz Screening - Density*(p|cd)'
        write(ltime,*)
        write(ltime,9997) 'Threshold :  ',THRESHOLD
        write(ltime,9998) '% Screened:  ',schw1,schw2
        write(ltime,*)
      end if
      subname=' Fitvcoul '
      call t_stat(3,1)
c      
 9995 format(10x,a,i10)
 9996 format(10x,a)
 9997 format(2x,a,e12.4)
 9998 format(2x,a,2f6.2)
c      
#endif
      return
      end
