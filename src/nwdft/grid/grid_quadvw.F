      Subroutine grid_quadvw(rtdb, 
     ,     qsh,nq_list, aqbuf,
     ,     rij, iqat,
     ,     g_dens, ncoef_max, natoms, 
     &                       rho_int, nqtot, 
     &                       iniz, ifin, rho, delrho, 
     &                       hess, qwght, qxyz, xyz,
     &                       expo, ccoef, Bmat, Fmat, 
     &                       Pmat, rq,  rdens_atom, 
     &                       cntobfr, cetobfr, 
     ,     ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,     Ex, Ec, amat,cmat,g_vxc)
c
c$Id: grid_quadvw.F,v 1.2 2000-03-28 19:52:37 edo Exp $
c
      implicit none
#include "cgridfile.fh"
#include "stdio.fh"
#include "cdft.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "util.fh"
#include "rtdb.fh"
#include "sym.fh"
#include "grid_quad.fh"
      integer qsh(3,*)! [in]
      integer nq_list ! [in] generated by grid_list, unused in grid_test_mem
      double precision aqbuf(4,*) ! [scr]
      double precision rij ! [scr] for ssw
      integer iqat(*) ! [scr]
      double precision rad
      integer nq_tot
      integer ntot_cube,npts_per_ang
      logical oreadfile, owritefile
      integer filesize, memsize
      character*255 gridfilename
      logical xc_chkgrad
      external xc_chkgrad
      logical grid_file_open
      external grid_file_open
      logical grid_file_close
      external grid_file_close
      logical grid_test_mem,trunc_neigh,cube_done
      external grid_test_mem
      integer nxtask,n1,n2,icount
      external nxtask
      integer me,nproc
      integer nqtotc,ncubenz,iaia,i_a,
     ,     nx,ny,nz,iii,
     ,     iang,ictr,nq,nqsh_at,nq_cube,
     ,     iqsh,irsh,ncu,nxyz,fnxyz,
     ,     nsubb_curr
      integer nq_out,nwrbuf
      integer iang_done
      integer nops ! [out]
c      integer mxang ! [in] max no. angular pts .eq.nqmax
      integer k_symops,l_symops ! [out]  symops handles
      integer k_gridscr,l_gridscr ! [out]  grid handles
      integer k_iscr,l_iscr ! [out] iscr handles
      integer nq_left


      double precision symfact,rmax,rmin,rad_write,rad_sh
C      
      nproc=ga_nnodes()
      me=ga_nodeid()
c
c     see if any Gradient Corrected Functional is not null
c
      grad=.true.
      grad=xc_chkgrad(xfac,cfac)
      npts_per_ang=nqmax
      nsubb_curr=0
c
c     temp set gridfilename to gridpts
c
c     Grid_pts caching/file information (from scf_get_info)
c
      if (.not. rtdb_get(rtdb, 'grid:filesize',
     $     MT_INT, 1, filesize)) filesize = 0
!      write(0,*) ' filesize ',filesize
      if (.not. rtdb_get(rtdb, 'grid:memsize',
     $     MT_INT, 1, memsize)) memsize = 0
!      write(0,*) ' memsize ',memsize
c
c     The opening routine will put the .pid on the grid_pts filename
c     (hence even tho' parallel file, open as sequential)
c
      if (.not. rtdb_cget(rtdb, 'grid:filename', 1, gridfilename)) 
     $   call util_file_name('gridpts',.true.,.false.,gridfilename)
      if (.not. rtdb_cput(rtdb, 'grid:filename', 1, gridfilename)) 
     $   call errquit('grid_tasks: trouble putting gridfilename', 0)
c
      oreadfile = .false.
      owritefile= .false.
c
      if (filesize.gt.0 .or. memsize.gt.0) then
         if (.not. grid_file_open(gridfilename, memsize, filesize))
     $        call errquit('grid_tasks: opening gridpts?', 0)
      endif
c
      owritefile= grid_test_mem (rtdb, geom, nq_list)
c
c
c     get partitioning function
c
      if(lssw) do_interp = xc_interp(whichssw)

C
      ntot_cube=0
c
      if (.not.rtdb_get(rtdb, 'dft:trunc_neigh', mt_log, 1,
     &   trunc_neigh))trunc_neigh=.true.
      call dft_tstamp(' Before buckinit.')

      call grid_buckinit()
cedo rchi business off
cedo      call grid_rchi0
      nqtotc=0
      ncubenz=0
      call dft_tstamp(' Before atom loop')
c
c     parallel loop init
c
      icount = 1
      n1 = 0
      n2 = nxtask(nproc,icount)

      if(leb.and.oskel)call grid_sympts0(geom,nops,k_symops,l_symops,
     ,     k_gridscr,l_gridscr,k_iscr,l_iscr,nqmax)
      do 111 i_a =1,ncenters
         iang_done=-1
         nwrbuf=1
         if(oskel) then
            if (.not.sym_atom(geom, i_a, symfact))  goto 111
         endif
c
c     get shells centers on i_a
c
         nqsh_at=0
         do iqsh=1,nqshells
            if(qsh(2,iqsh).eq.i_a) then
               nqsh_at=nqsh_at+1
               iqat(nqsh_at)=iqsh
            endif
         enddo
c
c     get no of segment
c
         iaia=iatype(i_a)
         rad=dble(rad_cutoff(1,iaia))
         nxyz=nint(rad/lcube(iaia))*2d0
c
c     loop over cubes centers on i_a
c
         do ncu=1,ncubes_type(iatype(i_a))
            nq_out=0
            if (n1.eq.n2 )then
               fnxyz=int_mb(k_nxyz+(iatype(i_a)-1)*ncubesmx+ncu-1)
               call grid_n2nxyz(nxyz,fnxyz,nx,ny,nz)
               call grid_rmaxmin(nx,ny,nz,rmax,rmin,lcube(iaia),nxyz)
               rad_write=rmax
               nq_cube=0
               cube_done=.false.
               do 100 iii = 1, nqsh_at
                  iqsh=iqat(iii)
                  irsh = qsh(1,iqsh)         
                  rad_sh=rpts(irsh,iatype(i_a))
c     
c     check if radius between rmin and rmax
c     
                  if(rad_sh.ge.rmin.and.rad_sh.le.rmax) then
                     ictr = qsh(2,iqsh)
                     iang = qsh(3,iqsh)
                     nq = npts_per_ang
c     
c     Generate all angular quadrature points for this radial shell
c     and keep only those inside cube
c     
                     if(leb.and.oskel) then
                        call grid_sympts(
     .                       rad_sh,xyz(1,ictr), ictr, 
     .                       irsh, iang, iang_done,nq_left,
     ,                       aqbuf, nq, nx,ny,nz,nxyz,
     ,                       dbl_mb(k_gridscr),nops,dbl_mb(k_symops),
     .                       int_mb(k_iscr))
                     else
                        call grid_qpts(rad_sh,xyz(1,ictr), ictr, 
     ,                       irsh, iang, 
     ,                       aqbuf, nq,  nx,ny,nz,nxyz)
                     endif
c     
c     modify the weight to include the spatial weight (and symmetry factor)
c     
                     if(ncenters.gt.1) then
                        call grid_setspac(rtdb, xyz, aqbuf,
     ,                       rij, 
     &                       rq, bp, ictr, nq,
     ,                       expo, rad_sh, trunc_neigh)
                     endif
                     if(nq.ne.0) then
                        if(oskel) call dscal(
     /                       nq, symfact, aqbuf(4,1), 4)
c
c     copy to buffer for XC stuff and compute if needed
c
                        nqtotc=nqtotc+nq
                        nq_cube=nq_cube+nq
                        call grid_quadvc(cube_done,nwrbuf,
     ,                       aqbuf,nq,nq_out,
     ,                       ntot_cube,ictr,qxyz, qwght, 
     ,                       rad_write,grad,
     .                       rtdb, g_dens, ncoef_max, natoms, 
     &                       rho_int, nqtot, 
     &                       iniz, ifin, rho, delrho, 
     &                       hess,  xyz,
     &                       expo, ccoef, Bmat, Fmat, 
     &                       Pmat, rq, rdens_atom, 
     &                       cntobfr, cetobfr, 
     ,                       ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,                       Ex, Ec, amat,cmat,g_vxc)
c     
c     now pack this aqbuf into the write buffer 
c     (write and update task counter as needed)
c     
                        call grid_file_write(nq, ictr, 
     ,                       rad_write, aqbuf,  ncu)
                        
                     endif
                  endif
 100           continue ! end loop over angular shells
               if(nq_cube.ne.0) then
                  cube_done=.true.
                  call grid_quadvc(cube_done,nwrbuf,
     ,                 aqbuf,nq,nq_out,
     ,                 ntot_cube,ictr,qxyz, qwght, 
     ,                 rad_write,grad,
     .                 rtdb, g_dens, ncoef_max, natoms, 
     &                 rho_int, nqtot, 
     &                 iniz, ifin, rho, delrho, 
     &                 hess,  xyz,
     &                 expo, ccoef, Bmat, Fmat, 
     &                 Pmat, rq, rdens_atom, 
     &                 cntobfr, cetobfr, 
     ,                 ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,                 Ex, Ec, amat,cmat,g_vxc)
                  ncubenz=ncubenz+1
               endif
               n1 = n1 + 1
               n2 = nxtask(nproc,icount)
            else
               n1 = n1 + 1
            endif
         enddo                  ! end loop over cubes
 111  continue                  ! end loop over atoms
      if(leb.and.oskel)call grid_sympts2(l_symops,l_gridscr,l_iscr)
      write(LuOut,*) ' me ',me,
     ,     ' NQTOTC NQ/cube',nqtotc,nqtotc/ncubenz
      call grid_buckend()
!      if(.true.) call errquit(' out ',1948)
c
c     Write last buffer of grid pts and close file     
c
      nq = 1
      n_tot_tasks = 0 ! sets nctr to 0; writes last buf and returns #tasks
      call grid_file_write(nq, n_tot_tasks, rad, aqbuf,0)
      n1 = nxtask(-nproc,icount)
      call dft_tstamp(' done atom loop')
      grid_written=.true.
c
      call ga_sync
      return
      end
