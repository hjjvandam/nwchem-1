      Subroutine grid_quadvw(rtdb, 
     ,     qsh,nq_list, aqbuf,
     ,     rij, iqat,
     ,     g_dens, ncoef_max, natoms, 
     &                       rho_int, nqtot, 
     &                       iniz, ifin, rho, delrho, 
     &                       hess, qwght, qxyz, xyz,iscr,nscr,
     &                       expo, ccoef, Bmat, Fmat, 
     &                       Pmat, rq,  rdens_atom, cetobfr, 
     ,     ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,     Ex, Ec, amat,cmat,g_vxc,
     ,     Amat2, Cmat2,
     ,     nmat, do_scf, do_cpks_l, do_cpks_r,tmat)
c
c$Id: grid_quadvw.F,v 1.14 2000-06-08 02:06:28 edo Exp $
c
      implicit none
#include "cgridfile.fh"
#include "stdio.fh"
#include "cdft.fh"
#include "mafdecls.fh"
#include "global.fh"
#include "util.fh"
#include "rtdb.fh"
#include "sym.fh"
#include "grid_quad.fh"
#include "grid_cube.fh"
      integer rtdb ![in]
      integer qsh(3,*)! [in]
      integer nq_list ! [in] generated by grid_list, unused in grid_test_mem
      double precision aqbuf(4,*) ! [scr]
      double precision rij ! [scr] for ssw
      integer iqat(*) ! [scr]
      double precision rad
      integer ntot_cube,npts_per_ang
      logical oreadfile, owritefile
      integer filesize, memsize
      character*255 gridfilename
      logical xc_chkgrad
      external xc_chkgrad
      logical grid_file_open,grid_file_close
      external grid_file_open,grid_file_close
      logical grid_test_mem,trunc_neigh,cube_done
      external grid_test_mem
      integer nxtask,n1,n2,icount
      external nxtask
      integer me,nproc
      integer nqtotc,ncubenz,iaia,i_a,
     ,    iii,ictr,nq,nqsh_at,nq_cube,
     ,     iqsh,irsh,ncu,nxyz,fnxyz,nsubb_curr
      integer nq_out,nwrbuf
      integer iang_done
      integer nops ! [out]
      integer k_symops,l_symops ! [out]  symops handles
      integer k_gridscr,l_gridscr ! [out]  grid handles
      integer k_iscr,l_iscr ! [out] iscr handles
      logical dosympts
      integer grid_nxyz,grid_nsub4
      external grid_nxyz,grid_nsub4
      double precision symfact,rmax,rmin,rad_write,rad_sh
      logical oprint
C      
      nproc=ga_nnodes()
      me=ga_nodeid()
      oprint = util_print('quadrature', print_high)
     
c
c     see if any Gradient Corrected Functional is not null
c
      grad=xc_chkgrad(xfac,cfac)
      npts_per_ang=nqmax
      nsubb_curr=0
c
c     temp set gridfilename to gridpts
c     Grid_pts caching/file information (from scf_get_info)
c
      if (.not. rtdb_get(rtdb, 'grid:filesize',
     $     MT_INT, 1, filesize)) filesize = 0
      if (.not. rtdb_get(rtdb, 'grid:memsize',
     $     MT_INT, 1, memsize)) memsize = 0
c
c     The opening routine will put the .pid on the grid_pts filename
c     (hence even tho' parallel file, open as sequential)
c
      if (.not. rtdb_cget(rtdb, 'grid:filename', 1, gridfilename)) 
     $   call util_file_name('gridpts',.true.,.false.,gridfilename)
      if (.not. rtdb_cput(rtdb, 'grid:filename', 1, gridfilename)) 
     $   call errquit('grid_tasks: trouble putting gridfilename', 0)
c
      oreadfile = .false.
      owritefile= .false.
c
      if (filesize.gt.0 .or. memsize.gt.0) then
         if (.not. grid_file_open(gridfilename, memsize, filesize))
     $        call errquit('grid_tasks: opening gridpts?', 0)
      endif
c
      owritefile= grid_test_mem (rtdb, nq_list)
c
c     get partitioning function
c

      ntot_cube=0
c
      if (.not.rtdb_get(rtdb, 'dft:trunc_neigh', mt_log, 1,
     &   trunc_neigh))trunc_neigh=.true.
      call grid_buckinit(rtdb)
      nqtotc=0
      ncubenz=0
      dosympts=leb.and.oskel
c
c     parallel loop init
c
      icount = 1
      n1 = 0
      n2 = nxtask(nproc,icount)

      if(dosympts) call grid_sympts0(geom,nops,k_symops,l_symops,
     ,     k_gridscr,l_gridscr,k_iscr,l_iscr,nqmax)
      do 111 i_a =1,ncenters
         iang_done=-1
         nwrbuf=1
         if(oskel) then
            if (.not.sym_atom(geom, i_a, symfact))  goto 111
         endif
c
c     get shells centers on i_a
c
         nqsh_at=0
         do iqsh=1,nqshells
            if(qsh(2,iqsh).eq.i_a) then
               nqsh_at=nqsh_at+1
               iqat(nqsh_at)=iqsh
            endif
         enddo
c
c     get no of segment
c
         iaia=iatype(i_a)
         rad=dble(rad_cutoff(1,iaia))
         nxyz=grid_nxyz(rad,lcube(iaia))
         if(sub4) then
            nsub4=grid_nsub4(nxyz)
            shft=nsub4**3
         endif
c
c     loop over cubes centers on i_a
c
         do ncu=1,ncubes_type(iatype(i_a))
            nq_out=0
            if (n1.eq.n2 )then
               fnxyz=int_mb(k_nxyz+(iatype(i_a)-1)*ncubesmx+ncu-1)
               call grid_rmaxmin(fnxyz,rmax,rmin,lcube(iaia),nxyz)
               rad_write=rmax
               nq_cube=0
               do 100 iii = 1, nqsh_at
                  iqsh=iqat(iii)
                  irsh = qsh(1,iqsh)         
                  rad_sh=rpts(irsh,iatype(i_a))
c     
c     check if radius between rmin and rmax
c     
                  if(rad_sh.ge.rmin.and.rad_sh.le.rmax) then
                     call grid_quadvw1(ncu,nq_out,iqsh,irsh,rad_sh,
     ,                    dosympts,
     ,                    fnxyz,nxyz,nops,trunc_neigh,grad,
     ,                    nq_cube,nqtotc,rad_write,symfact,
     ,                    iang_done,nwrbuf,
     ,                    dbl_mb(k_gridscr),
     .                    int_mb(k_iscr),dbl_mb(k_symops),
     ,                    qsh, aqbuf,rij, 
     ,                    g_dens, ncoef_max, natoms, 
     &                    rho_int, nqtot, 
     &                    iniz, ifin, rho, delrho, 
     &                    hess, qwght, qxyz, xyz,iscr,nscr,
     &                    expo, ccoef, Bmat, Fmat, 
     &                    Pmat, rq,  rdens_atom, cetobfr, 
     ,                    ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,                    Ex, Ec, amat,cmat,g_vxc,
     ,                    Amat2, Cmat2,
     ,                    nmat, do_scf, do_cpks_l, do_cpks_r,tmat)

                  endif
 100           continue ! end loop over angular shells
               if(nq_cube.ne.0) then
                  cube_done=.true.
                  ictr = qsh(2,iqsh)
                   call grid_quadvc(cube_done,nwrbuf,
     ,                 aqbuf,nq,nq_out,
     ,                 ntot_cube,ictr,qxyz, qwght, 
     ,                 rad_write,grad,
     .                 g_dens, ncoef_max, natoms, 
     &                 rho_int, nqtot, 
     &                 iniz, ifin, rho, delrho, 
     &                 hess,  xyz,iscr,nscr,
     &                 expo, ccoef, Bmat, Fmat, 
     &                 Pmat, rq, rdens_atom, cetobfr, 
     ,                 ibf_ao,bp,rscr,rchi_atom,rdelchi_atom,
     ,                 Ex, Ec, amat,cmat,g_vxc, amat2,cmat2,
     ,     nmat, do_scf, do_cpks_l, do_cpks_r,tmat)
                  ncubenz=ncubenz+1
               endif
               n1 = n1 + 1
               n2 = nxtask(nproc,icount)
            else
               n1 = n1 + 1
            endif
         enddo                  ! end loop over cubes
 111  continue                  ! end loop over atoms
      if(ncubenz.eq.0) call errquit(
     .     ' grid_quadvw: no cube detected - nqtot ',nqtotc)
      if(oprint) write(LuOut,16) ' me ',me,
     ,     ' NQTOTC NQ/cube',nqtotc,nqtotc/ncubenz
      if(dosympts)call grid_sympts2(l_symops,l_gridscr)
 16   format(A,I3,A,2I8)
      call grid_buckend()
c
c     Write last buffer of grid pts and close file     
c
      nq = 1
      n_tot_tasks = 0 ! sets nctr to 0; writes last buf and returns #tasks
      call grid_file_write(nq, n_tot_tasks, rad, aqbuf,0)
      n1 = nxtask(-nproc,icount)
      grid_written=.true.
c
      call ga_sync
      return
      end
