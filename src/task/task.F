      subroutine task(rtdb)
      implicit none
#include "rtdb.fh"
#include "inp.fh"
#include "util.fh"
#include "global.fh"
#include "mafdecls.fh"
      integer rtdb              ! [input] data base handle
c
c     Called by ALL processes.  task_input has read the
c     task directive and put stuff into the database.  Get the
c     data out and invoke the desired action.
c
c     If the operation is in the list of those supported by generic 
c     routines (currently energy, gradient, hessian, optimize), then 
c     the generic routine is called.  Otherwise, a match is attemped 
c     for a specialized routine.  If no operation is specified 
c     and no specialized routine located, then it is assumed that
c     a generic energy calculation is required.
c
c     This needs extending to accomodate QM/MM and other mixed methods
c     by having both MM and QM pieces specified (e.g., task md dft).
c
      character*20 theory, operation
      logical status, ignore
      character*80 errmsg
c
      logical  rjhtest, raktest, atwtest, task_check_sum, mdmain, cphf
      logical  nwargos, property, gapss, task_shell, moints_full
      logical  task_energy, task_gradient, task_optimize, task_freq
c
      external rjhtest, raktest, atwtest, task_check_sum, mdmain, cphf
      external nwargos, property, gapss, task_shell, moints_full
      external task_energy, task_gradient, task_optimize, task_freq
c      
      if (.not. rtdb_cget(rtdb, 'task:operation', 1, operation))
     $     operation = ' '
      if (.not. rtdb_cget(rtdb, 'task:theory', 1, theory)) then
         if (operation .ne. 'nwargos')
     $     call errquit('task: no task input for theory?', 0)
         theory = ' '
      endif
      if (.not. rtdb_get(rtdb, 'task:ignore', mt_log, 1, ignore))
     $     ignore = .false.
c
      if (operation .eq. ' ') then ! Look for specialized routine
         if (inp_compare(.false.,'rjhtest', theory)) then
            status = rjhtest(rtdb)
         else if (inp_compare(.false.,'raktest', theory)) then
            status = raktest(rtdb)
         else if (inp_compare(.false.,'atwtest', theory)) then
            status = atwtest(rtdb)
         else if (inp_compare(.false.,'rtdbprint', theory)) then
            status = rtdb_print(rtdb,.true.)
         else if (inp_compare(.false.,'checksum', theory)) then
            status = task_check_sum(rtdb)
         else if (inp_compare(.false.,'nwargos', theory)) then
            status = nwargos(rtdb)
         else if (inp_compare(.false.,'md', theory)) then
            status = nwargos(rtdb)
         else if (inp_compare(.false.,'md_ideaz', theory)) then
            status = mdmain(rtdb)
         else if (inp_compare(.false.,'cphf', theory)) then
            status = cphf(rtdb)
         else if (inp_compare(.false.,'property', theory)) then
            status = property(rtdb)
         else if (inp_compare(.false.,'gapss', theory)) then
            status = gapss(rtdb) ! This could/should be in task_energy
         else if (inp_compare(.false.,'shell', theory)) then
            status = task_shell(rtdb)
         else if (inp_compare(.false.,'moints', theory)) then
            status = moints_full(rtdb)
         else
            operation = 'energy' ! No matching specialized operation
            goto 100            !  execute the default generic operation
         endif
         if ((ga_nodeid().eq.0) .and. (.not. status)) then
            errmsg = ' '
            write(errmsg,'(a,'' failed '')')theory(1:inp_strlen(theory))
            if (ga_nodeid().eq.0) then
               if (ignore) then
                  write(6,*)' !! warning: ',errmsg(1:inp_strlen(errmsg))
                  call util_flush(6)
               else
                  call errquit(errmsg, 0)
               endif
            endif
         endif
         call ga_sync()
         return
      endif
c
 100  if (inp_compare(.false., 'energy', operation)) then
         status = task_energy(rtdb)
      else if (inp_compare(.false., 'gradient', operation)) then
         status = task_gradient(rtdb)
      else if (inp_compare(.false., 'optimize', operation)) then
         status = task_optimize(rtdb)
      else if (inp_compare(.false., 'freq', operation)) then
         status = task_freq(rtdb)
      else if (inp_compare(.false.,'dynamics', operation)) then
         status = nwargos(rtdb)
      else
         call errquit('task: unknown generic operation',0)
      endif
      if ((ga_nodeid().eq.0) .and. (.not. status)) then
         errmsg = ' '
         write(errmsg,'(a,'' '',a,'' failed '')')
     $      theory(1:inp_strlen(theory)), 
     $      operation(1:inp_strlen(operation))
         if (ga_nodeid().eq.0) then
            if (ignore) then
               write(6,*)' !! warning: ',errmsg(1:inp_strlen(errmsg))
               call util_flush(6)
            else
               call errquit(errmsg, 0)
            endif
         endif
      endif
c
      end
      logical function task_shell(rtdb)
      implicit none
#include "rtdb.fh"
#include "mafdecls.fh"
#include "global.fh"
      integer rtdb
c
      integer i
      character*1023 command
      integer range(3)
      integer util_system
      external util_system
c
      if (.not.rtdb_get(rtdb,'task:shell range',mt_int,3,range)) then
         range(1) = 0
         range(2) = 0
         range(3) = 1
      endif
      if (.not. rtdb_cget(rtdb,'task:shell command',1,command))
     $     call errquit('task shell: shell command missing',0)
c
      task_shell = .true.
c
      do i = range(1), range(2), range(3)
         if (ga_nodeid() .eq. i)
     $        task_shell = util_system(command) .eq. 0
      enddo
c
      end

