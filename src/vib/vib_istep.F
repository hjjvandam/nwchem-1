      subroutine vib_istep(rtdb,nat3,natom,
     &    eigenvecs,eigenvals,coords,
     &    steps,stepsave,master)
*
* $Id: vib_istep.F,v 1.1 1999-06-22 05:57:43 d3e129 Exp $
* routine to compute the direction vector, magnitudes, updated
* geometries for all negative eigenvalues in the current spectrum.
* only called during projected frequency analysis.
*
      implicit none
#include "stdio.fh"
#include "geom.fh"
      double precision ddot
      external ddot
*
      integer rtdb    ! [input] rtdb handle
      integer natom   ! [input] number of atoms
      integer nat3    ! [input] 3*number of atoms
      double precision eigenvecs(nat3,nat3) ! [input](xyz&atom,mode)
      double precision eigenvals(nat3)      ! [input] (mode)
      double precision master(3,natom)    ! [scratch] original coordintates
      double precision coords(3,natom)    ! [scratch] coords after step
      double precision steps(3,natom)     ! [scratch] step generated by vector and scaled
      double precision stepsave(3,natom)  ! [scratch] step generated by vector 
c
      integer imode,ivec,iatom,ixyz
      integer nzero
      integer geom
      integer ip
      double precision scale
      double precision xyz(3),charge
      double precision length_of_step, maxstep
      double precision percents(4)
      character*16 tag
      character*10 units
      intrinsic sqrt
c
      double precision step_limit
      parameter (step_limit = 0.2d00)
      double precision thresh
      parameter (thresh=1.0d-2)
c::-statement function
      logical is_it_close_to  
      double precision value,test
      intrinsic abs
*---          is value close to test?
      is_it_close_to(value,test) = (abs(value-test).lt.thresh)
c
      if (.not.geom_create(geom,'geometry')) call errquit
     &    ('vib_istep: geom create failed',911)
      if (.not.geom_rtdb_load(rtdb,geom,'geometry')) call errquit
     &    ('vib_istep: geom_rtdb_load failed',911)
      if (.not.geom_cart_coords_get(geom,master)) call errquit
     &    ('vib_istep: geom_get_cart_coords failed',911)
      if (.not.geom_get_user_scale(geom,scale)) call errquit
     &    ('vib_istep: geom_get_user_scale failed',911)
      if (.not.geom_get_user_units(geom,units)) call errquit
     &    ('vib_istep: geom_get_user_units failed',911)
c
      percents(1) = 100.0d00
      percents(2) =  50.0d00
      percents(3) =   0.0d00
      percents(4) =   0.0d00
      nzero = 0

      do imode = 1,nat3
        if (is_it_close_to(eigenvals(imode),0.0d00)) then
          nzero = nzero + 1
          if (nzero.ge.3) goto 99999 ! found all negative eigenvalues :)
*                                    ! should always find 3 translational zeros
        else
          write(luout,10000)imode,eigenvals(imode)
          call dfill(nat3,0.0d00,steps,1)
          call dfill(nat3,0.0d00,stepsave,1)
* compute raw step
          ivec = 0
          maxstep = -0.1d00
          do iatom = 1, natom
            do ixyz = 1,3
              ivec = ivec+1
              stepsave(ixyz,iatom) =
     &            -1.0d00*eigenvecs(ivec,imode)
              maxstep = max(maxstep,abs(stepsave(ixyz,iatom)))
            enddo
          enddo
* determine percentages based on maximum raw displacement and limit
          percents(3) =  (step_limit/maxstep)*100.0d00
          percents(4) =  (step_limit/2.0d00/maxstep)*100.0d00
* print raw step
          call dcopy(nat3,stepsave,1,steps,1)
          call dscal(nat3,(1.0d00/scale),steps,1)
          length_of_step = sqrt(ddot(nat3,steps,1,steps,1))
          write(luout,10001)length_of_step,units
          do iatom=1,natom
            if (.not.geom_cent_get(geom,iatom,tag,xyz,charge))
     &          call errquit
     &          ('vib_istep: geom_cent_get failed',911)
            write(luout,10002)iatom,tag,charge,
     &          (steps(ixyz,iatom),ixyz=1,3)
          enddo
          write(luout,'(/)')
* compute and print all scaled steps
          do ip = 1,4
            call dcopy(nat3,master,1,coords,1)
            call dcopy(nat3,stepsave,1,steps,1)
            call dscal(nat3,(percents(ip)/100.0d00),steps,1)
            length_of_step = sqrt(ddot(nat3,steps,1,steps,1))/
     &          scale
            call daxpy(nat3,1.0d00,steps,1,coords,1)
            if (.not.geom_cart_coords_set(geom,coords)) call errquit
     &          ('vib_istep: geom_cart_coords_set failed',911)
            write(luout,10003)percents(ip),imode,length_of_step,units
            do iatom=1,natom
              if (.not.geom_cent_get(geom,iatom,tag,xyz,charge))
     &            call errquit
     &            ('vib_istep: geom_cent_get failed',911)
              do ixyz = 1,3
                xyz(ixyz)=xyz(ixyz)/scale ! convert to user coordinates
              enddo
              write(luout,10002)iatom,tag,charge,(xyz(ixyz),ixyz=1,3)
            enddo
            write(luout,'(/)')
          enddo
        endif
      enddo
99999 continue
c
      if (.not.geom_destroy(geom)) call errquit
     &    ('vib_istep: geom_destroy failed',911)
c
10000 format(/,/,/,1x,79('='),/,6x,'Negative Nuclear Hessian Mode',
     &      i5,2x,'Eigenvalue = ',f9.2,' cm**(-1)',/,1x,79('-'))
10001 format(2x,' Raw step length:',f7.3,1x,a10,';',
     &    2x, 'The Raw step for this mode is:')
10002 format(' ',i4,' ',a16,' ',f10.4,3f15.8)
10003 format(2x,'Geometry after ',f5.1,
     &    '% step for mode ',
     &    i2,'; Step length =',f7.3,1x,a10)
      end
