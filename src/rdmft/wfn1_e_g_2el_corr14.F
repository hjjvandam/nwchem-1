c-----------------------------------------------------------------------
c
!> \ingroup wfn1
!> @{
!>
!> \file wfn1_e_g_2el_corr14.F
!> The correlation energy based on $\mathrm{H}_2$.
!>
!> @}
!>
!> \ingroup wfn1_priv
!> @{
!>
!> \brief Evaluate the electron correlation energy
!>
!> This subroutine evaluates the correlation energy based on the
!> Full-CI energy for $\matrm{H}_2$ in a minimal basis set.
!> The correlation energy is defined as the difference between the
!> Full-CI energy and the regular uncorrelated energy. Hence, adding
!> the correlation energy to the uncorrelated energy should produce
!> the Full-CI energy. Note again, this energy expression is only
!> exact for 2-electron systems in a 2 spatial orbital basis set.
!> For other systems the expression will be an approximation.
!>
!> Note that because this energy expression is based on a closed
!> shell 2-electron system the correlation energy does not include
!> any exchange terms. It only includes correlations between 
!> $\alpha$ and $\beta$-electrons.
!>
!> Note that this energy expression ensures that no self-interaction
!> terms arise. Hence the energy is self-interaction free. However,
!> it is not clear that this energy expression can be cast as being
!> generated by an N-representable density matrix.
!>
!> Note that the Coulomb terms are added on to the v_dc_a and v_dc_b
!> vectors as those contributions are diagonal in the natural orbital
!> basis (just as the 1-electron terms are). The exchange terms do not
!> have this property and are therefore immediately transformed and
!> added onto the correlation function Fock matrices.
!>
!> On the memory management aspects there are costs associated with
!> allocating memory on the heap as in the Fortran ALLOCATE statement.
!> To avoid these overheads, in particular in the inner loops, Fortran
!> POINTERs are used. This means that the actual memory is associated
!> with buffers allocated outside the loops. The pointers are set 
!> inside the loops to provide convenient array views on the memory. 
!> For clarity pairs of variables are used. The ALLOCATABLE arrays
!> having names BUF_<name> are the buffers that hold the actual memory.
!> Associated with each such array is a POINTER <name> that points to
!> BUF_<name> and provides an appropriate number of dimensions and
!> corresponding index limits.
!>
!> In addition this subroutine inherently deals with \f$\alpha\$ and
!> \f$\beta\f$-spin variables. Variables related to \f$\alpha\f$-spin
!> electrons are identified by names with a trailing "_a" whereas 
!> \f$\beta\f$-electron variables are identified by names with a
!> trailing "_b".
!>
!> Another naming convention is that variables include the remaining
!> indeces. For example \f$\gamma_{adj}\f$ given above would have a
!> name that lists the remaining indeces \f$a, d, j\f$ and the order
!> of these indeces corresponds to the order of the dimensions of the
!> 3-dimensional tensor.
!>
!> ### References ###
!>
!> [1] A.-L. Cauchy, "Sur les formules qui résultent de l'emploi du
!>     signe > ou <, et sur les moyennes entre plusieurs quantités",
!>     In Book: Cours d'analyse de l'École Royale Polytechnique, (1821).
!>     Reprinted in Cambridge Library Collection - Mathematics,
!>     Cambridge University Press (2009), pp. 438-459, DOI:
!>     <a href="https://dx.doi.org/10.1017/CBO9780511693328.017>
!>     10.1017/CBO9780511693328.017</a>.
!>
!> [2] V. Bouniakowsky, "Sur quelques inegalités concernant les
!>     intégrales aux différences finies", Memoires de L'Academie
!>     Imperiale des Sciences de St.-Petersbourg, VII, 1 (1859) Nr. 9,
!>     pp. 1-18, URL:
!>     <a href="https://books.google.com/books?id=wZhFAAAAcAAJ>
!>     books.google.com/books?id=wZhFAAAAcAAJ</a>.
!>
!> [3] H. A. Schwarz, "Über ein Flächen kleinsten Flächeninhalts
!>     betreffendes Problem der Variationsrechnung", Acta Societatis
!>     Scientiarum Fennicae, XV: 318 (1885), URL:
!>     <a href="https://books.google.com/books?id=BXtIAQAAMAAJ">
!>     https://books.google.com/books?id=BXtIAQAAMAAJ</a>.
!>
!> [4] J. M. Steele, "The Cauchy-Schwarz Master Class", The Mathematical
!>     Association of America (2004), ISBN: 
!>     <a href="https://isbnsearch.org/isbn/052154677X">
!>     0-521-54677-X</a>.
!>
!> [5] H. J. J. van Dam, "An N-representable Hartree-Fock approach for
!>     non-idempotent density matrixes", in preparation (08/31/2017).
!>
!> ### TO DO ###
!>
!> 1. The problem with the correlation energy as formulated in this
!>    subroutine is that in the dissociation limit the occupation
!>    numbers do not approach 1/2. One occupation number tends to be
!>    large (e.g. 0.80) and the other small. In addition still is 
!>    "dynamic correlation" showing up even though a dissociated H2
!>    molecule is just 2 H and so there should be no dynamic 
!>    correlation at all. 
!>    This problem might be a consequence of the repulsive term
!>    on the diagonal having a different shape than the attractive
!>    off-diagonal term.
!>
      subroutine wfn1_e_g_2el_corr14(wfn1_param,wfn1_inst,wfn1_mat,
     &                               wfn1_wave,g_x_aa,g_x_bb,E_corr)
      implicit none
c
!include "wfn1_param.fh"
!include "wfn1_matcnst.fh"
!include "wfn1_wfn.fh"
!include "wfn1_drv.fh"
#include "errquit.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
c
      type(wfn1_prm),     intent(in) :: wfn1_param ! the job parameters
      type(wfn1_prminst), intent(in) :: wfn1_inst  ! the job instances
      type(wfn1_matcnst), intent(in) :: wfn1_mat   ! matrix constants
      type(wfn1_wfn),     intent(in) :: wfn1_wave  ! the wavefunction
c
!     type(wfn1_drv),  intent(inout) :: wfn1_deriv ! the derivatives
c
c     Correlation function Fock matrices in the natural orbital basis
c     alpha-, and beta-spin respectively (excluding exchange)
c
!     double precision, intent(inout) :: v_dc_a(1:wfn1_param%nmo)
!     double precision, intent(inout) :: v_dc_b(1:wfn1_param%nmo)
c
c     This implementation assumes that g_x_aa and g_x_bb
c     have the same data distribution. If the actual
c     data distributions are different then this will not affect the
c     results as these differences will be resolved by the Global
c     Arrays. However, this may generate additional communication and
c     hence reduce the efficiency.
c
c     OBSOLETE:
c     Nmo x nmo global arrays for the 2RDM exchange diagonals.
c     See exchange terms of Eq.(34) of [5].
c
      integer, intent(in) :: g_x_aa ! exchange alpha-alpha block
      integer, intent(in) :: g_x_bb ! exchange beta-beta block
c
c     OBSOLETE:
c     Nmo x nmo global arrays for the 2RDM exchange diagonals
c     derivatives. See the diagonal terms of Eq.(119) of [5].
c
!     integer, intent(in) :: g_dx_aa ! exchange alpha-alpha block
!     integer, intent(in) :: g_dx_bb ! exchange beta-beta block
c
c     The electron correlation energy [5]:
c
      double precision, intent(out) :: E_corr ! The correlation energy
c
c     Local variables:
c
      integer :: nproc ! the number of processors
      integer :: iproc ! the rank of this processor
      integer :: jproc ! a counter over processors
      integer :: itask ! the current task number
c
      integer :: nbf   ! the number of basis functions
      integer :: nmo   ! the number of MOs
      integer :: ne_a  ! the number of alpha-electrons
      integer :: ne_b  ! the number of beta-electrons
c
      integer :: ii, jj, kk, ll ! natural orbital labels
      integer :: ia, ib, ic, id ! atomic orbital labels
      integer :: la, lb, lc, ld ! atomic orbital shell labels
      integer :: na, nb, nc, nd ! number of shell functions
c
!     integer :: ni, nj ! number of natural orbitals
      integer ::     nj ! number of natural orbitals
      integer :: jjj ! counter over sub-ranges of jj
c
      integer :: ia_lo, ia_hi ! a-index atomic orbital limits
      integer :: ib_lo, ib_hi ! b-index atomic orbital limits
      integer :: ic_lo, ic_hi ! c-index atomic orbital limits
      integer :: id_lo, id_hi ! d-index atomic orbital limits
c
      integer :: ii_lo, ii_hi ! i-index natural orbital limits
      integer :: jj_lo, jj_hi ! j-index natural orbital limits
c
      integer :: if_lo, if_hi ! i-index Fock matrix limits
      integer :: jf_lo, jf_hi ! i-index Fock matrix limits
      integer :: ldf          ! leading dimension on Fock matrix
      integer :: idxf         ! index for Fock matrix in local memory
      integer :: ix_lo, ix_hi ! i-index exchange occ. matrix limits
      integer :: jx_lo, jx_hi ! i-index exchange occ. matrix limits
      integer :: ldx          ! leading dimension on exchange occ matrix
      integer :: idxx         ! index for exchange occ. matrix in memory
c
      integer :: max2e  ! quartet maximum no. 2-el integrals
      integer :: mem2   ! amount of scratch space needed
      integer :: maxsbf ! maximum no. of basis functions in a shell
      integer :: nshell ! the number of shells
c
      logical :: ok_dist ! is the data distribution OK?
c
      double precision :: e_iiii_ab, e_iiii_ba
      double precision :: e_iijj_ab, e_iijj_ba
      double precision :: p_a,       p_b
      double precision :: p_a_12,    p_b_12
      double precision :: p1p_a_12,  p1p_b_12
      double precision :: p1p_a_14,  p1p_b_14
      double precision :: p1p_a_34,  p1p_b_34
      double precision :: dp_a_12,   dp_b_12
      double precision :: dp1p_a_12, dp1p_b_12
      double precision :: dp1p_a_14, dp1p_b_14
c
      double precision, allocatable :: occ_a(:) ! a-occupation numbers
      double precision, allocatable :: occ_b(:) ! b-occupation numbers
c
c     Data structure for the electron repulsion integrals, as well as
c     2RDM blocks for the density matrix of [5] and the conventional
c     Hartree-Fock 2RDM.
c
      double precision, allocatable         :: scr(:)
      double precision, allocatable, target :: buf_eri(:)
      double precision, pointer             :: eri(:,:,:,:)
c
c     Intermediates in the 2RDM construction
c
      double precision, allocatable, target :: buf_e_aci_ab(:)
      double precision, pointer             :: e_aci_ab(:,:,:)
      double precision, allocatable, target :: buf_e_aci_ba(:)
      double precision, pointer             :: e_aci_ba(:,:,:)
c
      double precision, allocatable, target :: buf_e2_acj_ab(:)
      double precision, pointer             :: e2_acj_ab(:,:,:)
      double precision, allocatable, target :: buf_e2_acj_ba(:)
      double precision, pointer             :: e2_acj_ba(:,:,:)
c
      double precision, allocatable, target :: buf_e4_abj_ab(:)
      double precision, pointer             :: e4_abj_ab(:,:,:)
      double precision, allocatable, target :: buf_e4_abj_ba(:)
      double precision, pointer             :: e4_abj_ba(:,:,:)
c
c     For the Fock matrices for the natural orbitals
c
c     - Partially transformed
c
!     double precision, allocatable, target :: buf_fn_ic_a(:)
!     double precision, pointer             :: fn_ic_a(:,:)
!     double precision, allocatable, target :: buf_fn_ic_b(:)
!     double precision, pointer             :: fn_ic_b(:,:)
!     double precision, allocatable, target :: buf_fn_ib_a(:)
!     double precision, pointer             :: fn_ib_a(:,:)
!     double precision, allocatable, target :: buf_fn_ib_b(:)
!     double precision, pointer             :: fn_ib_b(:,:)
c
c     - Same as above but fully transformed
c
!     double precision, allocatable, target :: buf_fn_ij_a(:)
!     double precision, pointer             :: fn_ij_a(:,:)
!     double precision, allocatable, target :: buf_fn_ij_b(:)
!     double precision, pointer             :: fn_ij_b(:,:)
c
c     For the Fock matrices for the correlation functions
c
!     double precision, allocatable, target :: buf_fc_ij_a(:)
!     double precision, pointer             :: fc_ij_a(:,:)
!     double precision, allocatable, target :: buf_fc_ij_b(:)
!     double precision, pointer             :: fc_ij_b(:,:)
!     double precision, allocatable, target :: buf_fc_ji_a(:)
!     double precision, pointer             :: fc_ji_a(:,:)
!     double precision, allocatable, target :: buf_fc_ji_b(:)
!     double precision, pointer             :: fc_ji_b(:,:)
c
c     Orbital coefficients
c
      double precision, allocatable, target :: buf_N_di_a(:)
      double precision, pointer             :: N_di_a(:,:)
      double precision, allocatable, target :: buf_N_di_b(:)
      double precision, pointer             :: N_di_b(:,:)
      double precision, allocatable, target :: buf_N_ci_a(:)
      double precision, pointer             :: N_ci_a(:,:)
      double precision, allocatable, target :: buf_N_ci_b(:)
      double precision, pointer             :: N_ci_b(:,:)
      double precision, allocatable, target :: buf_N_bi_a(:)
      double precision, pointer             :: N_bi_a(:,:)
      double precision, allocatable, target :: buf_N_bi_b(:)
      double precision, pointer             :: N_bi_b(:,:)
      double precision, allocatable, target :: buf_N_ai_a(:)
      double precision, pointer             :: N_ai_a(:,:)
      double precision, allocatable, target :: buf_N_ai_b(:)
      double precision, pointer             :: N_ai_b(:,:)
c
      double precision :: f_a
      double precision :: f_ab2a
      double precision :: f_ab2b
      double precision :: f_ab2c
      double precision :: f_ab4a
      double precision :: f_ab4b
      double precision :: f_ab4c
      double precision :: b_ii
      double precision :: b_ij
      double precision :: dbii_ab
      double precision :: dbii_ba
      double precision :: dbij_ab
      double precision :: dbij_ba
      double precision :: k1
      double precision :: k2
      double precision :: dk1_ab
      double precision :: dk1_ba
      double precision :: dk2_ab
      double precision :: dk2_ba
      double precision :: dT_ab
      double precision :: dT_ba
c
      double precision :: c_a_j
      double precision :: c_b_j
cDEBUG
      double precision E_ii_cor
      double precision E2_ij_cor
      double precision E4_ij_cor
      double precision c_ii
      double precision c2_ii
      double precision c2_ij
      character*1 t2, t4
cDEBUG
c
c     Functions:
c
      double precision, external :: ddot
c
c     Code:
c
      nproc = ga_nnodes()
      iproc = ga_nodeid()
      itask = -1
c
      E_corr    = 0.0d0
cDEBUG
      E_ii_cor  = 0.0d0
      E2_ij_cor = 0.0d0
      E4_ij_cor = 0.0d0
      b_ii      = 0.0d0
      c2_ii     = 0.0d0
      b_ij      = 0.0d0
!     write(*,*)'HVD: wfn1_e_g_2el_corr.F'
!     write(92,*)
!     write(94,*)
cDEBUG
c
      nbf    = wfn1_param%nbf
      nmo    = wfn1_param%nmo
      ne_a   = wfn1_param%nea
      ne_b   = wfn1_param%neb
      f_a    = wfn1_param%fac_a
      f_ab2a = wfn1_param%fac_ab2a
      f_ab2b = wfn1_param%fac_ab2b
      f_ab2c = wfn1_param%fac_ab2c
      f_ab4a = wfn1_param%fac_ab4a*dble(nmo**2)/dble(2*nmo*max(1,nmo-1))
      f_ab4b = wfn1_param%fac_ab4b*dble(nmo**2)/dble(2*nmo*max(1,nmo-1))
      f_ab4c = wfn1_param%fac_ab4c
c
      if (.not. bas_numcont(wfn1_inst%basis, nshell)) call errquit
     &     ('wfn1_e_g_2el_corr: bas_numcont failed for basis',
     &      wfn1_inst%basis, BASIS_ERR)
      if (.not. bas_nbf_cn_max(wfn1_inst%basis, maxsbf)) call errquit
     &     ('wfn1_e_g_2el_corr: bas_nbf_cn_max failed for basis',
     &      wfn1_inst%basis, BASIS_ERR)
c
!     call ga_distribution(wfn1_deriv%g_dna,0,ii_lo,ii_hi,jj_lo,jj_hi)
!     ni = ii_hi-ii_lo+1
!     nj = jj_hi-jj_lo+1
      call ga_distribution(wfn1_wave%g_na,0,ii_lo,ii_hi,jj_lo,jj_hi)
      nj = jj_hi-jj_lo+1
      call int_mem_2e4c(max2e,mem2)
c
#ifdef TEST_RDMS
c     allocate(da(nbf,nbf),db(nbf,nbf))
c     allocate(gaa(nbf,nbf,nbf,nbf))
c     allocate(gab(nbf,nbf,nbf,nbf))
c     allocate(gbb(nbf,nbf,nbf,nbf))
c     da  = 0.0d0
c     db  = 0.0d0
c     gaa = 0.0d0
c     gab = 0.0d0
c     gbb = 0.0d0
#endif
c
      allocate(occ_a(1:nmo),occ_b(1:nmo))
      allocate(scr(mem2))
      allocate(buf_eri(max2e))
c
      allocate(buf_e_aci_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e_aci_ba(maxsbf*maxsbf*nmo))
      allocate(buf_e2_acj_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e2_acj_ba(maxsbf*maxsbf*nmo))
      allocate(buf_e4_abj_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e4_abj_ba(maxsbf*maxsbf*nmo))
c
      allocate(buf_N_ai_a(maxsbf*nmo),buf_N_ai_b(maxsbf*nmo))
      allocate(buf_N_bi_a(maxsbf*nmo),buf_N_bi_b(maxsbf*nmo))
      allocate(buf_N_ci_a(maxsbf*nmo),buf_N_ci_b(maxsbf*nmo))
      allocate(buf_N_di_a(maxsbf*nmo),buf_N_di_b(maxsbf*nmo))
c
!     allocate(buf_fn_ic_a(nmo*maxsbf),buf_fn_ic_b(nmo*maxsbf))
!     allocate(buf_fn_ib_a(nmo*maxsbf),buf_fn_ib_b(nmo*maxsbf))
!     allocate(buf_fn_ij_a(nmo*nj),    buf_fn_ij_b(nmo*nj))
c
!     allocate(buf_fc_ij_a(nmo*nj))
!     allocate(buf_fc_ij_b(nmo*nj))
!     allocate(buf_fc_ji_a(nj*nmo))
!     allocate(buf_fc_ji_b(nj*nmo))
c
c     Calculate occupation numbers
c     ----------------------------
c
c     Calculate alpha-occupation numbers
c
      call wfn1_calc_occ(wfn1_wave%g_ca,nmo,ne_a,wfn1_wave%icnfa,
     &                   wfn1_wave%dcnta,occ_a)
c
c     Calculate beta-occupation numbers
c
      call wfn1_calc_occ(wfn1_wave%g_cb,nmo,ne_b,wfn1_wave%icnfb,
     &                   wfn1_wave%dcntb,occ_b)
c
      call ga_sync()
c
      do ld = 1, nshell
        if (.not. bas_cn2bfr(wfn1_inst%basis, ld, id_lo, id_hi))
     &      call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                   wfn1_inst%basis, BASIS_ERR)
c
        nd = id_hi-id_lo+1
        N_di_a(id_lo:id_hi,1:nmo) => buf_N_di_a
        N_di_b(id_lo:id_hi,1:nmo) => buf_N_di_b
        call ga_get(wfn1_wave%g_na,id_lo,id_hi,1,nmo,N_di_a,nd)
        call ga_get(wfn1_wave%g_nb,id_lo,id_hi,1,nmo,N_di_b,nd)
c
        do lb = 1, nshell
          if (.not. bas_cn2bfr(wfn1_inst%basis, lb, ib_lo, ib_hi))
     &        call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                     wfn1_inst%basis, BASIS_ERR)
c
          nb = ib_hi-ib_lo+1
          N_bi_a(ib_lo:ib_hi,1:nmo) => buf_N_bi_a
          N_bi_b(ib_lo:ib_hi,1:nmo) => buf_N_bi_b
          call ga_get(wfn1_wave%g_na,ib_lo,ib_hi,1,nmo,N_bi_a,nb)
          call ga_get(wfn1_wave%g_nb,ib_lo,ib_hi,1,nmo,N_bi_b,nb)
c
          do lc = 1, nshell 
            if (.not. bas_cn2bfr(wfn1_inst%basis, lc, ic_lo, ic_hi))
     &          call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                       wfn1_inst%basis, BASIS_ERR)
c
            nc = ic_hi-ic_lo+1
            N_ci_a(ic_lo:ic_hi,1:nmo) => buf_N_ci_a
            N_ci_b(ic_lo:ic_hi,1:nmo) => buf_N_ci_b
            call ga_get(wfn1_wave%g_na,ic_lo,ic_hi,1,nmo,N_ci_a,nc)
            call ga_get(wfn1_wave%g_nb,ic_lo,ic_hi,1,nmo,N_ci_b,nc)
c
            do la = 1, nshell
              itask = itask + 1
              if (mod(itask,nproc).ne.iproc) cycle
              if (.not. bas_cn2bfr(wfn1_inst%basis, la, ia_lo, ia_hi))
     &            call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                         wfn1_inst%basis, BASIS_ERR)
c
              na = ia_hi-ia_lo+1
              N_ai_a(ia_lo:ia_hi,1:nmo) => buf_N_ai_a
              N_ai_b(ia_lo:ia_hi,1:nmo) => buf_N_ai_b
              call ga_get(wfn1_wave%g_na,ia_lo,ia_hi,1,nmo,N_ai_a,na)
              call ga_get(wfn1_wave%g_nb,ia_lo,ia_hi,1,nmo,N_ai_b,na)
c
c             Set up eri buffers
c
              eri(ia_lo:ia_hi,ic_lo:ic_hi,ib_lo:ib_hi,id_lo:id_hi)
     &        => buf_eri
c
              e_aci_ab(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e_aci_ab
              e_aci_ba(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e_aci_ba
              e2_acj_ab(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e2_acj_ab
              e2_acj_ba(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e2_acj_ba
              e4_abj_ab(ia_lo:ia_hi,ib_lo:ib_hi,1:nmo)
     &        => buf_e4_abj_ab
              e4_abj_ba(ia_lo:ia_hi,ib_lo:ib_hi,1:nmo)
     &        => buf_e4_abj_ba
c
              e_aci_ab  = 0.0d0
              e_aci_ba  = 0.0d0
              e2_acj_ab = 0.0d0
              e2_acj_ba = 0.0d0
              e4_abj_ab = 0.0d0
              e4_abj_ba = 0.0d0
c
c             Calculate the 2-electron integrals
c
              call int_2e4c(wfn1_inst%basis, ld, lb,
     &                      wfn1_inst%basis, lc, la,
     &                      mem2, scr, max2e, eri)
c
              do id = id_lo, id_hi
                do ib = ib_lo, ib_hi
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      do ii = 1, nmo
                        e_aci_ab(ia,ic,ii) = e_aci_ab(ia,ic,ii)
     &                  + eri(ia,ic,ib,id)*N_bi_b(ib,ii)*N_di_b(id,ii)
                        e_aci_ba(ia,ic,ii) = e_aci_ba(ia,ic,ii)
     &                  + eri(ia,ic,ib,id)*N_bi_a(ib,ii)*N_di_a(id,ii)
                        e4_abj_ab(ia,ib,ii) = e4_abj_ab(ia,ib,ii)
     &                  + eri(ia,ic,ib,id)*N_ci_a(ic,ii)*N_di_b(id,ii)
                        e4_abj_ba(ia,ib,ii) = e4_abj_ba(ia,ib,ii)
     &                  + eri(ia,ic,ib,id)*N_ci_b(ic,ii)*N_di_a(id,ii)
                      enddo ! ii
                    enddo ! ia
                  enddo ! ic
                enddo ! ib
              enddo ! id
              do ii = 1, nmo
                do ic = ic_lo, ic_hi
                  do ia = ia_lo, ia_hi
                    e2_acj_ab(ia,ic,ii) = e_aci_ab(ia,ic,ii)
                    e2_acj_ba(ia,ic,ii) = e_aci_ba(ia,ic,ii)
                  enddo ! ia
                enddo ! ic
              enddo ! ii
c
c             Calculate the energy contributions
c
              do ic = ic_lo, ic_hi
                do ia = ia_lo, ia_hi
                  do ii = 1, nmo
                    E_corr = E_corr
     &              - e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &              * wfn1_diag(wfn1_param,
     &                          occ_a(ii),occ_b(ii))
     &              - e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &              * wfn1_diag(wfn1_param,
     &                          occ_b(ii),occ_a(ii))
cDEBUG
                    E_ii_cor = E_ii_cor
     &              - e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &              * wfn1_diag(wfn1_param,
     &                          occ_a(ii),occ_b(ii))
     &              - e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &              * wfn1_diag(wfn1_param,
     &                          occ_b(ii),occ_a(ii))
cDEBUG
                    do jj = 1, ii-1
                      E_corr = E_corr
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                      E2_ij_cor = E2_ij_cor
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                    enddo ! jj
                    do jj = ii+1, nmo
                      E_corr = E_corr
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                      E2_ij_cor = E2_ij_cor
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * wfn1_diag(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                    enddo ! jj
                  enddo ! ii
                enddo ! ia
              enddo ! ic
c
              do ib = ib_lo, ib_hi
                do ia = ia_lo, ia_hi
                  do ii = 1, nmo
                    do jj = 1, ii-1
                      E_corr = E_corr
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                      E4_ij_cor = E4_ij_cor
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                    enddo ! jj
                    do jj = ii+1, nmo
                      E_corr = E_corr
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
cDEBUG
                      E4_ij_cor = E4_ij_cor
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(ii),occ_b(jj))
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * wfn1_ofdg(wfn1_param,
     &                            occ_a(jj),occ_b(ii))
                    enddo ! jj
                  enddo ! ii
                enddo ! ia
              enddo ! ib
c
            enddo ! la
          enddo ! lc
        enddo ! lb
      enddo ! ld
c
      E_corr    = 0.5d0*E_corr
cDEBUG
c     write(*,*)'HVD: E_ii_cor  = ',0.5d0*E_ii_cor
c     write(*,*)'HVD: E2_ij_cor = ',0.5d0*E2_ij_cor
c     write(*,*)'HVD: E4_ij_cor = ',0.5d0*E4_ij_cor
cDEBUG
c
      call ga_dgop(1300,E_corr,1,"+")
c
      deallocate(occ_a,occ_b)
      deallocate(buf_eri)
      deallocate(scr)
c
      deallocate(buf_e_aci_ab)
      deallocate(buf_e_aci_ba)
      deallocate(buf_e2_acj_ab)
      deallocate(buf_e2_acj_ba)
      deallocate(buf_e4_abj_ab)
      deallocate(buf_e4_abj_ba)
c
      deallocate(buf_N_ai_a,buf_N_ai_b)
      deallocate(buf_N_bi_a,buf_N_bi_b)
      deallocate(buf_N_ci_a,buf_N_ci_b)
      deallocate(buf_N_di_a,buf_N_di_b)
c
!     deallocate(buf_fn_ic_a,buf_fn_ic_b)
!     deallocate(buf_fn_ib_a,buf_fn_ib_b)
!     deallocate(buf_fn_ij_a,buf_fn_ij_b)
c
!     deallocate(buf_fc_ij_a)
!     deallocate(buf_fc_ij_b)
!     deallocate(buf_fc_ji_a)
!     deallocate(buf_fc_ji_b)
c
      contains
c
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for low occ - low occ interactions
!>
!> This scale factor is high if both orbitals have occupations close
!> to zero.
!>
      double precision function wfn1_fac_occ00(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = (1.0d0-occ1)*(1.0-occ1)
     &    * (1.0d0-occ2)*(1.0-occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for high occ - high occ interactions
!>
!> This scale is high is both orbitals have occupations close to one.
!>
      double precision function wfn1_fac_occ11(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = (occ1*occ1*occ2*occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for low occ - high occ interactions
!>
!> This scale factor is high if one of the orbitals has an occupation 
!> number close to zero and the other an occupation number close to one.
!>
      double precision function wfn1_fac_occ01(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = (occ1*occ1*(1.0d0-occ2)*(1.0d0-occ2))
     &    + ((1.0d0-occ1)*(1.0d0-occ1)*occ2*occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for low occ - half occ interactions
!>
!> This scale factor is high if one of the orbitals has and occupation 
!> number close to zero and the other an occupation number close to 
!> half.
!>
      double precision function wfn1_fac_occ05(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = 2.0d0*(1.0d0-occ1)*(1.0d0-occ1)*occ2*(1.0d0-occ2)
     &    + 2.0d0*occ1*(1.0d0-occ1)*(1.0d0-occ2)*(1.0d0-occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for half occ - high occ interactions
!>
!> This scale factor is high if one of the orbitals has and occupation 
!> number close to one and the other an occupation number close to 
!> half.
!>
      double precision function wfn1_fac_occ51(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = 2.0d0*occ1*occ1*occ2*(1.0d0-occ2)
     &    + 2.0d0*occ1*(1.0d0-occ1)*occ2*occ2
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Scale factor for half occ - half occ interactions
!>
!> This scale factor is high if both orbitals are half occupied.
!>
      double precision function wfn1_fac_occ55(occ1,occ2) result(fac)
      implicit none
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = 4.0d0*occ1*(1.0d0-occ1)*occ2*(1.0d0-occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Root factor
!>
      double precision function wfn1_root(rt,occ1,occ2) result(fac)
      implicit none
!>    Root 
      double precision, intent(in) :: rt
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
c
      fac = ((4.0d0*(occ1*max(0.0d0,1.0d0-occ1)))
     &    *  (4.0d0*(occ2*max(0.0d0,1.0d0-occ2))))**rt
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief Exchange root factor
!>
      double precision function wfn1_exch_root(rt,occ12) result(fac)
      implicit none
!>    Root 
      double precision, intent(in) :: rt
!>    2-electron occupation number for orbital pair 1,2
      double precision, intent(in) :: occ12
c
      fac = (4.0d0*(occ12*max(0.0d0,1.0d0-occ12)))**rt
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief diagonal factor
!>
!> The old diagonal terms led to weird dissociation limit results.
!> Making the shape similar to the off-diagonal terms might help.
!>
      double precision function wfn1_diag(wfn1_param,occ1,occ2)
     &                 result(fac)
      implicit none
!>    Calculation parameters
      type(wfn1_prm),   intent(in) :: wfn1_param
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
!>
      double precision :: f00, f01, f11, f05, f51, f55
      double precision :: r00, r01, r11, r05, r51, r55
!>
      f00 = wfn1_param%fcd00
      f01 = wfn1_param%fcd01
      f11 = wfn1_param%fcd11
      f05 = wfn1_param%fcd05
      f51 = wfn1_param%fcd51
      f55 = wfn1_param%fcd55
      r00 = wfn1_param%rcd00
      r01 = wfn1_param%rcd01
      r11 = wfn1_param%rcd11
      r05 = wfn1_param%rcd05
      r51 = wfn1_param%rcd51
      r55 = wfn1_param%rcd55
!>
      fac = f00*wfn1_fac_occ00(occ1,occ2)*wfn1_root(r00,occ1,occ2)
     &    + f01*wfn1_fac_occ01(occ1,occ2)*wfn1_root(r01,occ1,occ2)
     &    + f11*wfn1_fac_occ11(occ1,occ2)*wfn1_root(r11,occ1,occ2)
     &    + f05*wfn1_fac_occ05(occ1,occ2)*wfn1_root(r05,occ1,occ2)
     &    + f51*wfn1_fac_occ51(occ1,occ2)*wfn1_root(r51,occ1,occ2)
     &    + f55*wfn1_fac_occ55(occ1,occ2)*wfn1_root(r55,occ1,occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief off-diagonal factor
!>
!>
      double precision function wfn1_ofdg(wfn1_param,occ1,occ2)
     &                 result(fac)
      implicit none
!>    Calculation parameters
      type(wfn1_prm),   intent(in) :: wfn1_param
!>    Occupation number 1
      double precision, intent(in) :: occ1
!>    Occupation number 2
      double precision, intent(in) :: occ2
!>
      double precision :: f00, f01, f11, f05, f51, f55
      double precision :: r00, r01, r11, r05, r51, r55
!>
      f00 = wfn1_param%fco00
      f01 = wfn1_param%fco01
      f11 = wfn1_param%fco11
      f05 = wfn1_param%fco05
      f51 = wfn1_param%fco51
      f55 = wfn1_param%fco55
      r00 = wfn1_param%rco00
      r01 = wfn1_param%rco01
      r11 = wfn1_param%rco11
      r05 = wfn1_param%rco05
      r51 = wfn1_param%rco51
      r55 = wfn1_param%rco55
!>
      fac = f00*wfn1_fac_occ00(occ1,occ2)*wfn1_root(r00,occ1,occ2)
     &    + f01*wfn1_fac_occ01(occ1,occ2)*wfn1_root(r01,occ1,occ2)
     &    + f11*wfn1_fac_occ11(occ1,occ2)*wfn1_root(r11,occ1,occ2)
     &    + f05*wfn1_fac_occ05(occ1,occ2)*wfn1_root(r05,occ1,occ2)
     &    + f51*wfn1_fac_occ51(occ1,occ2)*wfn1_root(r51,occ1,occ2)
     &    + f55*wfn1_fac_occ55(occ1,occ2)*wfn1_root(r55,occ1,occ2)
c
      return
      end
c
c-----------------------------------------------------------------------
c
!> \brief exchange off-diagonal factor
!>
!>
      double precision function wfn1_exch(wfn1_param,occ12,occ34)
     &                 result(fac)
      implicit none
!>    Calculation parameters
      type(wfn1_prm),   intent(in) :: wfn1_param
!>    2-electron occupation number for orbital pair 1,2
      double precision, intent(in) :: occ12
!>    2-electron occupation number for orbital pair 3,4
      double precision, intent(in) :: occ34
!>
      double precision :: f00, f01, f11, f05, f51, f55
      double precision :: r00, r01, r11, r05, r51, r55
!>
      f00 = wfn1_param%fx00
      f01 = wfn1_param%fx01
      f11 = wfn1_param%fx11
      f05 = wfn1_param%fx05
      f51 = wfn1_param%fx51
      f55 = wfn1_param%fx55
      r00 = wfn1_param%rx00
      r01 = wfn1_param%rx01
      r11 = wfn1_param%rx11
      r05 = wfn1_param%rx05
      r51 = wfn1_param%rx51
      r55 = wfn1_param%rx55
!>
      fac = f00*wfn1_fac_occ00(occ12,occ34)*wfn1_root(r00,occ12,occ34)
     &    + f01*wfn1_fac_occ01(occ12,occ34)*wfn1_root(r01,occ12,occ34)
     &    + f11*wfn1_fac_occ11(occ12,occ34)*wfn1_root(r11,occ12,occ34)
     &    + f05*wfn1_fac_occ05(occ12,occ34)*wfn1_root(r05,occ12,occ34)
     &    + f51*wfn1_fac_occ51(occ12,occ34)*wfn1_root(r51,occ12,occ34)
     &    + f55*wfn1_fac_occ55(occ12,occ34)*wfn1_root(r55,occ12,occ34)
c
      return
      end
c
c-----------------------------------------------------------------------
c
      end
!>
!> @}
