c-----------------------------------------------------------------------
c
      double precision function signum(x)
      double precision, intent(in) :: x
      if (x.lt.0.0d0) then
        signum = -1.0d0
      else if (x.gt.0.0d0) then
        signum =  1.0d0
      else
        signum =  0.0d0
      endif
      return
      end function signum
c
c-----------------------------------------------------------------------
c
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble.mac
!> 
!> The content of thimble.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> g(r,a,y,z):=(((r+a)**y-a**y)/((1.0+a)**y-a**y))**z;
!> f1(r,a,y,z):=((g(r,a,y,1.0)*log(g(r,a,y,1.0))+g(1.0-r,a,y,1.0)*log(g(1.0-r,a,y,1.0)))/(2.0*g(0.5,a,y,1.0)*log(g(0.5,a,y,1.0))))**z;
!> f2(r1,r2,a,y,z):=((g(r1,a,y,1.0)*g(r2,a,y,1.0)*log(g(r1,a,y,1.0)*g(r2,a,y,1.0))+g(r1,a,y,1.0)*g(1.0-r2,a,y,1.0)*log(g(r1,a,y,1.0)*g(1.0-r2,a,y,1.0))+g(1.0-r1,a,y,1.0)*g(r2,a,y,1.0)*log(g(1.0-r1,a,y,1.0)*g(r2,a,y,1.0))+g(1.0-r1,a,y,1)*g(1.0-r2,a,y,1.0)*log(g(1.0-r1,a,y,1.0)*g(1.0-r2,a,y,1.0)))/(4.0*(g(0.5,a,y,1.0)*g(0.5,a,y,1.0)*log(g(0.5,a,y,1.0)*g(0.5,a,y,1.0)))))**z;
!> h(r1,r2,a,y,z):=f1(r1,a,y,z)+f1(r2,a,y,z)-f2(r1,r2,a,y,z);
!> dhdr1(r1,r2,a,y,z):=diff(h(r1,r2,a,y,z),r1);
!> dhdr2(r1,r2,a,y,z):=diff(h(r1,r2,a,y,z),r2);
!> with_stdout("thimble.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,a,y,z),dhdr1(r1,r2,a,y,z),dhdr2(r1,r2,a,y,z)]));
!>
!>
      subroutine wfn1_thimble_mermin(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
      t1 = -a**y
      t2 = (a+5.0d-1)**y+t1
      t3 = (a+1.0d+0)**y+t1
      t4 = 1/t3
      t5 = t2*t4
      t6 = 1/log(t5)
      t7 = (-r1)+a+1.0d+0
      t8 = t7**y+t1
      t9 = t4*t8
      t10 = (-r2)+a+1.0d+0
      t11 = t10**y+t1
      t12 = t4*t11
      t13 = log(t9*t12)
      t14 = r1+a
      t15 = t14**y+t1
      t16 = t4*t15
      t17 = log(t16*t12)
      t18 = r2+a
      t19 = t18**y+t1
      t20 = t4*t19
      t21 = log(t9*t20)
      t22 = log(t16*t20)
      t23 = t22*t16*t20+t21*t9*t20+t17*t16*t12+t13*t4*t8*t12
      t24 = ((t6*t23)/t5**2.0d+0)**z
      t25 = 1.25d-1**z
      t26 = 1/t2
      t27 = log(t9)
      t28 = log(t16)
      t29 = 1.0d+0*t28*t16+1.0d+0*t27*t9
      t30 = (t6*t26*t3*t29)**z
      t31 = 5.0d-1**z
      t32 = log(t12)
      t33 = log(t20)
      t34 = 1.0d+0*t33*t20+1.0d+0*t32*t12
      t35 = (t6*t26*t3*t34)**z
      t36 = 1/t23
      t37 = 1/t3**2
      t38 = y-1
      t39 = t7**t38
      t40 = t14**t38
      t41 = 1/t3**4
      t42 = t3/t8
      t43 = t11**2
      t44 = t3/t11
      t45 = t3/t15
      t46 = t19**2
      t47 = t3/t19
      t48 = t10**t38
      t49 = t8**2
      t50 = t15**2
      t51 = t18**t38
      h = t35*t31+t30*t31-t24*t25+h
      dhdr1 = (t30*(1.0d+0*t28*t4*t40*y+1.0d+0*t4*t40*y-1.0d+0*t27*t4*t3
     1   9*y-1.0d+0*t4*t39*y)*z*t31)/t29-t36*t24*(t41*t40*t15*t45*t46*t4
     2   7*y-t41*t8*t42*t39*t46*t47*y+t22*t37*t40*t19*y-t21*t37*t39*t19*
     3   y+t41*t40*t15*t45*t43*t44*y-t41*t8*t42*t39*t43*t44*y+t17*t37*t4
     4   0*t11*y-t13*t37*t39*t11*y)*z*t25+dhdr1
      dhdr2 = (t35*(1.0d+0*t33*t4*t51*y+1.0d+0*t4*t51*y-1.0d+0*t32*t4*t4
     1   8*y-1.0d+0*t4*t48*y)*z*t31)/t34-t36*t24*(t41*t50*t45*t51*t19*t4
     2   7*y+t41*t49*t42*t51*t19*t47*y+t22*t37*t15*t51*y+t21*t37*t8*t51*
     3   y-t41*t50*t45*t11*t44*t48*y-t41*t49*t42*t11*t44*t48*y-t17*t37*t
     4   15*t48*y-t13*t37*t8*t48*y)*z*t25+dhdr2
      end subroutine wfn1_thimble_mermin
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function by repurposing SSF
!>
!> As the Mermin entropy based approach did not allow us to get the
!> entropy right (total energies and occupation numbers of H2 in a 
!> minimal basis were all wrong: total energy rises too slowly away
!> from equilibrium), we taking another approach here. 
!>
!> The approach used here is based on repurposing the SSF switching
!> function [1]. This switching function is modified by a transformation
!> of the coordinates \f$t(x=[0,1],y):->[0,1]\f$ given by \f$x^y\f$. The
!> transformed coordinates are transformed \f$u(x=[0,1]):->[-1,1]\f$ again
!> where u is a linear transformation.
!> Then the function \f$h(x=[-1,1]):->[-1,1]\f$ is applied. The timble
!> function is defined as \f$g(x)=h(x)*h(1-x)\f$. This result is then mapped
!> to the range [0,1] by \f$f(x)=\frac{(1+g(x))}{(1+g(1/2))}\f$.
!> Finally the thimble function overall is defined as 
!> \f$k(x,y)=f(x)*f(y)\f$.
!>
!> The switching function is defined as [1] (see Eq.(5)):
!> \f{eqnarray}{
!> h(x)&=&\frac{3}{2}x-\frac{1}{2}x^3
!> \f}
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble.mac
!> 
!> The content of thimble.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> t(r,y):=r**y;
!> u(r):=2*r-1;
!> h(u):=(3.0/2.0)*u-(u**3)/2.0;
!> g(x,y):=(x+1)/(y+1);
!> 
!> s(r1,r2,a,y,z):=g(h(u(t(r1,y)))*h(u(t(1.0-r1,y))),h(u(t(0.5,y)))*h(u(t(0.5,y))))*g(h(u(t(r2,y)))*h(u(t(1.0-r2,y))),h(u(t(0.5,y)))*h(u(t(0.5,y))));
!> dsdr1(r1,r2,a,y,z):=diff(s(r1,r2,a,y,z),r1);
!> dsdr2(r1,r2,a,y,z):=diff(s(r1,r2,a,y,z),r2);
!> with_stdout("thimble.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[s(r1,r2,a,y,z),dsdr1(r1,r2,a,y,z),dsdr2(r1,r2,a,y,z)]));
!>
!> [1] R.E. Stratmann, G.E. Scuseria, M.J. Frisch, "Achieving linear
!>     scaling in exchange-correlation density functional quadratures",
!>     Chemical Physics Letters (1996), Vol. 257, pp. 213-223, DOI:
!>     https://doi.org/10.1016/0009-2614(96)00600-8
!>
      subroutine wfn1_thimble_ssf(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = 2.0d0*t1**y-1.0d0
      t3 = 1.5d+0*t2-5.0d-1*t2**3
      t4 = 2.0d0*r1**y-1.0d0
      t5 = 1.5d+0*t4-5.0d-1*t4**3
      t6 = t3*t5+1.0d0
      t7 = 1.0d+0-r2
      t8 = 2.0d0*t7**y-1.0d0
      t9 = 1.5d+0*t8-5.0d-1*t8**3
      t10 = 2.0d0*r2**y-1.0d0
      t11 = 1.5d+0*t10-5.0d-1*t10**3
      t12 = t9*t11+1.0d0
      t13 = 2.0d0*5.0d-1**y-1.0d0
      t14 = 1.0d0/((1.5d+0*t13-5.0d-1*t13**3)**2+1.0d0)**2
      t15 = y-1.0d0
      t16 = t1**t15
      t17 = r1**t15
      t18 = t7**t15
      t19 = r2**t15
      h = t6*t12*t14+h
      dhdr1 = t12*(t3*(3.0d+0*t17*y-3.0d+0*t17*t4**2*y)+t5*(3.0d+0*t2**2
     1   *t16*y-3.0d+0*t16*y))*t14+dhdr1
      dhdr2 = t6*(t9*(3.0d+0*t19*y-3.0d+0*t19*t10**2*y)+t11*(3.0d+0*t8**
     1   2*t18*y-3.0d+0*t18*y))*t14+dhdr2
      end subroutine wfn1_thimble_ssf
c
c-----------------------------------------------------------------------
c
!> \brief Thimble inspired by Jacobi rotation
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b cos.mac
!> 
!> The content of cos.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> c(x):=cos(2*%pi*x);
!> h(r1,r2,y):=((1-c(r1)-c(r2)+c(r1)*c(r2))/(1-c(1/2)-c(1/2)+c(1/2)*c(1/2)))**y;
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("cos.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_cos(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      tpi = acos(-1.0d0)
      t1 = 2*tpi*r1
      t2 = cos(t1)
      t3 = 2*tpi*r2
      t4 = cos(t3)
      t5 = t2*t4-t4-t2+1
      t6 = 1/4**y
      t7 = t5**(y-1)
      t8 = sin(t1)
      t9 = sin(t3)
      h = t5**y*t6
      dhdr1 = t7*(2*tpi*t8-2*tpi*t8*t4)*y*t6
      dhdr2 = t7*(2*tpi*t9-2*tpi*t2*t9)*y*t6
      end subroutine wfn1_thimble_cos
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on an exponent
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b spire.mac
!> 
!> The content of spire.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r,y):=exp(-y*abs(r-1/2));
!> f(r,y):=(e(r,y)-e(0,y))/(e(1/2,y)-e(0,y));
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("spire.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_spire(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1    = -1.0d0/exp(y/2.0d+0)
      t2    = 1.0d0/(t1+1.0d0)**2
      t3    = r1+(-1.0d+0)/2.0d+0
      t4    = abs(t3)
      t5    = exp(-t4*y)
      t6    = t5+t1
      t7    = r2+(-1.0d+0)/2.0d+0
      t8    = abs(t7)
      t9    = exp(-t8*y)
      t10   = t9+t1
      h     = t2*t6*t10
      dhdr1 = -(t3*y*t2*t5*t10)/t4
      dhdr2 = -(t7*y*t2*t6*t9)/t8
      end subroutine wfn1_thimble_spire
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on a Gaussian
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b gaussian.mac
!> 
!> The content of gaussian.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r,y):=exp(-y*(r-1/2)**2);
!> f(r,y):=(e(r,y)-e(0,y))/(e(1/2,y)-e(0,y));
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("gaussian.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_gaussian(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = -1.0d0/exp(y/4.0d+0)
      t2 = 1.0d0/(t1+1.0d0)**2
      t3 = r1+(-1.0d+0)/2.0d+0
      t4 = exp(-t3**2*y)
      t5 = t4+t1
      t6 = r2+(-1.0d+0)/2.0d+0
      t7 = exp(-t6**2*y)
      t8 = t7+t1
      h  = t2*t5*t8
      dhdr1 = -2.0d0*t3*y*t2*t4*t8
      dhdr2 = -2.0d0*t6*y*t2*t5*t7
      end subroutine wfn1_thimble_gaussian
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on Mermin entropy
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble_better.mac
!> 
!> The content of thimble_better.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r):=(r*(1.0-r));
!> f(r,y):=(e(r)/e(1/2))**y;
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("thimble_better.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_no_e(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      h = t2*t4*t5
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5)/(t3*r2)
      end subroutine wfn1_thimble_no_e
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on Mermin entropy and orbital energies
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble_energy.mac
!> 
!> The content of thimble_energy.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> d(r):=(r*(1.0-r));
!> f(r,y):=(d(r)/d(1/2))**y;
!> g(e,z):=exp(-z*e*e);
!> h(r1,r2,de,y,z):=f(r1,y)*f(r2,y)*g(de,z);
!> 
!> dhdr1(r1,r2,de,y,z):=diff(h(r1,r2,de,y,z),r1);
!> dhdr2(r1,r2,de,y,z):=diff(h(r1,r2,de,y,z),r2);
!> with_stdout("thimble_energy.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,de,y,z),dhdr1(r1,r2,de,y,z),dhdr2(r1,r2,de,y,z)]));
!> 
!>
      subroutine wfn1_thimble_001(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      t6 = exp(-de**2*z)
      h = t2*t4*t5*t6
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5*t6)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5*t6)/(t3*r2)
      end subroutine wfn1_thimble_001
      subroutine wfn1_thimble_002(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d0/(log(2.0d0)/2.0d+0+3.4657359027997264d-1)**(2*y)
      t2 = de**2
      t3 = abs(de)
      t4 = 1.0d0/(2.7d+1*t2*t3+3.0d+0*t3+8.1d+1*de**4+9.0d+0*t2+1.0d+0)
      t5 = 1.0d+0-r1
      t6 = log(t5)
      t7 = log(r1)
      t8 = (-r1*t7)-t6*t5
      t9 = t8**y
      t10 = 1.0d+0-r2
      t11 = log(t10)
      t12 = log(r2)
      t13 = (-r2*t12)-t11*t10
      t14 = t13**y
      t15 = y-1.0d0
      h = 1.0d+0*t1*t4*t9*t14
      dhdr1 = 1.0d+0*t1*t4*(t6-t7)*t8**t15*t14*y
      dhdr2 = 1.0d+0*t1*t4*t9*(t11-t12)*t13**t15*y
      end subroutine wfn1_thimble_002
      subroutine wfn1_thimble_003(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      t6 = exp(-abs(de)**1.31d+0*z)
c     t6 = exp(-abs(de)**1.21319d+0*z)
c     t6 = exp(-abs(de)**0.50d+0*z)
      h = t2*t4*t5*t6
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5*t6)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5*t6)/(t3*r2)
      end subroutine wfn1_thimble_003
      subroutine wfn1_thimble_004(r1,r2,de,x,y1,y2,z1,z2,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2*x)
      t6 = abs(de)
      t7 = exp((-t6**y2*z2)-t6**y1*z1)
      h = t2*t4*t5*t7+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t7)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t7)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble_004
      subroutine wfn1_thimble_005(r1,r2,de,x,y1,y2,z1,z2,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      double precision :: gsl_sf_gamma
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2*x)
      t6 = abs(de)
#ifdef USE_GSL
      t7 = gsl_sf_gamma((z1*t6)**y1+2.0d+0)
      t8 = gsl_sf_gamma((z2*t6)**y2+2.0d+0)
      t9 = exp(-t8-t7+2.0d+0)
#else
      t7 = (z1*t6)**y1+1.0d+0
      t8 = (z2*t6)**y2+1.0d+0
      t9 = exp((-exp(t8*log(t8)))-exp(t7*log(t7))+2.0d+0)
#endif
      h = t2*t4*t5*t9+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t9)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t9)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble_005
      subroutine wfn1_thimble_006(r1,r2,de,x,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t0 = abs(de)
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2.0d0*x)
      t6 = -(t0*z5)**y5
      t7 = -(t0*z4)**y4
      t8 = -(t0*z3)**y3
      t9 = -(t0*z2)**y2
      t10 = -(t0*z1)**y1
      t11 = exp(t6+t7+t8+t9+t10)
cDEBUG
      write(*,*)'abs(de)=',t0
      write(*,*)'z1,y1  =',z1,y1,t10
      write(*,*)'z2,y2  =',z2,y2,t9
      write(*,*)'z3,y3  =',z3,y3,t8
      write(*,*)'z4,y4  =',z4,y4,t7
      write(*,*)'z5,y5  =',z5,y5,t6
      write(*,*)'exp    =',t11
cDEBUG
      h = t2*t4*t5*t11+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t11)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t11)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble_006
      subroutine wfn1_thimble_007(r1,r2,de,x,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d0/(log(2.0d0)/2.0d+0+3.4657359027997264d-1)**(2.0d0*x)
      t2 = 1.0d+0-r1
      t3 = log(t2)
      t4 = log(r1)
      t5 = (-r1*t4)-t3*t2
      t6 = t5**x
      t7 = 1.0d+0-r2
      t8 = log(t7)
      t9 = log(r2)
      t10 = (-r2*t9)-t8*t7
      t11 = t10**x
      t12 = abs(de)
      t13 = exp((-t12**y5*z5**y5)-t12**y4*z4**y4-t12**y3*z3**y3-t12**y2*
     1   z2**y2-t12**y1*z1**y1)
      t14 = x-1.0d0
      h = t1*t6*t11*t13+h
      dhdr1 = t1*(t3-t4)*t5**t14*t11*x*t13+dhdr1
      dhdr2 = t1*t6*(t8-t9)*t10**t14*x*t13+dhdr2
      end subroutine wfn1_thimble_007
      subroutine wfn1_thimble_008(r1,r2,de,x,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = log(t1)
      t3 = log(r1)
      t4 = (-r1*t3)-t2*t1
      t5 = abs(de)
      t6 = exp(-t5*x)
      t7 = t4**t6
      t8 = 1.0d+0-r2
      t9 = log(t8)
      t10 = log(r2)
      t11 = (-r2*t10)-t9*t8
      t12 = t11**t6
      t13 = 1.4426950408889633d+0**(2*t6)
      t14 = -t5**y1*z1**y1
      t15 = -t5**y2*z2**y2
      t16 = -t5**y3*z3**y3
      t17 = -t5**y4*z4**y4
      t18 = -t5**y5*z5**y5
      t19 = t6-1
      t20 = exp(t18+t17+t16+t15+t14-t5*x)
      h = t7*t12*t13*exp(t18+t17+t16+t15+t14)+h
      dhdr1 = (t2-t3)*t4**t19*t12*t13*t20+dhdr1
      dhdr2 = t7*(t9-t10)*t11**t19*t13*t20+dhdr2
      end subroutine wfn1_thimble_008
      subroutine wfn1_thimble_009(r1,r2,de,x,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = log(t1)
      t3 = log(r1)
      t4 = (-r1*t3)-t2*t1
      t5 = t4**x
      t6 = 1.0d+0-r2
      t7 = log(t6)
      t8 = log(r2)
      t9 = (-r2*t8)-t7*t6
      t10 = t9**x
      t11 = 1.4426950408889633d+0**(2*x)
      t12 = abs(de)
      t13 = exp((-t12**y5*z5**y5)-t12**y4*z4**y4-t12**y3*z3**y3-t12**y2*
     1   z2**y2-t12**y1*z1**y1)
      t14 = x-1
      h = t5*t10*t11*t13+h
      dhdr1 = (t2-t3)*t4**t14*t10*x*t11*t13+dhdr1
      dhdr2 = t5*(t7-t8)*t9**t14*x*t11*t13+dhdr2
      end subroutine wfn1_thimble_009
      subroutine wfn1_thimble_010(r1,r2,de,x1,x2,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x1
      double precision, intent(in)  :: x2
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      double precision, external :: signum
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = log(t1)
      t3 = log(r1)
      t4 = (-r1*t3)-t2*t1
      t5 = abs(de)
      t6 = t5**x2
      t7 = exp(-t6*x1)
      t8 = t4**t7
      t9 = 1.0d+0-r2
      t10 = log(t9)
      t11 = log(r2)
      t12 = (-r2*t11)-t10*t9
      t13 = t12**t7
      t14 = 1.4426950408889633d+0**(2*t7)
      t15 = -t5**y1*signum(z1)*abs(z1)**y1
      t16 = -t5**y2*signum(z2)*abs(z2)**y2
      t17 = -t5**y3*signum(z3)*abs(z3)**y3
      t18 = -t5**y4*signum(z4)*abs(z4)**y4
      t19 = -t5**y5*signum(z5)*abs(z5)**y5
      t20 = t7-1
cDEBUG
c     write(0,*)'HVD: y1,y2 = ',y1,y2
c     write(0,*)'HVD: z1,z2 = ',z1,z2
c     write(0,*)'HVD: t5    = ',t5
c     write(0,*)'HVD: t15   = ',t15
c     write(0,*)'HVD: t16   = ',t16
c     write(0,*)'HVD: t17   = ',t17
c     write(0,*)'HVD: t18   = ',t18
c     write(0,*)'HVD: t19   = ',t19
c     write(0,*)'HVD: t6x1  = ',-t6*x1
c     write(0,*)'HVD: total = ',t19+t18+t17+t16+t15-t6*x1
cDEBUG
      t21 = exp(t19+t18+t17+t16+t15-t6*x1)
      h = t8*t13*t14*exp(t19+t18+t17+t16+t15)+h
      dhdr1 = (t2-t3)*t4**t20*t13*t14*t21+dhdr1
      dhdr2 = t8*(t10-t11)*t12**t20*t14*t21+dhdr2
      end subroutine wfn1_thimble_010
c
c-----------------------------------------------------------------------
c
      subroutine wfn1_thimble_011(r1,r2,de_hf,de,x1,x2,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in Hartree-Fock orbital energy
      double precision, intent(in)  :: de_hf
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x1
      double precision, intent(in)  :: x2
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      double precision, external :: signum
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = log(t1)
      t3 = log(r1)
      t4 = (-r1*t3)-t2*t1
      t5 = abs(de)
      t6 = t5**x2
      t7 = exp(-t6*x1)
      t8 = t4**t7
      t9 = 1.0d+0-r2
      t10 = log(t9)
      t11 = log(r2)
      t12 = (-r2*t11)-t10*t9
      t13 = t12**t7
      t14 = 1.4426950408889633d+0**(2*t7)
      t15 = abs(abs(de_hf)-t5)
      t16 = -t15**y1*signum(z1)*abs(z1)**y1
      t17 = -t15**y2*signum(z2)*abs(z2)**y2
      t18 = -t15**y3*signum(z3)*abs(z3)**y3
      t19 = -t15**y4*signum(z4)*abs(z4)**y4
      t20 = -t15**y5*signum(z5)*abs(z5)**y5
      t21 = t7-1
      t22 = exp(t20+t19+t18+t17+t16-t6*x1)
c
      h = t8*t13*t14*exp(t20+t19+t18+t17+t16)+h
      dhdr1 = (t2-t3)*t4**t21*t13*t14*t22+dhdr1
      dhdr2 = t8*(t10-t11)*t12**t21*t14*t22+dhdr2
c
      end subroutine wfn1_thimble_011
c
c-----------------------------------------------------------------------
c
      subroutine wfn1_thimble(r1,r2,de_hf,de,x1,x2,
     &                        ye1,ye2,ye3,ye4,ye5,
     &                        ze1,ze2,ze3,ze4,ze5,
     &                        yh1,yh2,yh3,yh4,yh5,
     &                        zh1,zh2,zh3,zh4,zh5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in Hartree-Fock orbital energy
      double precision, intent(in)  :: de_hf
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x1
      double precision, intent(in)  :: x2
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: ye1, ye2, ye3, ye4, ye5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: ze1, ze2, ze3, ze4, ze5
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: yh1, yh2, yh3, yh4, yh5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: zh1, zh2, zh3, zh4, zh5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      double precision, external :: signum
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = log(t1)
      t3 = log(r1)
      t4 = (-r1*t3)-t2*t1
      t5 = t4**x1
      t6 = 1.0d+0-r2
      t7 = log(t6)
      t8 = log(r2)
      t9 = (-r2*t8)-t7*t6
      t10 = t9**x1
      t11 = 1.4426950408889633d+0**(2*x1)
      t12 = abs(de)
      t13 = (t12**ye5*signum(ze5)*abs(ze5)**ye5+t12**ye4*signum(ze4)*a
     1   bs(ze4)**ye4+t12**ye3*signum(ze3)*abs(ze3)**ye3+t12**ye2*signum
     2   (ze2)*abs(ze2)**ye2+t12**ye1*signum(ze1)*abs(ze1)**ye1+1.0d+0)
      t13 = 1.0d0/t13
      t14 = abs(de_hf)
      t15 = t14**yh5*signum(zh5)*abs(zh5)**yh5+t14**yh4*signum(zh4)*abs(
     1   zh4)**yh4+t14**yh3*signum(zh3)*abs(zh3)**yh3+t14**yh2*signum(zh
     2   2)*abs(zh2)**yh2+t14**yh1*signum(zh1)*abs(zh1)**yh1+1.0d+0
      t16 = x1-1
c
      h = t5*t10*t11*t13*t15+h
      dhdr1 = (t2-t3)*t4**t16*t10*x1*t11*t13*t15+dhdr1
      dhdr2 = t5*(t7-t8)*t9**t16*x1*t11*t13*t15+dhdr2
c
      end subroutine wfn1_thimble
c
c-----------------------------------------------------------------------
