#!/bin/bash
# 
declare -a LIST_MPIFWRAP
LIST_MPIFWRAP=( 'mpiifort' 'mpifc' 'mpixlf_r' 'mpixlf' 'mpif90' 'mpif77' )
export LIST_MPIFWRAP
declare -a LIST_MPICWRAP
LIST_MPICWRAP=( 'mpiicc' 'mpixlc_r' 'mpixlc' 'mpigcc' 'mpicc' )
export LIST_MPICWRAP
function get_mpi_fortran_wrapper()
{
   # Apparently it is too easy to call the MPI Fortran compiler wrapper mpif90.
   # So now there is a variety of such scripts which may or may not be available
   # on your machine. This function tries to find a Fortran compiler wrapper
   # from a given list and returns the first one it finds.
   lib=""
   length=${#LIST_MPIFWRAP[*]}
   indx=0
   while [ "${indx}" -lt "${length}" ] ; do
     candidate="${LIST_MPIFWRAP[${indx}]}"
     ((indx++))
     if [ ${#wrapper} -eq 0 ] ; then
       wrapper=`which ${candidate} 2> /dev/null`
     fi
   done
   if [ ${#wrapper} -eq 0 ] ; then
     # We have not found anything suitable
     echo ${wrapper}
     return 1
   fi
   echo ${wrapper}
}
function get_mpi_include ()
{
   # This shell function extracts the MPI include file directories
   # and returns them as a list for a compile line.
   # E.g.: /usr/include -I/usr/local/include
   #
   # Most support -show
   #
   inlist="`${NWCHEM_MPIF_WRAP} -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`${NWCHEM_MPIF_WRAP} -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`${NWCHEM_MPIF_WRAP} -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from ${NWCHEM_MPIF_WRAP}" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-I*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -I*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_link ()
{
   # This shell function extracts the MPI library file directories
   # and returns them as a list for a link line.
   # E.g.: /usr/lib -L/usr/local/lib
   #
   # most support -show
   #
   inlist="`${NWCHEM_MPIF_WRAP} -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`${NWCHEM_MPIF_WRAP} -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # Otherwise try -link-info
     #
     inlist="`${NWCHEM_MPIF_WRAP} -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get link info from ${NWCHEM_MPIF_WRAP}" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-L*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -L*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_lib ()
{
   # This shell function extracts the MPI libraries
   # and returns them as a list for a link line.
   # E.g.: -lmpich
   #
   # Most support -show
   #
   inlist="`${NWCHEM_MPIF_WRAP} -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`${NWCHEM_MPIF_WRAP} -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`${NWCHEM_MPIF_WRAP} -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get library info from ${NWCHEM_MPIF_WRAP}" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-l*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   echo ${outlist}
}
function get_mpi_fortran ()
{
   # This shell function extracts the fortran compiler
   # and returns its name as a list for a compile line.
   # E.g.: gfortran
   #
   # Most support -show
   #
   inlist="`${NWCHEM_MPIF_WRAP} -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`${NWCHEM_MPIF_WRAP} -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`${NWCHEM_MPIF_WRAP} -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from ${NWCHEM_MPIF_WRAP}" > /dev/stderr
     exit 1
   fi
   outlist=""
   length=${#LIST_COMPFLAGS[*]}
   for word in ${inlist} ; do
      echo "c23456 test program">/tmp/$$.f
      echo "       program test">>/tmp/$$.f
      echo "       write(6,'(\"hello world\")')">>/tmp/$$.f
      echo "       end">>/tmp/$$.f
      word=`basename ${word}`
      indx=0
      while [ "${indx}" -lt "${length}" ] ; do
         flags=${LIST_COMPFLAGS[$indx]}
         ((indx++))
         ${word} ${flags} -o /tmp/$$.x /tmp/$$.f
         result=$?
         if [ ${result} -eq 0 ] ; then
           /tmp/$$.x > /dev/null
           result=$?
           if [ ${result} -eq 0 ] ; then
             echo ${word}
             rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.f
             return 0
           fi
         fi
      done
   done
   rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.f
   echo "ERROR: could not find a valid Fortran compiler" > /dev/stderr
   exit 1
}
#
# Decide what we need to do here
#
option=$1
if [ "$option" == "help" ] ; then
  usage
  exit 1
elif [ "$option" == "" ] ; then
  echo > /dev/null
elif [ "$option" == "realclean" ] ; then
  echo > /dev/null
#elif [ "$option" == "python" ] ; then
#  echo > /dev/null
#elif [ "$option" == "python64" ] ; then
#  echo > /dev/null
else
  usage
  exit 1
fi
#
# Check whether NWCHEM_TOP is set to something sensible...
#
if [ ${#NWCHEM_MPIF_WRAP} -eq 0 ] ; then
  NWCHEM_MPIF_WRAP=`get_mpi_fortran_wrapper`
  if [ $? -ne 0 ] ; then
    unset NWCHEM_MPIF_WRAP
  fi
fi
#
if [ ${#MPI_INCLUDE} -eq 0 ] ; then
  MPI_INCLUDE=`get_mpi_include`
  if [ $? -ne 0 ] ; then
    unset MPI_INCLUDE
  fi
fi
if [ ${#MPI_LIB} -eq 0 ] ; then
  MPI_LIB=`get_mpi_link`
  if [ $? -ne 0 ] ; then
    unset MPI_LIB
  fi
fi
if [ ${#LIBMPI} -eq 0 ] ; then
  LIBMPI=`get_mpi_lib`
  if [ $? -ne 0 ] ; then
    unset LIBMPI
  fi
fi
export MPI_INCLUDE
export MPI_LIB
export LIBMPI
#
# If USE_MPI is not set at this stage do one more test to see if we have MPI.
# If we have MPI set USE_MPI to "y" otherwise leave USE_MPI as is.
# This is a catch all approach needed in case USE_MPI was not set but e.g.
# ARMCI_NETWORK is. In that case ARMCI_NETWORK is not going to be detected and
# associated USE_MPI initialization will not happen either. Therefore we need
# to test USE_MPI separately (as opposed to conditionally on other settings).
#
if [ ${#USE_MPI} -eq 0 ] ; then
  echo "#include <mpi.h>" > /tmp/$$.c
  echo "int main(int argc, char *argv[]){" >> /tmp/$$.c
  echo "   MPI_Init(&argc,&argv);" >> /tmp/$$.c
  echo "   MPI_Finalize();" >> /tmp/$$.c
  echo "}" >> /tmp/$$.c
  mpicc -o /tmp/$$.x /tmp/$$.c
  if [ $? -eq 0 ] ; then
    export USE_MPI=y
  fi
  rm -f /tmp/$$.x /tmp/$$.c
fi
echo "MPI_INCLUDE   =" ${MPI_INCLUDE}
#
echo "MPI_LIB       =" ${MPI_LIB}
#
echo "LIBMPI        =" ${LIBMPI}
#
