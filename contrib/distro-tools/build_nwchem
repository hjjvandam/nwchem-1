#!/bin/bash
#
# Build NWChem
# ============
#
# This script compiles a statically linked executable of NWChem
# with the gcc and gfortran compilers. This script expects to run
# in the top level NWChem directory (i.e. above src).
#
# The script takes at most one argument. This way you can use to
# build NWChem by simply invoking 
#
#    ./contrib/distro-tools/build_nwchem
#
# and similarly clean everything up by invoking
#
#    ./contrib/distro-tools/build_nwchem realclean
#
# Other builds can be generated by changing the compiler options and
# the environment variables as needed.
#
# The main advantages of this script are:
# 1. That you have a record of exactly how you compiled a binary.
# 2. You don't need any environment variables set in your general user
#    environment, allowing you full flexibility to switch between
#    different builds in different directories without getting caught
#    out by variable settings you forgot about.
#
function get_mpi_include ()
{
   # This shell function extracts the MPI include file directories
   # and returns them as a list for a compile line.
   # E.g.: /usr/include -I/usr/local/include
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpif90 -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-I*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -I*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_link ()
{
   # This shell function extracts the MPI library file directories
   # and returns them as a list for a link line.
   # E.g.: /usr/lib -L/usr/local/lib
   #
   # MPICH2 and MVAPICH2 support -link-info
   #
   inlist="`mpif90 -link-info`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # HPMPI supports -show
     #
     inlist="`mpif90 -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get link info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-L*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -L*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_lib ()
{
   # This shell function extracts the MPI libraries
   # and returns them as a list for a link line.
   # E.g.: -lmpich
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`mpif90 -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get library info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-l*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   echo ${outlist}
}
function get_mpi_fortran ()
{
   # This shell function extracts the fortran compiler
   # and returns its name as a list for a compile line.
   # E.g.: gfortran
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpif90 -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "c23456 test program">/tmp/$$.f
      echo "       program test">>/tmp/$$.f
      echo "       write(6,'(\"hello world\")')">>/tmp/$$.f
      echo "       end">>/tmp/$$.f
      ${word} -o /tmp/$$.x /tmp/$$.f
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.f
   done
   echo "ERROR: could not find a valid Fortran compiler" > /dev/stderr
   exit 1
}
function get_mpi_cc ()
{
   # This shell function extracts the C compiler
   # and returns its name as a list for a compile line.
   # E.g.: gcc
   #
   # Most support -show
   #
   inlist="`mpicc -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpicc -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpicc -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpicc" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "#include <stdio.h>">/tmp/$$.c
      echo "int main(void){">>/tmp/$$.c
      echo "    printf(\"hello world\n\");">>/tmp/$$.c
      echo "    return 0;">>/tmp/$$.c
      echo "}">>/tmp/$$.c
      ${word} -o /tmp/$$.x /tmp/$$.c
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.c
   done
   echo "ERROR: could not find a valid C compiler" > /dev/stderr
   exit 1
}
function get_mpi_cxx ()
{
   # This shell function extracts the C++ compiler
   # and returns its name as a list for a compile line.
   # E.g.: g++
   #
   # Most support -show
   #
   inlist="`mpiCC -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpiCC -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpiCC -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpiCC" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "#include <iostream>">/tmp/$$.cpp
      echo "int main(void) {">>/tmp/$$.cpp
      echo "    std::cout << \"hello world\n\";">>/tmp/$$.cpp
      echo "    return 0;">>/tmp/$$.cpp
      echo "}">>/tmp/$$.cpp
      ${word} -o /tmp/$$.x /tmp/$$.cpp
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.cpp
   done
   echo "ERROR: could not find a valid C++ compiler" > /dev/stderr
   exit 1
}
function get_config_value()
{
   # This function extracts the value of a setting in config.status.
   # The approach is to simply grep the key on the config.status file.
   # We expect to get 1 line in response, and we return whatever appears
   # after the equals sign.
   key=$1
   line=`grep $key ${NWCHEM_TOP}/src/tools/build/config.status`
   line=${line/*=/}
   line=${line/#\"/}
   line=${line/%\"/}
   echo ${line}
}
function config_is_set()
{
   # This function retrieves the value of a seting in config.status according
   # to the key specified. It then checks the length of the result. If
   # the result was "" (length <= 0) then it was not set, otherwise it is.
   key=$1
   result=`get_config_value $key`
   if [ ${#result} -gt 0 ] ; then
     value=0
   else
     value=1
   fi
   echo ${value}
}
#
# See if we can detect which platform we are on.
# This is most relevant to the various BlueGene platforms as they are a complete
# package, i.e. if you know you are on a BlueGene/P then all required settings
# are prescribed. This is not the case on other platforms.
#
if [ -d /bgsys/drivers/ppcfloor ] ; then
  #
  # This is a BlueGene/P machine
  #
  if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
    export NWCHEM_TARGET=BGP
  fi
  if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
    export ARMCI_NETWORK=DCMFMPI
  fi
  if [ ${#MSG_COMMS} -eq 0 ] ; then
    export MSG_COMMS=DCMFMPI
  fi
  if [ ${#USE_MPI} -eq 0 ] ; then
    export USE_MPI=y
  fi
  if [ ${#BGCOMPILERS} -eq 0 ] ; then
    export BGCOMPILERS=/bgsys/drivers/ppcfloor/gnu-linux/bin
  fi
  if [ ${#BGP_INSTALLDIR} -eq 0 ] ; then
    export BGP_INSTALLDIR=/bgsys/drivers/ppcfloor
  fi
  if [ ${#BGP_RUNTIMEPATH} -eq 0 ] ; then
    export BGP_RUNTIMEPATH=/bgsys/drivers/ppcfloor/runtime
  fi
  if [ ${#ARMCIDRV} -eq 0 ] ; then
    export ARMCIDRV=${BGP_INSTALLDIR}
  fi
  if [ ${#BGDRIVER} -eq 0 ] ; then
    export BGDRIVER=${ARMCIDRV}
  fi
  if [ ${#MPI_LIB} -eq 0 ] ; then
    export MPI_LIB=${BGDRIVER}/comm/lib
  fi
  if [ ${#MPI_INCLUDE} -eq 0 ] ; then
    export MPI_INCLUDE=${BGDRIVER}/comm/include
  fi
  if [ ${#BGMLMPI_INCLUDE} -eq 0 ] ; then
    export BGMLMPI_INCLUDE=${MPI_INCLUDE}
  fi
  if [ ${#LIBMPI} -eq 0 ] ; then
    export LIBMPI="-L${MPI_LIB} -lfmpich_.cnk -lmpich.cnk -ldcmf.cnk -ldcmfcoll.cnk -lpthread -lrt -L${BGP_RUNTIMEPATH}/SPI -lSPI.cna"
  fi
  if [ ${#MPI_F90} -eq 0 ] ; then
    export MPI_F90=mpixlf77
  fi
  if [ ${#MPI_CC} -eq 0 ] ; then
    export MPI_CC=mpixlc
  fi
  if [ ${#MPI_CXX} -eq 0 ] ; then
    export MPI_CXX=mpixlcxx
  fi

fi
#
# End of BlueGene stuff
#
if [ ${#NWCHEM_TOP} -eq 0 ] ; then
  export NWCHEM_TOP=`pwd`
fi
if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
  export NWCHEM_TARGET=LINUX64
fi
if [ ${#NWCHEM_MODULES} -eq 0 ] ; then
  export NWCHEM_MODULES="all"
fi
if [ ${#NWCHEM_EXECUTABLE} -eq 0 ] ; then
  export NWCHEM_EXECUTABLE=$NWCHEM_TOP/bin/$NWCHEM_TARGET/nwchem
fi
if [ ${#USE_MPI} -eq 0 ] ; then
  export USE_MPI=y
fi
if [ ${#USE_MPI} -ne 0 ] ; then
  if [ ${#USE_MPIF} -eq 0 ] ; then
    export USE_MPIF=y
  fi
  if [ ${#USE_MPIF4} -eq 0 ] ; then
    export USE_MPIF4=y
  fi
fi
if [ ${#MSG_COMMS} -eq 0 ] ; then
  export MSG_COMMS=MPI
fi
export LDOPTIONS=" "
export USE_SUBGROUPS=y
#export DEV_GA=y
#export USE_GPROF=y
#
# Now we try and guess the network on the machine.
# The default is sockets.
#
if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
  if [ -d /dev/infiniband ] ; then
    # There seems to be an infiniband network on this machine
    export ARMCI_NETWORK="OPENIB"
    export LIBMPI="${LIBMPI} -libverbs"
    if [ -d /usr/include/infiniband ] ; then
      export IB_INCLUDE="/usr/include/infiniband"
    else
      echo "ERROR: Infiniband include files not in expected location"
      exit 1
    fi
  fi
fi
if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
  #
  # This test is stolen from GASNET
  # /dev/ukbride present then we are probably on a Cray XT machine
  # /proc/portals/meminfo present then this machine has Cray Portals
  #
  if [ -f /proc/portals/meminfo ] ; then
    # There seems to be a portals infrastructure on this machine
    export ARMCI_NETWORK="PORTALS"
  fi
fi
#if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
#  export ARMCI_NETWORK="MPI-MT"
#fi
#
# Below we have to realize that EXPORT is a command. Hence if we use
#   EXPORT DUMMY=`ls`
#   status=$?
# then status will be set to the exit code of the EXPORT command. If we
# want the exit code from the ls command we need to write
#   DUMMY=`ls`
#   status=$?
#   EXPORT DUMMY
#
if [ ${#MPI_INCLUDE} -eq 0 ] ; then
  MPI_INCLUDE=`get_mpi_include`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
if [ ${#MPI_LIB} -eq 0 ] ; then
  MPI_LIB=`get_mpi_link`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
if [ ${#LIBMPI} -eq 0 ] ; then
  LIBMPI=`get_mpi_lib`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
if [ ${#MPI_F90} -eq 0 ] ; then
  MPI_F90=`get_mpi_fortran`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
if [ ${#MPI_CC} -eq 0 ] ; then
  MPI_CC=`get_mpi_cc`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
if [ ${#MPI_CXX} -eq 0 ] ; then
  MPI_CXX=`get_mpi_cxx`
  if [ $? -ne 0 ] ; then
    exit 1
  fi
fi
export MPI_INCLUDE
export MPI_LIB
export LIBMPI
option=$1
if [ "x$1" == "xpython" ]; then
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
elif [ "x$1" == "xpython64" ]; then
  export USE_PYTHON64=yes
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
else
  echo "Building NWChem"
  echo "==============="
  echo
fi
echo "MPI_INCLUDE   =" ${MPI_INCLUDE}
echo "MPI_LIB       =" ${MPI_LIB}
echo "LIBMPI        =" ${LIBMPI}
echo "MPI_F90       =" ${MPI_F90}
echo "MPI_CC        =" ${MPI_CC}
echo "MPI_CXX       =" ${MPI_CXX}
echo "ARMCI_NETWORK =" ${ARMCI_NETWORK}
if [ ${#IB_INCLUDE} -ne 0 ] ; then
  echo "IB_INCLUDE    =" ${IB_INCLUDE}
fi
cd $NWCHEM_TOP/src
echo "=== configure GA ==="
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" configure_ga
  #
  # Extract information about BLAS libraries from the GA config.status file
  #
  have_blas_false=`get_config_value "HAVE_BLAS_FALSE"`
  have_blas_true=`get_config_value "HAVE_BLAS_TRUE"`
  if [ "x${have_blas_true}" == "x" ] ; then
    if [ "x${have_blas_false}" == "x#" ] ; then
      # The GA found some BLAS library, set GA_BLAS accordingly
      GA_BLAS=`get_config_value "BLAS_LDFLAGS"`
      GA_BLAS="${GA_BLAS} `get_config_value \"BLAS_LIBS\"`"
      GA_BLAS_SIZE=`get_config_value "BLAS_SIZE"`
      export GA_BLAS
      if [ "${GA_BLAS_SIZE}" == "4" ] ; then
        export USE_64TO32=y
      else
        unset USE_64TO32
      fi
      echo "Found BLAS " ${GA_BLAS}
      echo "Found BLAS type: integer*"${GA_BLAS_SIZE}
    else
      # Confused
      echo "ERROR: A: inconsistent data on presence of BLAS library"
      echo "have_blas_true  = " ${have_blas_true}
      echo "have_blas_false = " ${have_blas_false}
      exit 1
    fi
  elif [ "x${have_blas_true}" == "x#" ] ; then
    if [ "x${have_blas_false}" == "x" ] ; then
      # The GA found no BLAS library, unset GA_BLAS to maintain consistency
      unset GA_BLAS
      echo "Found no BLAS "
    else
      # Confused
      echo "ERROR: B: inconsistent data on presence of BLAS library"
      echo "have_blas_true  = " ${have_blas_true}
      echo "have_blas_false = " ${have_blas_false}
      exit 1
    fi
  else
    echo "ERROR: C: invalid settings" 
    echo "have_blas_true  = " ${have_blas_true}
    echo "have_blas_false = " ${have_blas_false}
    exit 1
  fi
fi
if [ ${#BLASOPT} -eq 0 ] ; then
  if [ ${#GA_BLAS} -ne 0 ] ; then
    export BLASOPT=${GA_BLAS}
  fi
fi
echo "=== configure NWChem ==="
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" nwchem_config
fi
cd $NWCHEM_TOP/src/util
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" version
fi
cd $NWCHEM_TOP/src
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
cd $NWCHEM_TOP/contrib/mov2asc
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
