#!/bin/bash
#
# Build NWChem
# ============
#
# This script compiles a statically linked executable of NWChem
# with the gcc and gfortran compilers. This script expects to run
# in the top level NWChem directory (i.e. above src).
#
# The script takes at most one argument. This way you can use to
# build NWChem by simply invoking 
#
#    ./contrib/distro-tools/build_nwchem
#
# and similarly clean everything up by invoking
#
#    ./contrib/distro-tools/build_nwchem realclean
#
# Other builds can be generated by changing the compiler options and
# the environment variables as needed.
#
# The main advantages of this script are:
# 1. That you have a record of exactly how you compiled a binary.
# 2. You don't need any environment variables set in your general user
#    environment, allowing you full flexibility to switch between
#    different builds in different directories without getting caught
#    out by variable settings you forgot about.
#
function get_mpi_include ()
{
   # This shell function extracts the MPI include file directories
   # and returns them as a list for a compile line.
   # E.g.: /usr/include -I/usr/local/include
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpif90 -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-I*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   len=`expr "${outlist}" : ' -I*'`
   if [ ${len} -ge 3 ] ; then
     outlist="${outlist:3}"
   fi
   echo ${outlist}
}
function get_mpi_link ()
{
   # This shell function extracts the MPI library file directories
   # and returns them as a list for a link line.
   # E.g.: /usr/lib -L/usr/local/lib
   #
   # MPICH2 and MVAPICH2 support -link-info
   #
   inlist="`mpif90 -link-info`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # HPMPI supports -show
     #
     inlist="`mpif90 -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get link info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-L*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   len=`expr "${outlist}" : ' -L*'`
   if [ ${len} -ge 3 ] ; then
     outlist="${outlist:3}"
   fi
   echo ${outlist}
}
function get_mpi_lib ()
{
   # This shell function extracts the MPI libraries
   # and returns them as a list for a link line.
   # E.g.: -lmpich
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`mpif90 -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get library info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-l*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   echo ${outlist}
}
function get_mpi_fortran ()
{
   # This shell function extracts the fortran compiler
   # and returns its name as a list for a compile line.
   # E.g.: gfortran
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpif90 -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "c23456 test program">/tmp/$$.f
      echo "       program test">>/tmp/$$.f
      echo "       write(6,'(\"hello world\")')">>/tmp/$$.f
      echo "       end">>/tmp/$$.f
      ${word} -o /tmp/$$.x /tmp/$$.f
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.f
   done
   echo "ERROR: could not find a valid Fortran compiler" > /dev/stderr
   exit 1
}
function get_mpi_cc ()
{
   # This shell function extracts the C compiler
   # and returns its name as a list for a compile line.
   # E.g.: gcc
   #
   # Most support -show
   #
   inlist="`mpicc -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpicc -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpicc -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpicc" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "#include <stdio.h>">/tmp/$$.c
      echo "int main(void){">>/tmp/$$.c
      echo "    printf(\"hello world\n\");">>/tmp/$$.c
      echo "    return 0;">>/tmp/$$.c
      echo "}">>/tmp/$$.c
      ${word} -o /tmp/$$.x /tmp/$$.c
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.c
   done
   echo "ERROR: could not find a valid C compiler" > /dev/stderr
   exit 1
}
function get_mpi_cxx ()
{
   # This shell function extracts the C++ compiler
   # and returns its name as a list for a compile line.
   # E.g.: g++
   #
   # Most support -show
   #
   inlist="`mpiCC -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpiCC -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpiCC -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpicxx -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpiCC" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      echo "#include <iostream>">/tmp/$$.cpp
      echo "int main(void) {">>/tmp/$$.cpp
      echo "    std::cout << \"hello world\n\";">>/tmp/$$.cpp
      echo "    return 0;">>/tmp/$$.cpp
      echo "}">>/tmp/$$.cpp
      ${word} -o /tmp/$$.x /tmp/$$.cpp
      result=$?
      if [ ${result} -eq 0 ] ; then
        /tmp/$$.x > /dev/null
        result=$?
        if [ ${result} -eq 0 ] ; then
          echo ${word}
          return 0
        fi
      fi
      rm -f /tmp/$$.x /tmp/$$.cpp
   done
   echo "ERROR: could not find a valid C++ compiler" > /dev/stderr
   exit 1
}
function get_config_value()
{
   # This function extracts the value of a setting in config.status.
   # The approach is to simply grep the key on the config.status file.
   # We expect to get 1 line in response, and we return whatever appears
   # after the equals sign.
   key=$1
   line=`grep $key ${NWCHEM_TOP}/src/tools/build/config.status`
   line=${line/*=/}
   line=${line/#\"/}
   line=${line/%\"/}
   echo ${line}
}
function config_is_set()
{
   # This function retrieves the value of a seting in config.status according
   # to the key specified. It then checks the length of the result. If
   # the result was "" (length <= 0) then it was not set, otherwise it is.
   key=$1
   result=`get_config_value $key`
   if [ ${#result} -gt 0 ] ; then
     value=0
   else
     value=1
   fi
   echo ${value}
}
export NWCHEM_TOP=`pwd`
export NWCHEM_TARGET=LINUX64
export NWCHEM_MODULES="all"
export NWCHEM_EXECUTABLE=$NWCHEM_TOP/bin/LINUX64/nwchem
export LDOPTIONS=" "
export USE_SUBGROUPS=y
export USE_MPI=y
export USE_MPIF=y
export USE_MPIF4=y
export MSG_COMMS=MPI
#
# Now we try and guess the network on the machine.
# The default is sockets.
#
if [ -d /dev/infiniband ] ; then
  # There seems to be an infiniband network on this machine
  export ARMCI_NETWORK="OPENIB"
  export LIBMPI="${LIBMPI} -libverbs"
  if [ -d /usr/include/infiniband ] ; then
    export IB_INCLUDE="/usr/include/infiniband"
  else
    echo "ERROR: Infiniband include files not in expected location"
    exit 1
  fi
fi
#
# Below we have to realize that EXPORT is a command. Hence if we use
#   EXPORT DUMMY=`ls`
#   status=$?
# then status will be set to the exit code of the EXPORT command. If we
# want the exit code from the ls command we need to write
#   DUMMY=`ls`
#   status=$?
#   EXPORT DUMMY
#
MPI_INCLUDE=`get_mpi_include`
if [ $? -ne 0 ] ; then
  exit 1
fi
MPI_LIB=`get_mpi_link`
if [ $? -ne 0 ] ; then
  exit 1
fi
LIBMPI=`get_mpi_lib`
if [ $? -ne 0 ] ; then
  exit 1
fi
MPI_F90=`get_mpi_fortran`
if [ $? -ne 0 ] ; then
  exit 1
fi
MPI_CC=`get_mpi_cc`
if [ $? -ne 0 ] ; then
  exit 1
fi
MPI_CXX=`get_mpi_cxx`
if [ $? -ne 0 ] ; then
  exit 1
fi
export MPI_INCLUDE
export MPI_LIB
export LIBMPI
option=$1
if [ "x$1" == "xpython" ]; then
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
elif [ "x$1" == "xpython64" ]; then
  export USE_PYTHON64=yes
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
else
  echo "Building NWChem"
  echo "==============="
  echo
fi
echo "MPI_INCLUDE   =" ${MPI_INCLUDE}
echo "MPI_LIB       =" ${MPI_LIB}
echo "LIBMPI        =" ${LIBMPI}
echo "MPI_F90       =" ${MPI_F90}
echo "MPI_CC        =" ${MPI_CC}
echo "MPI_CXX       =" ${MPI_CXX}
echo "ARMCI_NETWORK =" ${ARMCI_NETWORK}
if [ ${#IB_INCLUDE} -ne 0 ] ; then
  echo "IB_INCLUDE    =" ${IB_INCLUDE}
fi
cd $NWCHEM_TOP/src
echo "=== configure GA ==="
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" configure_ga
  #
  # Extract information about BLAS libraries from the GA config.status file
  #
  have_blas_false=`get_config_value "HAVE_BLAS_FALSE"`
  have_blas_true=`get_config_value "HAVE_BLAS_TRUE"`
  if [ "x${have_blas_true}" == "x" ] ; then
    if [ "x${have_blas_false}" == "x#" ] ; then
      # The GA found some BLAS library, set GA_BLAS accordingly
      GA_BLAS=`get_config_value "BLAS_LDFLAGS"`
      GA_BLAS="${GA_BLAS} `get_config_value \"BLAS_LIBS\"`"
      export GA_BLAS
      echo "Found BLAS " ${GA_BLAS}
    else
      # Confused
      echo "ERROR: A: inconsistent data on presence of BLAS library"
      exit 1
    fi
  elif [ "x${have_blas_true}" == "x#" ] ; then
    if [ "x${have_blas_false}" == "x" ] ; then
      # The GA found no BLAS library, unset GA_BLAS to maintain consistency
      unset GA_BLAS
      echo "Found no BLAS "
    else
      # Confused
      echo "ERROR: B: inconsistent data on presence of BLAS library"
      exit 1
    fi
  else
    echo "ERROR: C: invalid settings" ${have_blas_true} ${have_blas_false}
    exit 1
  fi
fi
if [ ${#BLASOPT} -eq 0 ] ; then
  if [ ${#GA_BLAS} -ne 0 ] ; then
    export BLASOPT=${GA_BLAS}
  fi
fi
echo "=== configure NWChem ==="
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" nwchem_config
fi
cd $NWCHEM_TOP/src/util
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" version
fi
cd $NWCHEM_TOP/src
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
cd $NWCHEM_TOP/contrib/mov2asc
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
