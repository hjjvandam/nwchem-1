\label{sec:print}

All modules should use the same print control mechanism to provide
both uniformity and flexibility.  The routines in \verb+util_print+ do
this.  By using these routines

\begin{enumerate}
\item All modules understand the print levels
\begin{itemize}
\item \verb+none+
\item \verb+low+
\item \verb+medium+ = \verb+default+
\item \verb+high+
\item \verb+debug+
\end{itemize}
\verb+None+ is defined to mean literally no output except for
catastrophic errors (e.g., inconsistent data, failure to converge).
\item Printing of specific quantities may be directly enabled or
  disabled from the input using already existing input routines
\item Modules operate independently and printing will eventually be
   controllable via context
\end{enumerate}

This is an example of how it currently works. Inside the SCF input
\begin{verbatim}
  print low basis "final eigenvectors"
  noprint title
\end{verbatim}
This sets the overall SCF printlevel to low, forces printing of the
final eigenvectors and basis, and disables printing of the title.

The implementation is very simple.  Each module defines (using
provided input routines) one or two entries in the database which
enable/disable printing
\begin{itemize}
\item \verb+<module>:print+ --- list of names to enable print
\item \verb+<module>:noprint+ --- list of names to disable print
\end{itemize}
The special values ({\tt none}, {\tt low}, \ldots) are recognized in
the list of print keywords and are used to adjust the print level.
The parsing of this list is encapsulated in the routine
\verb+util_print_rtdb_load()+.  To support multiply nested modules a
stack of print options is maintained --- this will eventually be
combined with the mythical context.

\sloppy
The code necessary for a module using print control is then simply:
\begin{itemize}
\item In the input routine, upon detecting a line with either the print
  or noprint directive
\begin{verbatim}
     call util_print_input(rtdb, 'module_name')
\end{verbatim}
\item At the beginning of a module
\begin{verbatim}
     call util_print_push 
     call util_print_rtdb_load(rtdb, 'module_name')
\end{verbatim}
  \verb+util_print_push()+ sets the default printlevel for a new
  module. \verb+util_print_rtdb_load+ reads in any input parameters
\item To control printing within a module
\begin{verbatim}
     #include "util.fh"

     if (util_print("name", level)) then
       write out data associated with "name"
     endif
\end{verbatim}
  Level is one of the prespecified print levels (\verb+print_none+,
  \verb+print_low+, \ldots; see \verb+util/printlevels.fh+ for
  actual values).
\item At the end of a module
\begin{verbatim}
     call util_print_pop
\end{verbatim}
\end{itemize}

\fussy

 E.g.
\begin{verbatim}
#include "util.fh"

      call util_print_push
      call util_print_rtdb_load('scf')
      if (util_print('information', print_low)) then
         write(6,*) ...
      endif
      ...
      call util_print_pop
\end{verbatim}

 If an application wants more direct control over printing there are
routines to explicitly control the print level and to enable/disable
printing of named items.

{\tt util.fh} has been modified to define the integers
\begin{itemize}
\item \verb+print_none+ (use of this as an argument for
  \verb+util_print+ will force printing even if none is asked for!)
\item \verb+print_low+
\item \verb+print_medium+
\item \verb+print_high+
\item \verb+print_debug+
\item \verb+print_never+
\item \verb+print_default+ = \verb+print_medium+
\end{itemize}
and to declare \verb+util_print+ as an external logical valued function.

Other relevant routines are

\section{{\tt util\_print}}
\sloppy
\begin{verbatim}
  logical function util_print(level, name)
  integer level        [input]
  character*(*) name   [input]
\end{verbatim}
If \verb+level+ is less than or equal to the current print level
(which is set by either \verb+util_print_rtdb_load+, or
\verb+util_print_set_level+), or the printing of \verb+name+ was
explicitly enabled, and the printing of \verb+name+ has not been
explicitly disabled, then \TRUE is returned.  Otherwise
\FALSE is returned.

\fussy

\section{{\tt util\_print\_input}}
\begin{verbatim}
    subroutine util_print_input(rtdb, prefix)
    integer rtdb         [input]
    character*(*) prefix [input]
\end{verbatim}
The input routine of a module should call this routine upon detecting
either the {\tt print} or {\tt noprint} directives.  It should pass
the name of the module in the character string {\tt prefix}.  This is
prepended to actual entries made in the database.

\section{{\tt util\_print\_push}}
\begin{verbatim}
    subroutine util_print_push
\end{verbatim}
Call this routine on entry to a module to push the print stack down.
A call to this routine is usually immediately followed by a call to
\verb+util_print_rtdb_load+. 

\section{{\tt util\_print\_pop}}
\begin{verbatim}
    subroutine util_print_pop
\end{verbatim}
Call this routine immediately before exit from a module to pop the
print stack to the previous context.  Once context is properly
functioning the push/pop routines may disappear.

\section{{\tt util\_print\_rtdb\_load}}
\begin{verbatim}
    subroutine util_print_rtdb_load(rtdb, prefix)
    integer rtdb         [input]
    character*(*) prefix [input]
\end{verbatim}
This routine loads the print information from the database for a
module with name provided in \verb+prefix+.  The value of
\verb+prefix+ must match that provided in the corresponding call to
\verb+util_print_input+.

This routine is usually called at the start of a module immediately
following a call to \verb+util_print_push+.

\section{{\tt util\_print\_set\_level}}
\begin{verbatim}
    subroutine util_print_set_level(level)
    integer level        [input]
\end{verbatim}
Set the print level to {\tt level}.  This routine is rarely called
from applications.

