%
% $Id: int_api_spec.tex,v 1.3 1997-05-29 01:25:56 d3e129 Exp $
%
%-----------------------------------------------------------------%  
%                                                                 % 
%                                                                 % 
%  This latex source file should NOT be edited.  It is generated  % 
%  automatically from the integral API source code using "seetex" % 
%  modifications required sould be made in the source code which  % 
%  is in the source directory ".../nwchem/src/NWints/api" from    % 
%  the standard repository. If you have questions or problems     % 
%  contact Ricky Kendall at ra_kendall@pnl.gov or (509)375-2602   % 
%                                                                 % 
%                                                                 % 
%-----------------------------------------------------------------%  
\chapter{Integral Application Programmer's Interface} 
\label{appendix_intapi} 
This appendix describes the interface to all routines for the NWChem 
integral API. This includes the actual subroutine documentation and 
design specifications. 
 
 
\section{INT-API: Initialization, Integral Accuracy and Termination} 
These routines set the scope for the integral computation that is 
about to be performed.  
% 
 
%API Initialization and Termination Routines 
\subsection{int\_init} 
This is the main initialization routine for integrals. 
Default memory requirements, accuracy thresholds, and other  
initializations for all base integral codes are set here.  
This routine will read (from the rtdb) any integral  
settings changed by the user. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_init(rtdb, nbas, bases) 
\end{verbatim} 
\begin{verbatim} 
      integer rtdb        ! [input] run time data base handle 
      integer nbas        ! [input] number of basis sets to be used 
      integer bases(nbas) ! [input] basis set handles 
\end{verbatim} 
%API Initialization and Termination Routines 
\subsection{intd\_init} 
This is the main initialization routine for integral derivatives. 
Default memory requirements, accuracy thresholds, and other  
initializations for all base integral codes are set here.  
This routine will read (from the rtdb) any integral  
settings changed by the user. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine intd_init(rtdb,nbas,bases) 
\end{verbatim} 
\begin{verbatim} 
      integer rtdb        ! [input] run time data base handle 
      integer nbas        ! [input] number of basis sets to be used 
      integer bases(nbas) ! [input] basis set handles 
\end{verbatim} 
 
%API Initialization and Termination Routines 
\subsection{int\_terminate} 
This is the main termination routine for integrals. 
After this call the INT-API is ready for re-initialization. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_terminate() 
\end{verbatim} 
No formal arguments 
 
 
%API Initialization and Termination Routines 
\subsection{intd\_terminate} 
This is the main termination routine for integral 
derivatives. 
After this call the INT-API is ready for re-initialization. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine intd_terminate() 
\end{verbatim} 
No formal arguments 
 
% part of API Internal Routines 
\subsection{int\_acc\_std} 
This routine sets the integral threshold for radial cutoffs in all  
integral codes used in the api via a parameter statement.  Other 
routines have access via the apiP.fh common blocks and the set/get API. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_acc_std() 
\end{verbatim} 
The default ''standard'' value for the integral accuracy is: 
\begin{verbatim} 
      parameter(val_def = 1.0d-10) 
\end{verbatim} 
% part of API Internal Routines 
\subsection{int\_acc\_high} 
This routine sets the integral threshold to ``high'' accuracy  
for radial cutoffs in all integral codes used in the api via a  
parameter statement.  Other routines have access via the apiP.fh  
common blocks and the set/get API. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_acc_high() 
\end{verbatim} 
The default ''high accuracy'' value for the integral API is: 
\begin{verbatim} 
      parameter (val_def_high = 1.0d-20) 
\end{verbatim} 
This is needed for certain algorithms within NWChem, e.g.,  
the Schwarz inequality screening. 
 
% part of API Internal Routines 
\subsection{int\_acc\_get} 
This routine returns the current integral threshold  
for radial cutoffs in all integral codes used in the api via a  
parameter statement.   
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_acc_get(retval) 
\end{verbatim} 
\begin{verbatim} 
      double precision retval ! [output] current threshold 
\end{verbatim} 
% part of API Internal Routines 
\subsection{int\_acc\_set} 
This routine sets the current integral threshold  
for radial cutoffs in all integral codes used in the api via a  
parameter statement.   
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_acc_set(setval) 
\end{verbatim} 
\begin{verbatim} 
      double precision setval ! [input] new threshold 
\end{verbatim} 
\section{INT-API: Memory Managment Routines} 
These routines compute, store, and return memory requirements for 
particular ``classes'' of integral computations.  These routines are 
``overloaded'' since the application uses the same query function 
whether integrals or integral derivatives are computed.  For example, 
\verb+int_mem_2e4c+ is used to get the maximum buffer size and scratch 
array size for both integrals computed using \verb+int_2e4c+ and 
integral derivatives computed using \verb+intd_2e4c+.  The INT-API is 
also designed such that if you initialize INT-API for integral 
derivatives, the memory estimates are also valid for integrals as 
well.   
% 
 
% This is part of the API Standard Integral routines 
\subsection{int\_mem} 
This routine returns the maximum buffer and scratch array 
sizes for both one electron and two electron (4 center)  
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem(max1e, maxg, mscratch_1e, mscratch_2e) 
\end{verbatim} 
\begin{verbatim} 
      integer max1e       ! [output] max 1e buffer size 
      integer maxg        ! [output] max 2e4c buffer size 
      integer mscratch_1e ! [output] max scr for 1e ints 
      integer mscratch_2e ! [output] max scr for 2e ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_1e} 
This routine returns the maximum buffer and scratch array 
sizes for one electron (2 center) 
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_1e(max1e, mscratch_1e) 
\end{verbatim} 
\begin{verbatim} 
      integer max1e       ! [output] max 1e buffer size 
      integer mscratch_1e ! [output] max scr for 1e ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_2e4c} 
This routine returns the maximum buffer and scratch array 
sizes for two electron (4 center) 
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_2e4c(maxg, mscratch_2e) 
\end{verbatim} 
\begin{verbatim} 
      integer maxg        ! [output] max 2e4c buffer size 
      integer mscratch_2e ! [output] max scr for 2e ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_h1} 
This routine returns the maximum buffer and scratch array 
sizes for one electron hamiltonian  
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_h1(maxh1, mscratch_h1) 
\end{verbatim} 
\begin{verbatim} 
      integer maxh1       ! [output] max buffer size for H1 ints 
      integer mscratch_h1 ! [output] max scr size for H1 ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_2eec} 
This routine returns the maximum buffer and scratch array 
sizes for two electron (3 center) 
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_2e3c(maxg, mscratch_2e3c) 
\end{verbatim} 
\begin{verbatim} 
      integer maxg           ! [output] max buf size for 2e3c ints 
      integer mscratch_2e3c  ! [output] max scr size for 2e3c ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_2e2c} 
This routine returns the maximum buffer and scratch array 
sizes for two electron (2 center) 
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_2e2c(maxg, mscratch_2e2c) 
\end{verbatim} 
\begin{verbatim} 
      integer maxg          ! [output] max buf size for 2e2c ints 
      integer mscratch_2e2c ! [output] max scr size for 2e2c ints 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_3ov} 
This routine returns the maximum buffer and scratch array 
sizes for one electron (3 center) 
integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_3ov(maxbuf, mscratch_3ov) 
\end{verbatim} 
\begin{verbatim} 
      integer maxbuf       ! [output] max buf size for 3 center ov 
      integer mscratch_3ov ! [output] max scr size for 3 center ov 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{int\_mem\_print} 
This routine prints the maximum buffer and scratch array 
sizes for all known ``classes'' of integrals. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_print() 
\end{verbatim} 
% This is part of the API Standard Integral routines 
\subsection{intb\_mem\_2e4c} 
This routine returns the maximum buffer and scratch array 
sizes for two electron (4 center) 
integrals from the blocking interface. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine intb_mem_2e4c(maxg, mscratch_2e) 
\end{verbatim} 
\begin{verbatim} 
      integer maxg        ! [output] max buf size for blocked 2e4c ints 
      integer mscratch_2e ! [output] max scr size for blocked 2e4c ints 
\end{verbatim} 
\section{INT-API: Integral Routines} 
These routines compute and return integrals based on shell quartets 
or groups of shell quartets.   
% 
 
% This is part of the API Standard Integral routines 
\subsection{int\_1cg} 
This routine computes the integral of the one center gaussian. 
\begin{eqnarray*} 
({\mu}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})dr_{1} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1cg(i_basis,ish,lscr,scr,l1g,G1e) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis ! [input] basis set handle 
      integer ish     ! [input] lexical shell/contraction index 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr)  ! [scratch] scratch space  
      integer l1g     ! [input] length of integral buffer array 
      double precision G1e(l1g)   ! [output] one center gaussian integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_1e3ov} 
This routine computes the 3 center overlap integral: 
\begin{eqnarray*} 
({\mu}{\nu}{\lambda}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})g_{\nu}(X_{\nu},r_{1})g_{\lambda}(X_{\lambda},r_{1})dr
_{1} 
\end{eqnarray*} 
{\it Syntax:}  
\begin{verbatim} 
      subroutine int_1e3ov (i_basis, ish, j_basis, jsh, k_basis, ksh, 
     &       lscr, scr, lov3, OV3) 
\end{verbatim} 
\begin{verbatim}  
      integer i_basis            ! [input] basis set handle for ish 
      integer ish                ! [input] i shell/contraction 
      integer j_basis            ! [input] basis set handle for jsh 
      integer jsh                ! [input] j shell/contraction 
      integer k_basis            ! [input] basis set handle for ksh 
      integer ksh                ! [input] k shell/contraction 
      integer lscr               ! [input] length of scratch v 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lov3               ! [input] length of 3c overlap buffer 
      double precision OV3(lov3) ! [output] 3c overlap integrals 
\end{verbatim}  
% this is part of the API Standard Integral routines. 
\subsection{int\_l1e3ov} 
This routine computes the 3 center overlap integral  
with labels and it removes ``zero'' integrals: 
\begin{eqnarray*} 
({\mu}{\nu}{\lambda}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})g_{\nu}(X_{\nu},r_{1}g_{\lambda}(X_{\lambda},r_{1})dr_
{1} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_l1e3ov(i_basis, ish, j_basis, jsh, k_basis, ksh, 
     &       zerotol, lov3, OV3, ilab, jlab, klab, numov3, lscr, scr) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis            ! [input] basis set handle for ish 
      integer ish                ! [input] i shell/contraction 
      integer j_basis            ! [input] basis set handle for jsh 
      integer jsh                ! [input] j shell/contraction 
      integer k_basis            ! [input] basis set handle for ksh 
      integer ksh                ! [input] k shell/contraction 
      double precision zerotol   ! [input] "zero" tolerance threshold 
      integer lov3               ! [input] length of 3c overlap array 
      double precision OV3(lov3) ! [output] 3c overlap integrals 
      integer ilab(lov3)         ! [output] i labels for 3c overlap ints 
      integer jlab(lov3)         ! [output] j labels for 3c overlap ints 
      integer klab(lov3)         ! [output] k labels for 3c overlap ints 
      integer numov3             ! [output] number of integrals and labels  
c . . . . . . . . . . . . . . . .!          generated and returned 
      integer lscr               ! [input] length of scratch array 
      double precision scr(lscr) ! [input] scratch array 
\end{verbatim} 
 
% this is part of the API Standard Integral routines. 
\subsection{int\_1eall}  
This routine computes the 1 electron integrals S, T, and V: 
\begin{eqnarray*}  
S & = & ({\mu}|{\nu}) \\ 
  & = & \int_{{-}\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})g_{\nu}(X_{\nu},r_{1})dr_{1} \\ 
T & = & ({\mu}|\frac{-1}{2}{\nabla^{2}}|{\nu}) \\ 
  & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\frac{-1}{2}{\nabla^{2}}(r_{1})g_{\nu}(X_{\nu},r_{1})dr_{1} \\ 
V & = & ({\mu}|\sum_{\alpha}\frac{-Z_{\alpha}}{|r_{1}-R_{\alpha}|}|{\nu}) \\ 
  & = & \int_{-\infty}^{\infty}g_{\mu}(X_{\mu},r_{1})\sum_{\alpha}\frac{-Z_{\alpha}} 
{|r_{1}-R_{\alpha}|}g_{\nu}(X_{\nu},r_{1})dr_{1} 
\end{eqnarray*}  
 
If an ECP is defined then the ECP integral contributions are summed  
directly into the V integrals.   
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1eall(i_basis,ish,j_basis,jsh,lscr,scr,lstv,S,T,V) 
\end{verbatim} 
\begin{verbatim}  
      integer i_basis ! [input] basis set handle for ish 
      integer ish     ! [input] i shell/contraction 
      integer j_basis ! [input] basis set handle for jsh 
      integer jsh     ! [input] j shell/contraction 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lstv               ! [input] length of one electron buffers 
      double precision T(lstv)   ! [output] kinetic integral buffer 
      double precision V(lstv)   ! [output] potential integral buffer 
      double precision S(lstv)   ! [output] overlap integral buffer 
\end{verbatim} 
 
% this is part of the API Standard Integral routines. 
\subsection{int\_1eh1} 
This routine computes the 1 electron hamiltonian, ($H1$). 
\begin{eqnarray*} 
H1 & = & T + V      \\ 
T  & = & ({\mu}|\frac{-1}{2}\nabla^{2}|{\nu}) \\ 
   & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\frac{-1}{2} 
\nabla^{2}(r_{1})g_{\nu}(X_{\nu},r_{1})dr_{1} \\ 
V  & = & ({\mu}|\sum_{\alpha}\frac{-Z_{\alpha}}{|r_{1}-R_{\alpha}|}|{\nu}) \\ 
   & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\sum_{\alpha}\frac 
{-Z_{\alpha}}{|r_{1}-R_{\alpha}|}g_{\nu}(X_{\nu},r_{1})dr_{1}  
\end{eqnarray*} 
 
If an ECP is defined then the ECP integral contributions are summed  
directly into the $H1$ integrals.   
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1eh1(i_basis,ish,j_basis,jsh,lscr,scr,lh1,H1) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis ! [input] basis set handle for ish 
      integer ish     ! [input] i shell/contraction 
      integer j_basis ! [input] basis set handle for jsh 
      integer jsh     ! [input] j shell/contraction 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lh1                ! [input] length of H1 buffer. 
      double precision H1(lh1)   ! [output] one electron 
c. . . . . . . . . . . . . . . . !      hamiltonian integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_1eke} 
This routine computes the 1 electron kinetic energy integrals, ($T$).: 
\begin{eqnarray*} 
T & = & ({\mu}|\frac{-1}{2}\nabla^{2}|{\nu}) \\ 
  & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\frac{-1}{2}\nabla^{2}(r_{1})g_{\nu}(X_{\nu},r_{1})dr_{1} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1eke(i_basis,ish,j_basis,jsh,lscr,scr,lke,Ke) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis ! [input] basis set handle for ish 
      integer ish     ! [input] i shell/contraction 
      integer j_basis ! [input] basis set handle for jsh 
      integer jsh     ! [input] j shell/contraction 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lke                ! [input] length of Ke buffer 
      double precision Ke(lke)   ! [output] kinetic energy  
c . . . . . . . . . . . . . . . .!             integral buffer 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_1eov} 
This routine computes the 1 electron overlap integrals ($S$): 
\begin{eqnarray*} 
S & = & ({\mu}|{\nu}) \\ 
  & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})g_{\nu}(X_{\nu},r_{1})dr_{1} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1eov(i_basis,ish,j_basis,jsh,lscr,scr,lov,Ov) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis ! [input] basis set handle for ish 
      integer ish     ! [input] i shell/contraction 
      integer j_basis ! [input] basis set handle for jsh 
      integer jsh     ! [input] j shell/contraction 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lov                ! [input] length of Ov buffer 
      double precision Ov(lov)   ! [output] overlap integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_1epe} 
This routine computes the 1 electron potential integrals, ($V$): 
\begin{eqnarray*} 
V & = & ({\mu}|\sum_{\alpha}\frac{-Z_{\alpha}}{|r_{1}-R_{\alpha}|}|{\nu}) \\ 
  & = & \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\sum_{\alpha}\frac 
{-Z_{\alpha}}{|r_{1}-R_{\alpha}|}g_{\nu}(X_{\nu},r_{1})dr_{1}  
\end{eqnarray*} 
If an ECP is defined then the ECP integral contributions are summed  
directly into the V integrals.   
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1epe(i_basis,ish,j_basis,jsh,lscr,scr,lpe,Pe) 
\end{verbatim} 
\begin{verbatim} 
      integer i_basis ! [input] basis set handle for ish 
      integer ish     ! [input] i shell/contraction 
      integer j_basis ! [input] basis set handle for jsh 
      integer jsh     ! [input] j shell/contraction 
      integer lscr    ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] scratch array 
      integer lpe                ! [input] length of potential buffer 
      double precision Pe(lpe)   ! [output] potential integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_2e2c} 
this routine computes the 2 center 2 electron integrals:  
\begin{eqnarray*} 
({\mu}|{\nu}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\frac{1}{r_{12}}g_{\nu}(X_{\nu},r_{2})dr_{1}dr_{2} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_2e2c(brain, ish, ketin, jsh,  
     &       lscr, scr, leri, eri) 
\end{verbatim} 
\begin{verbatim} 
      integer brain ! [input] bra basis set handle 
      integer ish   ! [input] shell/contraction index 
      integer ketin ! [input] ket basis set handle 
      integer jsh   ! [input] shell/contraction index 
      integer lscr  ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] array 
      integer leri  ! [input] length of integral array 
      double precision eri(leri) ! [output] 2e2c integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_2e3c} 
this routine computes the 3 center 2 electron integrals:  
\begin{eqnarray*} 
({\mu}|{\nu}{\lambda}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})\frac{1}{r_{12}} 
g_{\nu}(X_{\nu},r_{2}g_{\lambda}(X_{\lambda},r_{2})dr_{1}dr_{2} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_2e3c(brain, ish, ketin, jsh, ksh, 
     &       lscr, scr, leri, eri) 
\end{verbatim} 
\begin{verbatim} 
      integer brain ! [input] bra basis set handle 
      integer ish   ! [input] shell/contraction index 
      integer ketin ! [input] ket basis set handle 
      integer jsh   ! [input] shell/contraction index 
      integer ksh   ! [input] shell/contraction index 
      integer lscr  ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] array 
      integer leri  ! [input] length of integral array 
      double precision eri(leri) ! [output] 2e3c integrals 
\end{verbatim} 
% this is part of the API Standard Integral routines. 
\subsection{int\_2e4c} 
this routine computes the 4 center (traditional) 2 electron integrals:  
\begin{eqnarray*} 
({\mu}{\rho}|{\nu}{\lambda}) = \int_{-\infty}^{\infty} g_{\mu}(X_{\mu},r_{1})g_{\rho}(X_{\rho},r_{1})\frac{1}{r_{12}}g_{\nu}
(X_{\nu},r_{2}g_{\lambda}(X_{\lambda},r_{2})dr_{1}dr_{2} 
\end{eqnarray*} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_2e4c(brain, ish, jsh, ketin, ksh, lsh, 
     &       lscr, scr, leri, eri) 
\end{verbatim} 
\begin{verbatim} 
      integer brain ! [input] bra basis set handle 
      integer ish   ! [input] shell/contraction index 
      integer jsh   ! [input] shell/contraction index 
      integer ketin ! [input] ket basis set handle 
      integer ksh   ! [input] shell/contraction index 
      integer lsh   ! [input] shell/contraction index 
      integer lscr  ! [input] length of scratch array 
      double precision scr(lscr) ! [scratch] array 
      integer leri  ! [input] length of integral array 
      double precision eri(leri) ! [output] 2e4c integrals 
\end{verbatim} 
\section{INT-API: Miscellaneous Routines} 
These routines do a variety of functions mostly internal to the 
INT-API but may require use by those integrating a new base integral 
code into NWChem.  These should be used with care and rarely in any 
application module.  
% 
 
% part of API Internal Routines 
\subsection{exact\_mem} 
This routine computes the memory required by the  
McMurchie-Davidson integral code developed at PNNL.   
This calls specific routines listed below for each  
integral type.  The data is stored in a common block  
(apiP.fh) for fast retrieval. 
This routine should never be called directly by a  
NWChem application module. 
    
{\it Syntax:} 
\begin{verbatim} 
      subroutine exact_mem(rtdb,bases,nbas) 
\end{verbatim} 
\begin{verbatim} 
      integer rtdb        ! [input] the RTDB handle 
      integer nbas        ! [input] number of basis sets 
      integer bases(nbas) ! [input] basis set handles 
\end{verbatim} 
 
{\bf Debugging Note:} using a set directive to set the  
variable ``int:full\_mem'' to true will force the more  
expensive $O(N^4)$ algorithm to be used to compute the  
memory requirements for the 2-electron integrals. 
 
% part of API Internal Routines 
\subsection{emem\_3ov} 
This routine computes the memory for the 3-center overlap  
integrals based on the basis sets used.   
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_3ov(ibasin,jbasin,kbasin,lsz_buf,memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer ibasin  ! [input] basis set handle for ``i'' contractions 
      integer jbasin  ! [input] basis set handle for ``j'' contractions 
      integer kbasin  ! [input] basis set handle for ``k'' contractions 
      integer lsz_buf ! [output] maximum size of integral buffer  
      integer memsize ! [output] memory needed for scratch array 
\end{verbatim} 
% part of API Internal Routines 
\subsection{emem\_1e} 
This routine computes the memory for any type of 1e  
integrals based on the basis sets used.   
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_1e(brain, ketin, max1e, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer max1e   ! [output] max size of 1e integrals buffer 
      integer memsize ! [output] max size of scratch space for 1e integral evaluation 
\end{verbatim} 
% part of API Internal Routines 
\subsection{emem\_2e4c} 
This routine computes the memory required by the McMurchie-Davidson  
algorithm for 4 center two electron integrals based on the  
basis sets used.   
 
The exact algorithm is an N$^4$ and an N$^2$ approximate algorithm  
is used here.  Exact memory is computed for integrals over the  
following classes: 
\begin{itemize} 
\item Coulumb $(ii|jj)$ 
\item Exchange $(ij|ij)$ 
\item Triplet $(ii|ij)$ 
\item Triplet $(ij|jj)$ 
\end{itemize} 
An additional 10\% is added to the maximum exact memory  
computation for each of these classes.  Additional classes that  
have been periodically problematic are: 
\begin{itemize} 
\item $(ij|jk)$ 
\item $(ij|kk)$ 
\end{itemize} 
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_2e4c(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% part of API Internal Routines 
\subsection{emem\_2e3c} 
This routine computes the memory required for the the two electron 
three center integrals using the McMurchie-Davidson algorithm.  
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_2e3c(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% part of API Internal Routines 
\subsection{emem\_2e2c} 
This routine computes the memory required for the the two electron 
two center integrals using the McMurchie-Davidson algorithm.  
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_2e2c(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% part of API Internal Routines 
\subsection{emem\_2e4c\_full} 
This routine computes the memory required by the McMurchie-Davidson  
algorithm for 4 center two electron integrals based on the  
basis sets used.   
 
The exact algorithm is an N$^4$ and costly.  This routine is used 
primarily as a debugging tool 
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_2e4c_full(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% Part of the API internal routines. 
\subsection{int\_nbf\_max} 
This routine computes the maximum cartesian nbf for a given basis 
set.  Used in many memory computing routines to deterine maximum 
buffer sizes needed for integral computations.  This also includes 
any general contraction information. 
This routine should never be called directly by a  
NWChem application module. 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_nbf_max(basisin,nbf_max) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin  ! [input] basis set handle 
      integer nbf_max  ! [output] maximum number of basis functions 
\end{verbatim} 
% Part of the API internal routines. 
\subsection{int\_mem\_zero} 
This routine zeros the memory pointers in the apiP.fh common 
that pertain to the memory utilization of the integral suite. 
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_mem_zero() 
\end{verbatim} 
There are no formal arguments to this routine 
 
% Part of the API internal routines. 
\subsection{api\_is\_ecp\_basis} 
This routine identifies basis set handles to INT-API  
that store ECP information. 
This routine should never be called directly by a  
NWChem application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      logical function api_is_ecp_basis(basisin) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin ! [input] basis set handle 
\end{verbatim} 
Return value is true if ``basisin'' represents an ECP 
 
% part of the API Internal Routines 
\subsection{exactd\_mem} 
This routine computes the memory required by the  
McMurchie-Davidson integral derivative code developed at PNNL. 
This calls specific routines listed below for each integral 
derivative type.  The data is stored in a common block (apiP.fh) 
for fast retrieval from the int\_mem routines. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine exactd_mem(rtdb,bases,nbas) 
\end{verbatim} 
\begin{verbatim} 
      integer rtdb        ! [input] the RTDB handle 
      integer nbas        ! [input] number of basis sets 
      integer bases(nbas) ! [input} array of basis set handles 
\end{verbatim} 
 
{\bf Debugging Note:} using a set directive to set the  
variable ``int:full\_mem'' to true will force the more  
expensive $O(N^4)$ algorithm to be used to compute the  
memory requirements for the 2-electron integral derivatives. 
 
% part of API Internal Routines 
\subsection{emem\_d1e} 
This routine determines the maximum buffer and scratch size for the  
one electron derivative integrals. 
This routine should not be called by application code. 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_d1e(brain, ketin, max1e, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer max1e   ! [output] max size of 1e integrals buffer 
      integer memsize ! [output] max size of scratch space for 1e integral evaluation 
\end{verbatim} 
% part of the API Internal Routines 
\subsection{emem\_d2e4c} 
This routine determines the maximum buffer and scratch size for  
the given basis sets to compute 2 electron derivative integrals.   
The logic used is similar to that of the integral routine.   
This routine should not be called by application code. 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_d2e4c(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% part of the API Internal Routines 
\subsection{emem\_d2e4c\_full} 
This routine determines the maximum buffer and scratch size for  
the given basis sets to compute 2 electron derivative integrals.   
The logic used is similar to that of the integral routine.   
This routine should not be called by application code.  
this routine computes the complete memory requirements using 
an $O(N^4$) algorithm 
{\it Syntax:} 
\begin{verbatim} 
      subroutine emem_d2e4c_full(brain, ketin, maxg, memsize) 
\end{verbatim} 
\begin{verbatim} 
      integer brain   ! [input] bra basis set handle 
      integer ketin   ! [input] ket basis set handle 
      integer maxg    ! [output] max size of 2e integrals buffer 
      integer memsize ! [output] max size of scratch space for 2e integral evaluation 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_canon} 
This routine canonicalizes integral lables such that: 
$i \geq j$, $k \geq l$, and $ij \geq kl$ 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_canon(i, j, k, l, ii, jj, kk, ll) 
\end{verbatim} 
\begin{verbatim} 
      integer i,j,k,l      ! [input] labels 
      integer ii,jj,kk,ll  ! [output] canonical labels 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_chk\_init} 
This function checks to see that the integral API is initialized. 
Returns .true. if initialized and .false. if not. 
 
{\it Syntax:} 
\begin{verbatim} 
      logical function int_chk_init(msg) 
\end{verbatim} 
\begin{verbatim} 
      character*(*) msg ! [input] usually indentfy calling routine 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_chk\_sh} 
This function checks to see that the given shell is valid 
Returns .true. if so else returns .false. if not. 
This subroutine call can be replaced by a statement  
function sequence: 
\begin{verbatim} 
#include "basP.fh" 
#include "geobasmapP.fh" 
      logical inline_chk_sh 
      inline_chk_sh(bra,ish) = 
     $     ((ish.gt.0) .and. (ish.le.ncont_tot_gb(bra))) 
\end{verbatim} 
Where bra is the lexical basis index (not the handle). 
or you could use the following with the handle. 
\begin{verbatim} 
      inline_chk_sh(bra,ish) = 
     $     ((ish.gt.0) .and.  
     $(ish.le.ncont_tot_gb(bra+Basis_Handle_Offset))) 
\end{verbatim} 
 
{\it Syntax:} 
\begin{verbatim} 
      logical function int_chk_sh(basisin,shell) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin ! [input] basis set handle 
      integer shell ! [input] lexical shell index 
\end{verbatim} 
% this is an internal API routine 
\subsection{int\_nospherical\_check} 
This routine stubs out routines that are not ready for  
spherical basis functions by forcing an error condition. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_nospherical_check(basisin,tine) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin     ! [input] basis set handle 
      character*(*) tine  ! [input] routine identifier 
\end{verbatim} 
% this is an internal API routine 
\subsection{int\_nogencont\_check} 
This routine stubs out routines that are not ready for  
general contraction basis functions by forcing an error  
condition. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_nogencont_check(basisin,tine) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin     ! [input] basis set handle 
      character*(*) tine  ! [input] routine identifier 
\end{verbatim} 
% this is an internal API routine 
\subsection{int\_nospshell\_check} 
This routine stubs out routines that are not ready for  
sp shells type basis functions by forcing an error  
condition. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_nospshell_check(basisin,tine) 
\end{verbatim} 
\begin{verbatim} 
      integer basisin     ! [input] basis set handle 
      character*(*) tine  ! [input] routine identifier 
\end{verbatim} 
% part of the internal API routines. 
\subsection{int\_hf1sp} 
This is a layer routine that calls the  
McMurchie-Davidson one electron routine.  This layer 
routine handles all permutations to compute sp integrals. 
This routine should never be called by an application module. 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_hf1sp( 
     &       xyzi,expi,coefi, i_nprim, i_ngen, Li, 
     &       xyzj,expj,coefj, j_nprim, j_ngen, Lj, 
     &       xyz,zan,nat,S,T,V,lstv,doS,doT,doV,canAB, 
     &       dryrun,scr,lscr,msg) 
\end{verbatim} 
For an integral $<i|Operator|j>$ 
\begin{verbatim} 
      integer i_nprim  ! [input] num. prims on function i 
      integer i_ngen   ! [input] num general conts on func. i 
      integer Li       ! [input] angular momentum of func. i   
      integer j_nprim  ! [input] num. prims on function j      
      integer j_ngen   ! [input] num general conts on func. j  
      integer Lj       ! [input] angular momentum of func. j   
      integer nat      ! [input] number of atoms 
      integer lscr     ! [input] size of scratch array 
      integer lstv     ! [input] size of any integral buffer 
      double precision xyzi(3)  ! [input] position of center i 
      double precision expi(i_nprim) ! [input] exponents on i 
      double precision coefi(i_nprim,i_ngen) ! [input] i coeffs 
      double precision xyzj(3)  ! [input] position of center j 
      double precision expj(j_nprim)  ! [input] exponents on j 
      double precision coefj(j_nprim,j_ngen)  ! [input] j coeffs 
      double precision xyz(3,nat)  ! [input] all atom positions 
      double precision zan(nat)  ! [input] charges on all atoms 
      double precision scr(lscr)  ! [scratch] scratch buffers 
      double precision S(lstv)  ! [output] overlap integrals 
      double precision T(lstv)  ! [output] kinetic energy integrals 
      double precision V(lstv)  ! [output] potential integrals 
      logical doS     ! [input] compute overlap (True/False) 
      logical doT     ! [input] compute kinetic (True/False) 
      logical doV     ! [input] compute potential (True/False) 
      logical canAB   ! [input] compute only canonical ints (false only) 
      logical dryrun  ! [input] true means only compute required memory 
      character*(*) msg ![input] calling func. identification message 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_1psp} 
This routine transforms integrals from the way they 
were computed $(p|s)$, $(p|p)$ to $(p|sp)$. 
The transformation is done in place as follows: 
\begin{tabular}{rccc} 
 & computed & transformed & \\ 
 &  order   &   order     & \\ 
~1 & (x$|$s)  &  (x$|$s)  & \\ 
~2 & (y$|$s)  &  (x$|$x)  & 2 $\rightarrow$ 5\\ 
~3 & (z$|$s)  &  (x$|$y)  & 3 $\rightarrow$ 9\\ 
~4 & (x$|$x)  &  (x$|$z)  & 4 $\rightarrow$ 2\\ 
~5 & (x$|$y)  &  (y$|$s)  & 5 $\rightarrow$ 3\\ 
~6 & (x$|$z)  &  (y$|$x)  & 6 $\rightarrow$ 4\\ 
~7 & (y$|$x)  &  (y$|$y)  & 7 $\rightarrow$ 6\\ 
~8 & (y$|$y)  &  (y$|$z)  & 8 $\rightarrow$ 7\\ 
~9 & (y$|$z)  &  (z$|$s)  & 9 $\rightarrow$ 8\\ 
10 & (z$|$x)  &  (z$|$x)  &  \\ 
11 & (z$|$y)  &  (z$|$y)  &  \\ 
12 & (z$|$z)  &  (z$|$z)  &  \\ 
\end{tabular} 
  
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1psp(block,num_blocks) 
\end{verbatim} 
\begin{verbatim} 
      integer num_blocks  ! [input] num. blocks to transform 
      double precision block(12,num_blocks) ! [input/output]  
c. . . . . . . . . . . . . . . . . . . . . .! integral block 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_1dsp} 
This routine transforms integrals from the way they 
were computed $(d|s)$, $(d|p)$ to $(d|sp)$. 
The transformation is done in place as follows: 
\begin{tabular}{rccc}       
  &  computed  & transformed & \\ 
  &  ~order    &  order & \\ 
~1 & (xx$|$s)  &  (xx$|$s)  & \\ 
~2 & (xy$|$s)  &  (xx$|$x)  &  ~2 $\rightarrow$ 5~~ \\ 
~3 & (xz$|$s)  &  (xx$|$y)  &  ~3 $\rightarrow$ 9~~ \\ 
~4 & (yy$|$s)  &  (xx$|$z)  &  ~4 $\rightarrow$ 13~ \\ 
~5 & (yz$|$s)  &  (xy$|$s)  &  ~5 $\rightarrow$ 17~ \\ 
~6 & (zz$|$s)  &  (xy$|$x)  &  ~6 $\rightarrow$ 21~ \\ 
~7 & (xx$|$x)  &  (xy$|$y)  &  ~7 $\rightarrow$ 2~~ \\ 
~8 & (xx$|$y)  &  (xy$|$z)  &  ~8 $\rightarrow$ 3~~ \\ 
~9 & (xx$|$z)  &  (xz$|$s)  &  ~9 $\rightarrow$ 4~~ \\ 
10 & (xy$|$x)  &  (xz$|$x)  &  10 $\rightarrow$ 6~~ \\ 
11 & (xy$|$y)  &  (xz$|$y)  &  11 $\rightarrow$ 7~~ \\ 
12 & (xy$|$z)  &  (xz$|$z)  &  12 $\rightarrow$ 8~~ \\ 
13 & (xz$|$x)  &  (yy$|$s)  &  13 $\rightarrow$ 10~ \\ 
14 & (xz$|$y)  &  (yy$|$x)  &  14 $\rightarrow$ 11~ \\ 
15 & (xz$|$z)  &  (yy$|$y)  &  15 $\rightarrow$ 12~ \\ 
16 & (yy$|$x)  &  (yy$|$z)  &  16 $\rightarrow$ 14~ \\ 
17 & (yy$|$y)  &  (yz$|$s)  &  17 $\rightarrow$ 15~ \\ 
18 & (yy$|$z)  &  (yz$|$x)  &  18 $\rightarrow$ 16~ \\ 
19 & (yz$|$x)  &  (yz$|$y)  &  19 $\rightarrow$ 18~ \\ 
20 & (yz$|$y)  &  (yz$|$z)  &  20 $\rightarrow$ 19~ \\ 
21 & (yz$|$z)  &  (zz$|$s)  &  21 $\rightarrow$ 20~ \\ 
22 & (zz$|$x)  &  (zz$|$x)  & \\ 
23 & (zz$|$y)  &  (zz$|$y)  & \\ 
24 & (zz$|$z)  &  (zz$|$z)  & \\ 
\end{tabular} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1dsp(block,num_blocks) 
\end{verbatim} 
\begin{verbatim} 
      integer num_blocks  ! [input] num. blocks to transform 
      double precision block(24,num_blocks) ! [input/output]  
c . . . . . . . . . . . . . . . . . . . . . ! integral block 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_1spsp} 
This routine transforms integrals from the way they 
were computed $(s|s)$, $(s|p)$, $(p|s)$, $(p|p)$   
to $(sp|sp)$. 
The transformation is done in place as follows: 
\begin{tabular}{rccc}       
  &  computed & transformed   &   \\ 
  &   order   &  order  &   \\ 
~1 & (s$|$s)  &  (s$|$s)  &   \\ 
~2 & (s$|$x)  &  (s$|$x)  &   \\ 
~3 & (s$|$y)  &  (s$|$y)  &   \\ 
~4 & (s$|$z)  &  (s$|$z)  &   \\ 
~5 & (x$|$s)  &  (x$|$s)  &   \\ 
~6 & (y$|$s)  &  (x$|$x)  &  ~6 $\rightarrow$ 9\\ 
~7 & (z$|$s)  &  (x$|$y)  &  ~7 $\rightarrow$ 13\\ 
~8 & (x$|$x)  &  (x$|$z)  &  ~8 $\rightarrow$ 6\\ 
~9 & (x$|$y)  &  (y$|$s)  &  ~9 $\rightarrow$ 7\\ 
10 & (x$|$z)  &  (y$|$x)  &  10 $\rightarrow$ 8 \\  
11 & (y$|$x)  &  (y$|$y)  &  11 $\rightarrow$ 10\\ 
12 & (y$|$y)  &  (y$|$z)  &  12 $\rightarrow$ 11\\ 
13 & (y$|$z)  &  (z$|$s)  &  13 $\rightarrow$ 12\\ 
14 & (z$|$x)  &  (z$|$x)  &   \\ 
15 & (z$|$y)  &  (z$|$y)  &   \\ 
16 & (z$|$z)  &  (z$|$z)  &   \\ 
\end{tabular} 
 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_1spsp(block,num_blocks) 
\end{verbatim} 
\begin{verbatim} 
      integer num_blocks        ! [input] num. blocks to transform 
      double precision block(16,num_blocks) ! [input/output]  
c . . . . . . . . . . . . . . . . . . . . . ! integral block 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_1spa} 
This routine transforms integrals from the way they 
were computed $(s|X)$, $(p|X)$, to $(sp|X)$. 
The transformation is {\bf NOT} done in place: 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_sp1a(sp_block,s_block,p_block,sizeb,num_blocks) 
\end{verbatim} 
\begin{verbatim} 
      integer sizeb  ! [input] size of non sp block 
      integer num_blocks ! [input] num of blocks to transform 
* 
* . . . . . . . . . . . . . . .! [output] (sp|X) transformed integral block 
      double precision sp_block(sizeb,1:4,num_blocks)  
* 
* . . . . . . . . . . . . . . . . . . . . . .! [input] computed (s|X) block 
      double precision s_block(sizeb,num_blocks) 
* 
* . . . . . . . . . . . . . . . . . . . . . .! [input] computed (p|X) block 
      double precision p_block(sizeb,2:4,num_blocks) 
\end{verbatim} 
% part of the internal API routines 
\subsection{int\_sp1b} 
This routine transforms integrals from the way they 
were computed $(X|s)$, $(X|p)$, to $(X|sp)$. 
The transformation is {\bf NOT} done in place: 
{\it Syntax:} 
\begin{verbatim} 
      subroutine int_sp1b(sp_block,s_block,p_block,sizea,num_blocks) 
\end{verbatim} 
\begin{verbatim} 
      integer sizea ! [input] size of non sp block 
      integer num_blocks ! [input] num of blocks to transform 
* 
* . . . . . . . . . . . . . . .! [output] (X|sp) transformed integral block 
      double precision sp_block(1:4,sizea,num_blocks) 
* 
* . . . . . . . . . . . . . . . . . . . . . .! [input] computed (X|s) block 
      double precision s_block(sizea,num_blocks) 
* 
* . . . . . . . . . . . . . . . . . . . . . .! [input] computed (X|p) block 
      double precision p_block(2:4,sizea,num_blocks) 
\end{verbatim} 
