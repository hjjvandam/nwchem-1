
In your environment, or on the make command line, you must specify two
variables
\begin{itemize}
\item {\tt NWCHEM\_TARGET} --- the name of the machine to build for.
\item {\tt NWCHEM\_TOP} --- the full path to the top level NWChem
  directory.
\end{itemize}
Look in the {\tt README} file in the top-level NWChem directory for
information about supported target platforms.  For instance, you might
insert the following in your \verb+.cshrc+ file on a SUN with SunOS
4.1.3 
\begin{verbatim}
  setenv NWCHEM_TARGET SUN
  if (! $?NWCHEM_TOP) setenv NWCHEM_TOP $HOME/nwchem
\end{verbatim}
(the test to see if \verb+NWCHEM_TOP+ is already defined permits you
to build in an alternative directory without having to edit your
\verb+.cshrc+ file).  Given just this information the structure of
NWChem makes it easy to write a makefile to build a library for a
module (.e.g, {\tt libddscf.a} for the SCF module) or to add routines
into a library shared between multiple modules (e.g., {\tt libutil.a}
which includes at least the util, geometry, basis, global, and ma
trees).

A minimal makefile looks like this
\begin{verbatim}
      LIBRARY = libminimal.a
          OBJ = a.o b.o c.o

include ../config/makefile.h
include ../config/makelib.h
\end{verbatim}

The above specifies that the object files are to be generated by
compiling available source (C or Fortran, without optimization) and
put into the library {\tt libminimal.a} (in the NWChem library
directory).  Nothing else is necessary.  If the library source is not
located in a subdirectory of the NWChem {\tt src} directory then the
path to the included files must be modified accordingly.

A slightly more complex makefile looks like this
\begin{verbatim}
      LIBRARY = libsimple.a
          OBJ = a.o b.o c.o
 OBJ_OPTIMIZE = d.o
    USES_BLAS = c.o
      HEADERS = simple.fh
  LIB_TARGETS = test

include ../config/makefile.h
include ../config/makelib.h

test: test.o $(LIBRARY_PATH)
      $(LINK.f) -o $@ $^

a.o b.o c.o test.o: simple.fh private.fh
\end{verbatim}

This makefile builds the library {\tt libsimple.a} from four object
files of which only one ({\tt d.o}) is optimized.  The source
associated with {\tt c.o} uses FORTRAN BLAS and will be automatically
converted on machines where 64 bit reals are single precision (e.g.,
requiring {\tt sgemm()} rather than {\tt dgemm()}).  The header file
{\tt simple.fh} is exported automatically into the NWChem include
directory ({\tt src/include}) where it may be included by other
modules which reference these routines.  Associated with the module is
the executable {\tt test} (not made by default) which will be cleaned
up automatically with \verb+make clean+.  The final line
specifies a dependency of certain object files on various header
files.

In gory detail, a makefile for a module must
\begin{enumerate}
\item include \verb+../config/makefile.h+ --- amoung other things this will
    define {\tt TARGET} from which any machine dependent actions are driven
    (if you don't need to use {\tt TARGET} then it's best to include this
     file at the same point that makelib.h is included).
\item define {\tt LIBRARY} as the name of the library to be made
\item optionally define {\tt OBJ} as the list of object files to be made 
    without optimization
\item optionally define {\tt OBJ\_OPTIMIZE} as the list of object files to 
    be made with optimization.  It is good practice to keep this list 
    short so as to minimize exposure to possible compiler errors.
\item optionally define {\tt HEADERS} as the list of header/include files to be
    copied into the common include directory
\item optionally define {\tt LIB\_TARGETS} as any additional files made in
    this subdirectory that may need cleaning up
\item optionally define {\tt LIB\_DEFINES} as any additional defines for
   the C preprocessor (for both Fortran and C)
 \item optionally define {\tt LIB\_INCLUDES} as any additional include
   directories
\item optionally define {\tt SUBDIRS} as any subdirectories to build (note
  that makefiles in subdirectories will need to modify the paths to
  the include files)
\item optionally define {\tt USES\_BLAS} to be the list of FORTRAN files that
    need BLAS names converting between single and double (e.g., {\tt
      ddot} to  {\tt sdot})
\item include \verb+../config/makelib.h+.  The first rule in this file
     builds the library so there should be {\em no} targets before this.
\item define any additional targets (e.g., test programs)
\end{enumerate}

Notes:
\begin{enumerate}
\item  To modify the optimization being used specify on the command
  line {\tt C/FDEBUG} or {\tt C/FOPTIMIZE} to override the flags for the 
  {\tt OBJ} and {\tt OBJ\_OPTIMIZE} files respectively.  E.g.,
\begin{verbatim}
     make FDEBUG="-g -O1"
     make FOPTIMIZE="-O3 -Superfast -bugs" FDEBUG="-O1"
\end{verbatim}
\item  The library is now put directly into the NWChem library
  directory and the full path to the library (if needed by your
  makefile) is automatically put into the variable {\tt
    LIBRARY\_PATH}.
\item The object files are now put directly into the libraries and are
  not kept elsewhere.  This has several implications
  \begin{itemize}
  \item You can (apart from TCGMSG and GA which are being fixed) build
    executables and libraries for multiple platforms in the same
    source tree.
  \item To force recompilation of all source in a given directory 
    \verb+make clean+ now works by deleting the object files from
    the library, and deletes the library itself only if it is empty.
    You have to
    actually either delete the corresponding library or touch the
    source files.
  \item To override the compilation options for a specifc file (e.g.,
    because of compiler errors on a specific platform) you must
    specify the dependency on the object file in the library.  Here
    are two examples.  The first one (\verb+dosymops.f+) does not need
    preprocessing, whereas the second one (\verb+sym_mo_ap_op.F+) does
    and this must done explicity within the rule for this file.
    This preprocessing is normally done automatically.
\begin{verbatim}
  ifeq ($(TARGET),CRAY-T3D)
    FNOOPT = -dp -Ccray-t3d -Wf"-o noscalar,jump,noieeedivide"
  $(LIBRARY_PATH)(dosymops.o):  dosymops.f
        $(FC) -c $(FNOOPT) $^
  $(LIBRARY_PATH)(sym_mo_ap_op.o):  sym_mo_ap_op.F
        $(FCONVERT)
        $(FC) -c $(FNOOPT) sym_mo_ap_op.f
        @/bin/rm -f sym_mo_ap_op.f
  endif
\end{verbatim}
%$ ... to unscrew emacs latex hiliting
  \end{itemize}
\item The target {\tt clean} will recursively descend subdirectories and
  delete object files from both the directory and associated library, 
  core files and files defined in {\tt LIB\_TARGETS}.
\item The target {\tt realclean} will, in addition to the actions of
  clean, also delete the library and any emacs backup files.
\item The target {\tt cleanF} will recursively descend subdirectories
  and search for and delete \verb+.f+ files for which a corresponding
  \verb+.F+ file exists.  This is useful on machines for which the
  conversion from \verb+.F+ to \verb+.f+ is done explicitly rather
  than by the compiler.
\item The target {\tt depend} will recursively descend subdirectories
  and append onto the end of makefiles dependencies of \verb+.F+ and
  \verb+.c+ files on header files that have been included using the
  notation \verb+#include "filename"+.  Files included using angle
  brackets are assumed to be system files and dependencies are not
  generated.  If the include file is in the local directory, the
  dependency is generated upon that.  Otherwise, a dependency is
  generated upon a file in the NWChem include directory.
  Do not insert anything below the line
\begin{verbatim}
# DO NOT EDIT BENEATH THIS LINE ... GENERATED AUTOMATICALLY
\end{verbatim}
  since it will be lost the next time that \verb+make depend+
  is run.
\end{enumerate}

Typing {\tt make} in the top-level NWChem directory will traverse the
entire directory tree twice.  Once to ensure the include files are
up-to-date, and again for the libraries.  This can take a while.
When developing a module, then unless recompilation of another module
is necessary, it is much faster to 
\begin{enumerate}
\item execute {\tt make} in the subdirectory, and
\item execute {\tt make link} in the top NWChem directory.
\end{enumerate}
The special target link just relinks the code and does not traverse
the directory tree.  {\em After doing a \verb+cvs update+ you should:}
\begin{enumerate}
\item do a make depend, if you have not recently, in any directory you
  have been working in, and
\item do a full make from the top level to ensure that all libraries
  incorporate any changed common blocks or declarations.
\end{enumerate}

In addition, the top-level makefile has the target {\tt test} which
builds the executable \verb+nwchem_test+ in the \verb+src/+ directory
(rather than the usual \verb+$(BINDIR)/nwchem+), % $
and the target {\tt prof} 
which builds \verb+nwchem_prof+ (in \verb+src/+)
for performance profiling by linking with the -p option.

