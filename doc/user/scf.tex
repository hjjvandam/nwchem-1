\label{SCF}

\begin{verbatim}
  SCF
    ...
  END
\end{verbatim}

This compound directive controls the SCF program.  Closed shell RHF,
ROHF, and UHF are currently working.  The various optional
sub-directives are described below.

\subsection{Type of SCF wavefunction and specification of multiplicity
and open shells}

\begin{verbatim}
  SINGLET 
  DOUBLET 
  TRIPLET 
  QUARTET 
  QUINTET 
  NOPEN <integer nopen default 0>
  RHF
  ROHF
  UHF
\end{verbatim}

By default, the SCF module assumes that a spin-restricted,
closed-shell SCF (RHF) calculation is to be run, and an error results
if the number of electrons (inferred from the nuclear-charges and
total charge on the system) is inconsistent with this.  If any of the
keywords specifying the multiplicity are given then a spin-restricted,
high-spin, open-shell SCF (ROHF) calculation is run.  The open-shell
orbitals must be the highest occupied orbitals, which, if necessary,
may be arranged through the use of the \verb+SWAP+ keyword on the
\verb+VECTORS+ directive (see section \ref{sec:vectors}). If there are
more than four open shells then \verb+NOPEN+ may be used to specify
directly the number of open shells.  If in addition it is desired to
run a spin-unrestricted calculation (UHF) then the keyword \verb+UHF+
must be present.  The keywords \verb+RHF+ and \verb+ROHF+ exist for
convenience, but never need to be specified.  In UHF calculations it is
assumed that the number of open shells corresponds to the difference
between the number of alpha-spin and beta-spin orbitals.

Examples:
\begin{itemize}
\item No input runs a spin-restricted closed-shell singlet.
\item \verb+doublet+ runs a ROHF calculation with one open shell.
\item \verb+triplet; uhf+ runs a UHF calculation with 2 more
  alpha-spin orbitals than beta-spin.
\end{itemize}

Note that by default molecular orbitals are symmetry adapted.  This
may not be desirable for fully unrestricted wavefunctions, in which
case specify \verb+ADAPT OFF+ (section \ref{sec:adapt}) and \verb+SYM
OFF+ (section \ref{sec:sym}).

\subsection{SYM}
\label{sec:sym}

\begin{verbatim}
  SYM (ON|OFF)
\end{verbatim}
This directive enables/disables use of symmetry to speedup Fock matrix
construction (via the petite or skeleton algorithm) in the SCF even if
symmetry was used in the specification of the geometry.  Symmetry
adaption of the molecular orbitals is not affected by this option.

\subsection{ADAPT}
\label{sec:adapt}

\begin{verbatim}
 ADAPT (ON|OFF)
\end{verbatim}

This directive enables/disables symmetry adaption of the molecular
orbitals.  This does not impact the speed of the calculation but the
resulting orbitals may be symmetry contaminated, especially if
starting a calculation from orbitals from a distorted geometry.
Underlying the use of symmetry in Fock-matrix construction is the
assumption that the density is totally symmetric --- if the orbitals
are symmetry contaminated this assumption may be invalid which will
potentially result in incorrect energies and poor convergence.  It is
thus advisable when specifying \verb+ADAPT OFF+ to also specify
\verb+SYM OFF+.

\subsection{TOL2E}

\begin{verbatim}
  TOL2E <real tol2e default 1.0e-7>
\end{verbatim}

This is used in determining the integral screening threshold for the
evaluation of the energy and related Fock-like matrices.  The Schwarz
inequality is used to screen upon the product of integrals and density
matrices in a manner that results in approximately an accuracy of
\verb+TOL2E+ in the energy and Fock-matrices.  This differs from many
codes where the error in the energy is typically much greater than
this threshold.  The default threshold is suitable for most purposes.
A value of $10^{-5}$ can speed up some low-accuracy exploratory
calculations, where as a tighter threshold of $10^-9$ might be
necessary to explore reliably very weak, micro-Hartree or below,
interactions.

\subsection{LAGRANGIAN}

\begin{verbatim}
  LAGRANGIAN
\end{verbatim}

This keyword generates and dumps the orbital Lagrangian to disk. The
lagrangian is required to compute ROHF gradients but under most
circumstances this option is automatically enabled and need not be set
by the user.

\subsection{CHUNK}

\begin{verbatim}
  CHUNK <integer chunk default -1>
\end{verbatim}

This directive controls the `chunk-size' or granularity of the
parallel work decomposition.  It might be necessary to use a smaller
or larger value to obtain a more efficient execution on a large
parallel computer, or a computer with very high communication costs.
Users unfamiliar with the internal function of the program should seek
advice before changing this parameter.

\subsection{VECTORS}
\label{sec:vectors}

\begin{verbatim}
  VECTORS [[input] (<string input_movecs default atomic>) || \
                   (project <string basisname> <string filename>)] \
          [swap [alpha|beta] <integer vec1 vec2> ...] \
          [output <string output_movecs default movecs>] \
          [lock]
\end{verbatim}

The \verb+VECTORS+ directive controls the source and destination of
the molecular orbital vectors.  In a startup calculation the default
source for guess vectors is to diagonalize a Fock matrix constructed
from a superposition of the atomic density matrices.  This is usually
a very good guess.  Other possible sources for orbitals are from
diagonalization of the bare-nucleus or one-electron Hamiltonian
(\verb+HCORE+), projection from molecular orbitals in a smaller basis
(\verb+PROJECT+), or from a named file that contains the results of a
previous calculation.

If the input vectors are read from a file then the output orbitals are
by default sent to the same file.  If the \verb+ATOMIC+, \verb+HCORE+,
or \verb+PROJECT+, guesses are used then the default destination for
vectors is a file named \verb+"<file_prefix>.movecs"+.  When a
calculation completes normally (i.e., is not interrupted or does not
crash) then, independent of convergence, the database is automatically
modified so that if the job is restarted the default source of vectors
will be the results of the previous calculation.

Once starting vectors have been produced from any of the possible
options they may be reordered through use of the \verb+SWAP+ keyword
which takes as its argument a list of pairs that will be swapped.
For UHF calculations separate \verb+SWAP+ keywords must be provided
for the alpha and beta orbitals as necessary.

The \verb+LOCK+ directive locks the ordering of orbitals to that of the
initial vectors, as far as possible. The default is to order by
ascending orbital energies within each orbital space. The \verb+LOCK+
directive is useful, for example, to force the SCF to preserve the
ordering of a previous geometry despite flipping of orbital energies.

To re-cap, the default options suffice to provide a good starting
guess for most instances as well as to route vectors to a file
(\verb+"movecs"+) from which they are automatically used for restart.
Note that the SCF orbitals are {\em always} canonicalized on output.
Examples follow.

To use the default sources for vectors and route result vectors
to a different file
\begin{verbatim}
  vectors output h2o.movecs
\end{verbatim}

To load the vectors from one file and route result vectors to a
second file
\begin{verbatim}
  vectors input initial.movecs output final.movecs
\end{verbatim}

\sloppy

To restart from vectors in the file \verb+"small.movecs"+ which are in
a basis named \verb+"small basis"+ (NB: the definition of this basis
must be available in the current database and the basis must be
smaller than the current one.  Also, the geometry used for the
previous calculations must have the atoms in the same order and in the
same orientation as the current geometry).  The keyword \verb+INPUT+
is not necessary but is provided for clarity.  Output vectors are
routed to the file \verb+"big.movecs"+.
\begin{verbatim}
  vectors input project "small basis" small.movecs
\end{verbatim}

\fussy

To read orbitals from the file \verb+"try1.movecs"+, swap the orbitals
within the pairs 173--175 and 174--176, and write final orbitals to
the file \verb+"try2.movecs"+.
\begin{verbatim}
  vectors input try1.movecs swap 173 175 174 176 output try2.movecs
\end{verbatim}

In a UHF calculation, swap the 5--6 alpha orbital pair and the 4--5
beta orbital pair.
\begin{verbatim}
  vectors swap beta 4 5 swap alpha 5 6
\end{verbatim}


\subsection{THRESH}

\begin{verbatim}
  THRESH  <real thresh default 1.0e-5>
\end{verbatim}

The convergence threshold is the norm of the orbital gradient which is
also roughly the precision available in the wavefunction.  The energy
should be converged to roughly the square of this number.  Of course,
the precision in the energy is also limited by the integral selection
thresholds, etc. 

\subsection{MAXITER}

\begin{verbatim}
   MAXITER <integer maxiter default 8>
\end{verbatim}

The default maximum number of iterations is eight.  This is adequate for
the quadratically convergent SCF algorithm to converge most molecules
to the default threshold.

\subsection{RI}

\begin{verbatim}
   RI <hessian | preconverge | full> <disk | memory | auto>
\end{verbatim}

This directive requests the RI approximation being used for the Fock matrix.
The RI-SCF method is especially suggested for small molecules with
expensive basis sets.

If called with the \verb+full+ keyword (default)  it is used for all
Fock builds, which is 
fastest but results in an approximate energy.. The \verb+Hessian+ keyword
means only the hessian is calculated with an approximated Fock matrix, and
\verb+preconverge+ requests an ''exact'' direct SCF (with RI hessian, which
does not change the result) after convergence of the
RI approximated calculation.

\verb+Disk+ indicates storage of 3-center integrals on disk. This only
works where the ''Disk Resident Array'' library is implemented. \verb+Memory+
requests in-core storage of the integrals. This
significantly reduces the maximum problem size that can be handled.
Default is \verb+auto+, which lets the program determine if there is
enough memory for the in-core version, otherwise the disk based
algorithm is used (if available).

An expansion basis named ''riscf basis'' has to be present in the input deck.

\subsection{PROFILE}

\begin{verbatim}
  PROFILE
\end{verbatim}

If present, this directive enables a detailed analysis of the
performance of the SCF code.  This can introduce significant
overhead on machines which have expensive timing routines (e.g., SUN).

\subsection{DIIS}
\begin{verbatim}
  DIIS
\end{verbatim}

This directive toggles on the DIIS convergence as opposed to the
second-order convergence. This is a fairly rudimentary implementation
without level-shifting and damping and, currently, does not support
open-shells. This is provided on an ``as is'' basis. Use the
\verb+MAXITER+ directive to increase the macroiteration count to
approximately 20.

The directive
\begin{verbatim}
  DIISBAS <integer diisbas default 5>
\end{verbatim}
controls the size of the subspace for DIIS extrapolation.  The default
should be adequate in most instances but it may be reduced to conserve
memory for large systems or increased if convergence is poor.

\subsection{Control of direct, semi-direct and disk-resident SCF}
\label{sec:semidirect}

The default behaviour of the SCF code is
\begin{itemize}
\item If all integrals can be stored in memory then integrals are
  computed once and cached in memory. Otherwise,
\item 95\% of the available disk space in the scratch directory
  (section \ref{sec:dirs}) is assumed available for use
  and as many integrals as possible are cached on disk (with no
  memory being used for caching).  Some attempt is made to 
  store the most expensive integrals in the cache.
\item Note that no allowance is made for processes sharing
  disks when computing available space.
\item If not all integrals can be cached in memory or on disk,
  then the additional integrals are recomputed in a semi-direct
  fashion.
\item Since many computer systems (e.g., the EMSL IBM SP) clear the
  fast scratch space at the end of each job, and given the complexity
  of restarting {\em parallel} semi-direct calculations, the integral
  file is deleted at the end of the calculation.  Under some
  situations it is possible to restart from integrals on disk, but
  this capability will not be made widely available until a later date.
\end{itemize}

On the IBM SP or any other computer with fast disks, local to each
processor, semi-direct is the best behaviour and can result in {\em
  quadratic speedup} as more processors are added.  On other machines,
it may be necessary to limit the use of disk space, force the use of
more memory for caching, change the default file names, or to use
fully-direct SCF.

The directive
\begin{verbatim}
  DIRECT
\end{verbatim}
forces a fully-direct calculation with recomputation of the integrals
as required.  More detailed control is provided with

\begin{verbatim}
   SEMIDIRECT [filesize <integer filesize = disksize>] 
              [memsize  <integer memsize = available>]
              [filename <string filename>]
\end{verbatim}
The \verb+filesize+ specifies the disk space to be used per process
for storing integrals in 64-bit words.  Similarly, \verb+memsize+
specifies the number of 64-bit words to be used per process for
caching integrals in memory (if this memory is not available then the
request it is repeatedly halved until the request is satisfied).  By
default, the integral file is placed into the scratch directory
(section \ref{sec:dirs}). The \verb+filename+ keyword permits this
default to be overriden, however, it should be noted that the
user-provided name has the process number appended to it (so that
processes have distinct files) but otherwise is used unchanged by all
processes.  Thus, it is not possible to use this keyword to use
different disks for different processes.  Use the \verb+SCRATCH_DIR+
(section \ref{sec:dirs}) directive for this purpose.  Some examples
follow.

These two directives accomplish the same effect (full recomputation of
integrals)
\begin{verbatim}
  direct
  semidirect filesize 0 memsize 0
\end{verbatim}

To disable use of memory for caching integrals and to limit disk
usage by each process to 100 MW
\begin{verbatim}
  semidirect memsize 0 filesize 200000000
\end{verbatim}


\subsubsection{Integral file format and file sizes}

The file format is rather complex since it accomodates a variety of
packing and compression options and distribution of data.  We present
sufficient detail here to understand the output and to use that
information for estimating file sizes.

If integrals are stored with a threshold of greater than $10^{-10}$,
which is sufficient for nearly all purposes, then the integrals
themselves are stored in a 32-bit fixed-point format (large integrals
require special treatment).  Otherwise, the 64-bit floating-point
values are stored.  If a replicated-data calculation is being run,
then 8 bits are used for each basis function label, unless there are
more than 256 functions, in which case 16 bits are used.  If
distributed-data is being used, then the labels are always packed to
8-bits (the distributed blocks always being less than 256).

Thus, the number ($W$) of 64-bit words required to store $N$ integrals,
may be computed as
\begin{displaymath}
  W = \left\{ \\
      \begin{array}{c}
        N \mbox{ , 8-bit labels and 32-bit values} \\
        \frac{3}{2}N \mbox{ , 16-bit labels and 32-bit values} \\
        \frac{3}{2}N \mbox{ , 8-bit labels and 64-bit values} \\
        2N \mbox{ , 16-bit labels and 64-bit values} 
      \end{array}
      \right.
\end{displaymath}
The actual number is slightly bigger (less than one percent) than this
due to book-keeping overhead, and the file itself is organized into
fixed-size records.

With at least the default print level, all semidirect (not direct)
calculations will printout information similar to the following about
the integral file and the number of integrals computed.
\begin{verbatim}
 Integral file          = ./c6h6.aoints.0
 Record size in doubles =  32769        No. of integs per rec  =  32768
 Max. records in memory =      3        Max. records in file   =      5
 No. of bits per label  =      8        No. of bits per value  =     32

 #quartets = 2.0D+04  #integrals = 7.9D+05  direct = 63.6%  cached = 36.4%
\end{verbatim}
The file information relates just to process 0, but apart from the
name, will be the same on all nodes.  The information about the number
of integrals, etc., is a sum over all processes.

When the integral file is closed, additional information is printed
\begin{verbatim}
------------------------------------------------------------
EAF file 0: "./c6h6.aoints.0" size=262152 bytes
------------------------------------------------------------
               write      read    awrite     aread      wait
               -----      ----    ------     -----      ----
     calls:        6        12         0         0         0
   data(b): 1.57e+06  3.15e+06  0.00e+00  0.00e+00
   time(s): 1.09e-01  3.12e-02                      0.00e+00
rate(mb/s): 1.44e+01  1.01e+02
------------------------------------------------------------

 Parallel integral file used       4 records with       0 large values
\end{verbatim}
The detailed file information relates just to process 0, but the 
line below that indicates the total number of integral records stored
by all processes.  

This information may be used to optimize subsequent calculations.


\subsection{Options controlling convergence}
\label{sec:scfconv}

{\em Please communicate to Robert Harrison all molecules for which you
  find you have to modify the default convergence parameters --- if we
  do not know about problems we cannot fix them.  Presently, there are
  no molecules that do not converge, given sufficient iterations, with
  the default options.}

An understanding of the output of the SCF program and the options
controlling convergence requires some knowledge of the convergence
scheme.

A preconditioned conjugate gradient (PCG) method is used which has
guaranteed convergence.  Basically, the orbital gradient (the
derivative of the energy w.r.t. orbital rotations) is multiplied by a
level-shifted approximation to the inverse of the orbital Hessian to
form a search direction.  In the initial iterations (see section
\ref{sec:nrswitch}) an inexpensive one-electron approximation to the
inverse orbital Hessian is used.  Closer to convergence, the full
orbital Hessian is used, which should provide quadratic convergence.
For both the full or one-electron orbital Hessians, the
inverse-Hessian matrix-vector product is formed iteratively.
Subsequently, an approximate line search is performed along the new
search direction.  If the exact Hessian is being employed then the
line search should require a single step (of unity).  Preconditioning
with approximate Hessians may require additional steps, especially in
the initial iterations.  It is the line search that provides the
convergence guarantee.  The iterations required to solve the linear
equations are referred to as micro-iterations.  A macro-iteration
comprises both the iterative solution and a line search.

  Level-shifting plays {\em exactly} the same role in this algorithm
as it does in the conventional iterative solution of the SCF
equations.  The approximate Hessian used for preconditioning should be
positive definite.  If this is not the case, then level-shifting by a
positive constant ($\Delta$) serves to make the preconditioning matrix
positive definite by adding $\Delta$ onto all of its eigenvalues.  The
level-shifts employed for the orbital Hessian should be approximately
four times the value that one would employ in a conventional
SCF\footnote{This can be seen by considering a one-electron
approximation to the closed-shell RHF Hessian in canonical orbitals,
$A_{ia,jb} = 4 \delta_{ij} \delta_{ab} (\epsilon_a - \epsilon_i)$.}.
Level-shifting is automatically enabled in the early iterations and
the default options suffice for most test cases.

  So why do things go wrong and what can you do to fix convergence
problems?  Most problems encountered so far arise from small or
negative eigenvalues of the orbital Hessian which can occur even
though you seem to be close to convergence (as measured by the
gradient norm, or off diagonal Fock matrix elements).  Small
eigenvalues will cause the iterative linear equation solver to
converge slowly, causing an excessive number of micro-iterations.
This makes the SCF expensive, and you may even exceed the maximum
number of iterations without achieving the accuracy required for
quadratic convergence which causes more macro-iterations to be
performed.  A negative eigenvalue in the Hessian will usually also
cause slow convergence of the micro-iterations (since negative
eigenvalues are usually small) and also cause components of the
line-search direction to point uphill, which again slows convergence
of the macro-iterations and causes more steps to be taken in the line
search.

  Two solutions are relevant. If you suspect a negative eigenvalue,
the first course is to disable the Newton-Raphson until closer to
convergence (see section \ref{sec:nrswitch}), or even to disable it
completely.  At some point close to convergence the Hessian will be
positive definite.  If you disable the Newton-Raphson you should
obtain approximately the same convergence rate as DIIS.  

The second option is to apply also a small level-shift (see section
\ref{sec:level}).  This should improve the convergence rate of the
micro-iterations and stabilize the macro-iterations.  Note that
level-shifting will destroy exact quadratic convergence and that the
optimization process is automatically adjusted to reflect this by
enforcing conjugacy and reducing the accuracy to which the linear
equations are solved.  The net result of this is that you do more
macro iterations, each of which should be cheaper.

\subsection{NR}
\label{sec:nrswitch}

\begin{verbatim}
    NR <real nr_switch default 0.1>
\end{verbatim}

The exact orbital Hessian is adopted as the preconditioner
when the maximum element is below the value of \verb+nr_switch+.  The
use of the exact Hessian can be disabled by setting this number to
zero, e.g.,
\begin{verbatim}
  nr 0
\end{verbatim}

\subsection{LEVEL}
\label{sec:level}

\begin{verbatim}
   LEVEL [pcg <real initial default 20.0> \
           [<real tol default 0.5> <real final default 0.0>]] \
         [nr <real initial default 0.0> \
           [<rel tol default 0.0> <real final default 0.0>]]
\end{verbatim}

Section \ref{sec:scfconv} discussed the use of level shifts to control
convergence.  Level shifts may be set independently for both the
approximate (denoted here by PCG) and exact Hessians (denoted by
NR).  You can also have the level shift automatically changed when a
certain accuracy is attained.  The default options correspond to 
shifting the approximate Hessian by 10 until the maximum element of
the gradient falls below 0.5, at which point the shift is set to zero.
The exact Hessian is usually not shifted.

The default options correspond to
\begin{verbatim}
  level pcg 20 0.5 0 nr 0 0 0
\end{verbatim}
The following applies a shift of 0.2 to the exact Hessian
for the duration of the calculation:
\begin{verbatim}
  level nr 0.2
\end{verbatim}
To reduce this shift to zero when the maximum element of the gradient
falls below 0.005:
\begin{verbatim}
  level nr 0.2 0.005 0
\end{verbatim}


\subsection{PRINT}

All output from the SCF module is under print control.  In addition to
the standard print control keywords (section \ref{sec:printcontrol}) here
is a list of the items currently under direct print control, along
with their print levels.

\begin{tabbing}
  Very\_long\_descriptive\_name \= Print level space \= \kill
  Name                    \> Print Level \> Description \\
                          \>        \> \\
 ``atomic guess density'' \> debug  \> guess density matrix \\
 ``atomic scf''           \> debug  \> details of atomic SCF \\
 ``mo guess''             \> default\> brief info from mo guess \\
 ``information''          \> low    \> results  \\
 ``initial vectors''      \> debug  \> \\
 ``intermediate vectors'' \> debug  \> \\
 ``final vectors''        \> debug  \> \\
 ``intermediate evals''   \> debug  \> \\
 ``final evals''          \> default\> \\
 ``schwarz''              \> high   \> integral screening info \&
  stats at completion\\
 ``screening statistics'' \> debug  \> display stats after every Fock build \\
 ``geometry''             \> high   \> \\
 ``symmetry''             \> debug  \> detailed symmetry info \\
 ``basis''                \> high   \> \\
 ``geombas''              \> debug  \> detailed basis map info \\
 ``vectors i/o''          \> default\> report vectors I/O \\
 ``parameters''           \> default\> convergence parameters \\
 ``convergence''          \> default\> info each iteration
\end{tabbing}
