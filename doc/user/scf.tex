\label{sec:scf}

The NWChem self-consistent field (SCF) module computes closed-shell
restricted Hartree-Fock (RHF), restricted high-spin open-shell
Hartree-Fock (ROHF) and spin-unrestricted Hatree-FOck (UHF)
wavefunctions. 

The \verb+SCF+ directive provides input to the SCF module
and is a compound directive
\begin{verbatim}
  SCF
    ...
  END
\end{verbatim}
that encloses additional directives specific to the SCF module. 

\subsection{Type of SCF wavefunction and specification of multiplicity
and open shells}

By default a spin-restricted, closed shell RHF calculation is
performed.  An error results if the number of electrons is
inconsistent with this assumption.  The number of electrons is
inferred from the total charge on the system and the sum of the
effective nuclear charges of all centers (atoms and dummy atoms,
Section \ref{sec:geom}).  The total charge on the system is zero by
default, unless specified at some value by input on the \verb+CHARGE+
directive (Section \ref{sec:toplevel}).

The options available to define the SCF wavefunction and multiplicity
are as follows;

\begin{verbatim}
  SINGLET 
  DOUBLET 
  TRIPLET 
  QUARTET 
  QUINTET 
  NOPEN <integer nopen default 0>
  RHF
  ROHF
  UHF
\end{verbatim}

The optional keywords \verb+SINGLET, DOUBLET, TRIPLET, QUARTET, QUINTET+ 
and \verb+NOPEN+ allow the user to specify the number of open shells for a 
particular calculation.  \verb+SINGLET+ is the default, and specifies a 
closed shell; \verb+DOUBLET+ specifies one open shell; \verb+TRIPLET+
specifies two open shells; and so forth.  If there are more than four
open shells, the keword \verb+NOPEN+ must be used, with the integer
\verb+nopen+ defining the exact number of open shells.

If the multiplicity is any value other than \verb+SINGLET+, the
default calculation will be a spin-restricted, high-spin, open-shell
SCF calculation (keyword ROHF).  The open-shell orbitals must be the
highest occupied orbitals.  If necessary, any starting vectors may be
rearranged through the use of the \verb+SWAP+ keyword on the
\verb+VECTORS+ directive (see Section \ref{sec:vectors}) to accomplish
this.

A spin-unrestricted solution can also be performed by specifying the
keyword \verb+UHF+.  In UHF calculations, it is assumed that the
number of open shells corresponds to the difference between the number
of alpha-spin and beta-spin orbitals.  For example, a UHF calculation
with 2 more alpha-spin orbitals than beta-spin orbitals can be
obtained by specifying

\begin{verbatim}
scf
     triplet uhf

     ...

end
\end{verbatim}

The user should be aware that by default molecular orbitals are
symmetry adapted in NWChem.  This may not be desirable for fully
unrestricted wavefunctions.  In such cases, the user has the option of
defeating the defaults by specifying the keywords \verb+ADAPT OFF+
(see Section \ref{sec:adapt}) and \verb+SYM OFF+ (see Section
\ref{sec:sym}).

The keywords \verb+RHF+ and \verb+ROHF+ are provided in the code for
completeness. It may be necessary to specify these in order to modify
the behaviour of a previous calculation (see Section \ref{sec:persist}
  for restart behaviour).

\subsection{{\tt SYM} --- use of symmetry}
\label{sec:sym}

 \begin{verbatim}
   SYM <string (ON||OFF) default ON>
 \end{verbatim}

This directive enables/disables use of symmetry to speedup Fock matrix
construction (via the petite or skeleton algorithm) in the SCF if
symmetry was used in the specification of the geometry.  Symmetry
adaption of the molecular orbitals is not affected by this option.
The default is to use symmetry if it is specified in the geometry
directive (Section \ref{sec:geom}). 

For example, to disable use of symmetry in Fock-matrix construction
\begin{verbatim}
  sym off
\end{verbatim}

\subsection{{\tt ADAPT} -- symmetry adaptation of MOs}
\label{sec:adapt}

\begin{verbatim}
  ADAPT <string (ON||OFF) default ON>
\end{verbatim}

The default in the SCF module calculation is to force symmetry
adaption of the molecular orbitals. This does not affect the speed of
the calculation, but the resulting orbitals may be symmetry
contaminated for some problems.  This is especially likely if the
calculation is started using orbitals from a distorted geometry.

The underlying assumption in the use of symmetry in Fock matrix
contruction is that the density is totally symmetric.  If the orbitals
are symmetry contaminated, this assumption may not be valid which
could result in incorrect energies and poor convergence of the
calculation.  It is thus advisable when specifying \verb+ADAPT OFF+ to
also specify \verb+SYM OFF+ (Section \ref{sec:sym}).

\subsection{{\tt TOL2E} --- integral screening threshold}
\label{sec:tol2e}

\begin{verbatim}
  TOL2E <real tol2e default 0.01*$thresh$>
\end{verbatim}

It is generally not necessary to set this parameter directly.  Specify
instead the required precision in the wavefunction using the
\verb+THRESH+ directive (Section \ref{sec:thresh}).

The variable \verb+tol2e+ is used in determining the integral
screening threshold for the evaluation of the energy and related
Fock-like matrices.  The Schwarz inequality is used to screen upon the
product of integrals and density matrices in a manner that results in
approximately an accuracy of the value specified for \verb+tol2e+ in
the energy and Fock-matrices.  This differs from many codes where the
error in the energy is typically much greater than this threshold.

The default threshold is the minimum of $10^{-7}$ and $0.01$ times the
requested convergence threshold of the SCF calclation.  This is
suitable for nearly all purposes, though a more relaxed value of 
$10^-6$ might accelerate inaccurate exploratory calculations.

The input to specify the threshold explicitly within the
\verb+SCF+ directive is as follows, e.g.

\begin{verbatim}
  tol2e 1e-6
\end{verbatim}

\subsection{{\tt LAGRANGIAN} --- orbital lagrangian}

\begin{verbatim}
  LAGRANGIAN
\end{verbatim}

This keyword generates and dumps the orbital Lagrangian to disk. The
lagrangian is required to compute ROHF gradients but under most
circumstances this option is automatically enabled and need not be set
by the user.

\subsection{{\tt VECTORS} --- input/output of MO vectors}
\label{sec:vectors}


\begin{verbatim}
  VECTORS [[input] (<string input_movecs default atomic>) || \
                   (project <string basisname> <string filename>)] \
          [swap [alpha|beta] <integer vec1 vec2> ...] \
          [output <string output_filename default input_movecs>] \
          [lock]
\end{verbatim}

The \verb+VECTORS+ directive allows the user to specify the source and
destination of the molecular orbital vectors.  In a startup
calculation (see Section \ref{sec:start}), the default source for
guess vectors is to diagonalize a Fock matrix constructed from a
superposition of the atomic density matrices for the particular
problem.  This is usually a very good guess.  For a restarted or
continued calculation, the default is to use the previous MO vectors.

The optional keyword \verb+INPUT+ allows the specification the source
of the input molecular orbital vectors as
\begin{itemize}
\item \verb+ATOMIC+ --- the default guess of eigenvectors of a Fock-like
  matrix formed from a superposition of the atomic densities.
\item \verb+HCORE+ --- eigen vectors of the bare-nucleus or
  one-electron Hamiltonian.
\item \verb+filename+ --- the name of a file containing the MO
  vectors of a previous calculation.
\item \verb+PROJECT basisname filename+ --- projects existing MO
  vectors in the file \verb+filename+ from the smaller basis with name
  \verb+basisname+ into the current basis.  The definition of the
  basis \verb+basisname+ must be available in the current database,
  and the basis must be smaller than the current one.  In addition,
  the geometry used for the previous calculations must have the atoms
  in the same order and in the same orientation as the current
  geometry.
\end{itemize}
 
The molecular orbitals are saved every iteration and also aat the end
of the calculation.  At completion (converged or not), the SCF module
always canonicalizes the molecular orbitals by {\em separately}
diagonalizing the closed--closed, open--open and virtual--virtual
blocks of the Fock matrix.

The name of the file used to store the MO vectors is determined as
follows:
\begin{itemize}
  \item if the \verb+OUTPUT+ keyword was specified on the \verb+VECTORS+
  directive, then the following filename is used, or
  \item if the input vectors were read from a file, this file is
    reused for the output vectors (overwriting the input vectors), else
  \item a default file name is generated in the directory for
    permanent files (Section \ref{sec:dirs}) by prepending
    \verb+".movecs"+ with the file prefix, i.e.,
    \verb+"<file_prefix>.movecs"+.
\end{itemize}
The name of this file is stored in the database so that a subsequent
SCF calculation will automatically restart from these MO vectors.


Applications of this directive are illustrated in the following
examples.

Example 1:
\begin{verbatim}
  vectors output h2o.movecs
\end{verbatim}
Assuming a start-up calculation, this directive will result in use of
the default atomic density guess, and will output the vectors to the
file \verb+h2o.movecs+.

Example 2:
\begin{verbatim}
  vectors input initial.movecs output final.movecs
\end{verbatim}
This directive will result in the initial vectors being read from the
file \verb+"initial.movecs"+.  The results will be written to the file
\verb+final.movecs+.  The contents of \verb+"initial.movecs"+ will not
be changed.

Example 3:
\begin{verbatim}
  vectors input project "small basis" small.movecs
\end{verbatim}
This directive will cause the calculation to start from vectors in the
file \verb+"small.movecs"+ which are in a basis named \verb+"small
basis"+.  The output vectors will be written to the default
file \verb+"<file_prefix.movecs>"+.
 
Once starting vectors have been obtained using any of the possible
options, they may be reordered through use of the \verb+SWAP+ keyword.
This optional keyword requires a list of orbital pairs that will be
swapped.  For UHF calculations, separate \verb+SWAP+ keywords may be
provided for the alpha and beta orbitals, as necessary.  

An example of use of the \verb+SWAP+ directive:
\begin{verbatim}
  vectors input try1.movecs swap 173 175 174 176 output try2.movecs
\end{verbatim}
This directive will cause the initial orbitals to be read from the
file \verb+"try1.movecs"+.  The vectors for the orbitals within the
pairs 173--175 will be swapped with those within 174--176.  The final
orbitals obtained in the calculation will be written to the file
\verb+"try2.movecs"+.

Another example, now illustrating this feature for a UHF calculation
is the directive
\begin{verbatim}
  vectors swap beta 4 5 swap alpha 5 6
\end{verbatim}
This input will result in the swapping of the 5--6 alpha orbital pair and 
the 4--5 beta orbital pair.  (All other items in the input use the
default values.)

The \verb+LOCK+ keyword allows the user to specify that the ordering
of orbitals will be locked to that of the initial vectors, as far as
possible. The default is to order by ascending orbital energies within
each orbital space. One application where this might be desirable is a
calculation where it is necessary to preserve the ordering of a
previous geometry despite flipping of orbital energies.  For such a
case, the \verb+LOCK+ directive can be used to prevent the SCF
calculation from changing the ordering, even if the orbital energies
change.

\subsubsection{Atomic guess orbitals with charged atoms}

If some atoms are significantly charged, then the default guess of
superimposing the densities of the neutral atoms may be improved upon
by modifying the atomic densities.  This is done by adding factional
charges to the occupation of the valence atomic orbitals.  This is
acomplished by setting parameters used by the atomic SCF program which
does not have its own input block, and therefore the \verb+SET+
directive (Section \ref{sec:set}) must be used.

The input specifies a list of tags (i.e., names of atoms in a
geometry, see Section \ref{sec:geom}) and the charges to be added to
those centers.  Two parameters must be set as follows:
\begin{verbatim}
  set atomscf:tags_z <string list_of_tags>
  set atomscf:z      <real list_of_charges>
\end{verbatim}

The arrary of strings \verb+atomscf:tags_z+ should be set to the list
of tags and array \verb+atomscf:z+ should be set to the list of tags.
All atoms that have the same tag as one specified in this list will be
assigned the corresponding charge.

For example, the following specifies that all oxygen atoms with tag
\verb+O+ be assigned a charge of \verb+-1+ and all iron atoms with tag
\verb+Fe+ be assigned a charge of \verb=+2=
\begin{verbatim}
  set atomscf:z        -1  2
  set atomscf:tags_z    O  Fe
\end{verbatim}

There are some limitations to this feature.  It is not possible to add
electrons to closed shell atoms, nor is it possible to remove all
electrons from a given atom.  Attempts to do so will cause the code to
report an error, and it will not report further errors in the input
for modifying the charge even when they are detected.

Finally, recall that the database is persistent (Section
\ref{sec:persist}) and the above settings will be used in subsequent
atomic guess calculations unless the data is deleted from the database
with the \verb+UNSET+ directive (Section \ref{sec:unset}).


\subsection{{\tt THRESH} --- convergence threshold}
\label{sec:thresh}

\begin{verbatim}
  THRESH  <real thresh default 1.0e-4>
\end{verbatim}

This directive specifies the convergence threshold for the
calculation.  The convergence threshold is the norm of the orbital
gradient, and has a default value in the code of $10^{-4}$.

The norm of the orbital gradient corresponds roughly to the precision
available in the wavefunction, and the energy should be converged to
approximately the square of this number.  It should be noted, however,
that the precision in the energy will not exceed that of the integral
selection tolerance.  This tolerance (Section \ref{sec:tol2e}) is
automatically set from the convergence threshold, so that sufficient
precision is usually available by default.

The default convergence threshold suffices for most SCF energy and
geometry optimization calculations, providing about 6--8 decimal
places in the energy, and about four significant figures in the
density and derivative w.r.t.\ nuclear coordinates.  However, weakly
interacting systems, floppy molecules, finite-difference of gradients
to compute the Hessian, and post-Hartree-Fock calculations may require
greater precision.  A threshold of $10^{-6}$ is adequate for most such
purposes, and a threshold of $10^{-8}$ might be necessary for very
high accuracy or very weak interactions.  A threshold of $10^{-10}$
should be regarded as the best that can be attained in most
circumstances.

\subsection{{\tt MAXITER} --- iteration limit}
\label{sec:max}

\begin{verbatim}
  MAXITER <integer maxiter default 8>
\end{verbatim}

The maximum number of iterations for the SCF calculation defaults to
eight for ROHF/RHF calculations and 20 for UHF.  For most molecules,
this number of iterations is sufficient for the quadratically
convergent SCF algorithm to obtain a solution converged to the
default threshold (see Section \ref{sec:thresh} above).  If the SCF
program detects that the quadratically-convergent algorithm is not
efficient, then it will resort to a linearly-convergent algorithm and
increase the maximum number of iterations by 10.

Convergence may not be reached in the maximum number of iterations for
many reasons, including input error (e.g., an incorrect geometry or
linearly dependent basis), a very low convergence threshold, a poor
initial guess, or the system is intrinsically hard to converge. 

The following sets the maximum no. of SCF iterations to 50
\begin{verbatim}
  maxiter 50
\end{verbatim}

\subsection{{\tt RI} --- resolution of the identity approximation}
\label{sec:riscf}

The resolution of the identity (RI) approximation (using the
V-approximation of Alml\"{o}f and Vahtras) is automatically invoked if
a basis set named \verb+"riscf basis"+ is present in the database.
This basis will be used as the fitting basis.  The RI-SCF method
provides most computational speedup with least loss of accuracy when
applied to relatively small molecules in larage basis sets.
Calculations on large molecules in modest basis sets will not realize
a significant performance gain from RISCF.

By default the full RISCF approximation will be applied and the
\verb+RI+ directive serves to modify the extent of the approximation
and the computational strategy.

\begin{verbatim}
   RI [<string (hessian || preconverge || full) default full>] \
      [<string (disk || memory || auto) default memory>]
\end{verbatim}

The first three parameters determine the extent of the approximation:
\begin{itemize} 
\item \verb+FULL+ --- is the default and specifies that the RI
  approximation will be used for all Fock builds in the calculation.
  This is the fastest of the three options (perhaps 3--10 times faster
  than direct SCF), but will result in only an approximate value for
  the energy.

\item \verb+HESSIAN+ --- only the orbital Hessian will be calculated
  with an approximated Fock matrix.  This will yield an exact energy
  and wavefunction and using the quadratically convergent SCF
  algorithm should result in a 1.5--2 fold speedup over direct SCF.

\item \verb+PRECONVERGE+ --- specifies a two-part calculation.  First,
  the SCF calculation will be performed with the full RI
  approximation.  Then an ``exact'' direct SCF calculation using the
  RI approximated Hessian will be performed (the same as the above
  \verb+HESSIAN+ option).  An exact energy and wavefunction will be
  obtained.
\end{itemize}

The next three paramters determine the computational strategy:
\begin{itemize}
\item \verb+AUTO+ --- This is the default option which allows the code
  to make its own decision on where to store the 3-center integrals.
  If there is enough memory available, it will use the in-core option;
  otherwise, the disk-based algorithm will be used, if available.

\item \verb+MEMORY+ --- This forces storage of the 3-center integrals
  in memory.  If insufficient memory is available an error results.

\item \verb+DISK+ --- If the ''Disk Resident Array'' library is
  implemented in the user's installation of NWChem, the keyword
  \verb+DISK+ can be used to specify that the 3-center integrals will
  be stored on disk.  Otherwise an error results.
\end{itemize}

\subsection{{\tt PROFILE} --- performance profile}

This directive allows the user to obtain a timing and parallel
execution information about the SCF module.  It is specified by the
simple keyword

\begin{verbatim}
  PROFILE
\end{verbatim}

This option can be helpful in understanding the computational
performance of an SCF calculation.  However, on machines that have
expensive timing routines, such as the SUN, it can introduce a
significant overhead.

\subsection{{\tt DIIS} --- DIIS convergence}

This directive allows the user to specify DIIS convergence rather than
second-order convergence for the SCF calculation.  The form of the
directive is as follows;

\begin{verbatim}
  DIIS
\end{verbatim}

When this option is specified in the input, the \verb+MAXITER+
directive (see Section \ref{sec:max}) must also be specified, with the
macro-iteration count \verb+maxiter+ set to a value around 20.  The
implementation of this option is currently fairly rudimentary.  It
does not have level-shifting and damping, and does not support
open-shells or UHF.  It is provided on an ``as is'' basis, and should
be used with caution.

When the \verb+DIIS+ directive is specified in the input, the user has
the additional option of specifying the size of the subspace for the DIIS
extrapolation.  This is accomplished with the \verb+DIISBAS+ directive,
which is of the form,
\begin{verbatim}
  DIISBAS <integer diisbas default 5>
\end{verbatim}
The default of 5 should be adequate for most applications, but may be
increased if convergence is poor.  On large systems, it may be necessary
to specify a lower value for \verb+diisbas+, to conserve memory.

\subsection{{\tt DIRECT} and {\tt SEMIDIRECT} --- recomputation of integrals}
\label{sec:semidirect}

The default behaviour of the SCF module is
\begin{itemize}
\item if there is enough memory available, the integrals are computed
   once and cached in memory.
 \item If there is not enough memory to store all of the integrals at
   once, then 95\% of the available disk space in the scratch
   directory (see Section \ref{sec:dirs}) is assumed available for
   this purpose, and as many integrals as possible are cached on disk
   (with no memory being used for caching).  Some attempt is made to
   store the most expensive integrals in the cache.  (Note that no
   allowance is made for processes sharing disks when computing
   available space.)
 \item If there is not enough room in memory or on disk for all of the
   integrals, then the ones that are not cached are recomputed in a
   semi-direct fashion.
\end{itemize}

The integral file is deleted at the end of a calculation, so it is not
possible to restart a semi-direct calculation when the integrals are
cached in memory or on disk.  Many computer systems (e.g., the EMSL
IBM SP) clear the fast scratch space at the end of each job, adding a
further complication to the problem of restarting a {\em parallel}
semi-direct calculation.  Under some situations, it is possible to
restart from integrals on disk, but this capability will not be made
widely available until a later date.

On the IBM SP or any other computer with fast disks local to each
processor, semi-direct gives the best behaviour.  It can result in
{\em quadratic speedup} as more processors are added.  On other
machines, it may be necessary to resort to additional strategies to
achieve faster performance, such as limiting the use of disk space,
forcing the use of more memory for caching, changing the default file
names, or using fully-direct SCF.

The user has the option of forcing a fully-direct calculation (with
recomputation of the integrals each iteration).  This is accomplished
by specifying the directive

\begin{verbatim}
  DIRECT
\end{verbatim}

Alternatively, the \verb+SEMIDIRECT+ directive can be used to control
the default semi-direct calculation by defining the amount of disk
space and the cache memory size.  The form of this directive is as
follows;

\begin{verbatim}
   SEMIDIRECT [filesize <integer filesize default disksize>] 
              [memsize  <integer memsize default available>]
              [filename <string filename default $file_prefix.aoints$>]
\end{verbatim}

The keyword \verb+FILESIZE+ allows the user to define an integer value
for \verb+filesize+ to specify the amount of disk space to be used per
process for storing integrals in 64-bit words.  Similarly, the keyword
\verb+MEMSIZE+ allows the user to specify \verb+memsize+, the number
of 64-bit words to be used per process for caching integrals in
memory. (Note: If the amount of storage space specified by the entry
for \verb+memsize+ is not available, the code cuts the value in half
and checks again for available space.  This process is repeated until
the request is satisfied.)  

By default, the integral file is placed into the scratch directory
(see Section \ref{sec:dirs}). Specifying the keyword \verb+FILENAME+
overrides this default.  The user-specified name entered in the string
\verb+filename+ has the process number appended to it, so that each
process has a distinct file but with a common basename and directory.
Therefore, it is not possible to use this keyword to specify different
disks for different processes.  The \verb+SCRATCH_DIR+ directive (see
Section \ref{sec:dirs}) can be used for this purpose.

For example, to force full recomputation of all integrals
\begin{verbatim}
  direct
\end{verbatim}

Exactly the same result could be obtained by entering the directive
\begin{verbatim}
  semidirect filesize 0 memsize 0
\end{verbatim}

To disable the use of memory for caching integrals and limit disk
usage by each process to 100 MW:
\begin{verbatim}
  semidirect memsize 0 filesize 100000000
\end{verbatim}


\subsubsection{Integral File Size and Format for the SCF Module}

The file format is rather complex since it accomodates a variety of
packing and compression options and distribution of data.  This
section presents some information that may help the user understand
the output and illustrates how to use the output information to
estimate file sizes.

If integrals are stored with a threshold of greater than $10^{-10}$,
then the integrals themselves are stored in a 32-bit fixed-point
format (with special treatment for large values to retain precision).
If integrals are stored with a threshold that is less than $10^{-10}$,
howwever, the values are stored in 64-bit floating-point format.  If a
replicated-data calculation is being run, then 8 bits are used for
each basis function label, unless there are more than 256 functions,
in which case 16 bits are used.  If distributed-data is being used,
then the labels are always packed to 8-bits (the distributed blocks
always being less than 256).

Thus, the number ($W$) of 64-bit words required to store $N$
integrals, may be computed as
\begin{displaymath}
  W = \left\{ \\
      \begin{array}{c}
        N \mbox{ , 8-bit labels and 32-bit values} \\
        \frac{3}{2}N \mbox{ , 16-bit labels and 32-bit values} \\
        \frac{3}{2}N \mbox{ , 8-bit labels and 64-bit values} \\
        2N \mbox{ , 16-bit labels and 64-bit values} 
      \end{array}
      \right.
\end{displaymath}

The actual number of words required can be up to about one percent
larger than the value of $W$ computed by the above relationship.  This
is due to bookkeeping overhead, and because the file itself is
organized into fixed-size records.

With at least the default print level, all semidirect (not direct)
calculations will print out information about the integral file and
the number of integrals computed.  The form of this output is as
follows;

\begin{verbatim}
 Integral file          = ./c6h6.aoints.0
 Record size in doubles =  32769        No. of integs per rec  =  32768
 Max. records in memory =      3        Max. records in file   =      5
 No. of bits per label  =      8        No. of bits per value  =     32

 #quartets = 2.0D+04  #integrals = 7.9D+05  direct = 63.6%  cached = 36.4%
\end{verbatim}

The above file information relates only to process 0.  The information
about the number of integrals, etc., is a sum over all processes.

When the integral file is closed, additional information of the following
form is printed.

\begin{verbatim}
------------------------------------------------------------
EAF file 0: "./c6h6.aoints.0" size=262152 bytes
------------------------------------------------------------
               write      read    awrite     aread      wait
               -----      ----    ------     -----      ----
     calls:        6        12         0         0         0
   data(b): 1.57e+06  3.15e+06  0.00e+00  0.00e+00
   time(s): 1.09e-01  3.12e-02                      0.00e+00
rate(mb/s): 1.44e+01  1.01e+02
------------------------------------------------------------

 Parallel integral file used       4 records with       0 large values
\end{verbatim}
The detailed file information relates just to process 0, but the 
line below that indicates the total number of integral records stored
by all processes.  

This information may be used to optimize subsequent calculations.


\subsection{SCF Convergence Control Options}
\label{sec:scfconv}

{\em Note to users:} It is desired that the SCF program converge
reliably with the default options for a wide variety of molecules.  In
addition it should be guaranteed to converge sufficient iterations for
any system.  Please report significant convergence problems to
\verb+nwchem+-\verb+support@+\-\verb+emsl.pnl.gov+, including the
input file. 

% An understanding of the output of the SCF program and the options
% controlling convergence requires some knowledge of the convergence
% scheme.

The SCF program uses a preconditioned conjugate gradient (PCG) method
that is unconditionally convergent.  Basically, the orbital gradient
(the derivative of the energy with respect to the orbital rotations)
is multiplied by an approximation to the inverse of the level-shifted
orbital Hessian to form a search direction.  In the initial iterations
(see Section \ref{sec:nrswitch}) an inexpensive one-electron
approximation to the inverse orbital Hessian is used.  Closer to
convergence, the full orbital Hessian is used, which should provide
quadratic convergence.  For both the full or one-electron orbital
Hessians, the inverse-Hessian matrix-vector product is formed
iteratively.  Subsequently, an approximate line search is performed
along the new search direction.  If the exact Hessian is being
employed then the line search should require a single step (of unity).
Preconditioning with approximate Hessians may require additional
steps, especially in the initial iterations.  It is the (approximate)
line search that provides the convergence guarantee.  The iterations
required to solve the linear equations are referred to as
micro-iterations.  A macro-iteration comprises both the iterative
solution and a line search.

Level-shifting plays {\em exactly} the same role in this algorithm as
it does in the conventional iterative solution of the SCF equations.
The approximate Hessian used for preconditioning should be positive
definite.  If this is not the case, then level-shifting by a positive
constant ($\Delta$) serves to make the preconditioning matrix positive
definite by adding $\Delta$ onto all of its eigenvalues.  The
level-shifts employed for the RHF orbital Hessian should be
approximately four times (only twice for UHF) the value that one would
employ in a conventional SCF\footnote{This can be seen by considering
  a one-electron approximation to the closed-shell RHF Hessian in
  canonical orbitals, $A_{ia,jb} = 4 \delta_{ij} \delta_{ab}
  (\epsilon_a - \epsilon_i)$.  Similarly, for UHF the level shift
  should be twice as large.}.  Level-shifting is automatically enabled
in the early iterations and the default options suffice for most test
cases.

So why do things go wrong and what can be done to fix convergence
problems?  Most problems encountered so far arise from small or
negative eigenvalues of the orbital Hessian which can occur even
though you seem to be close to convergence (as measured by the
gradient norm, or off diagonal Fock matrix elements).  Small
eigenvalues will cause the iterative linear equation solver to
converge slowly, causing an excessive number of micro-iterations.
This makes the SCF expensive in terms of computation time, and it is
possible to exceed the maximum number of iterations without achieving
the accuracy required for quadratic convergence which causes more
macro-iterations to be performed.  A negative eigenvalue in the
Hessian will usually also cause slow convergence of the
micro-iterations (since negative eigenvalues are usually small) and
also cause components of the line-search direction to point uphill,
which again slows convergence of the macro-iterations and causes more
steps to be taken in the line search.

There are two main options available when a problem will not converge;
Newton-Raphson can be disabled temporarily or permanently, and
level-shifting can be applied to the matrix.  In some cases, both
options may be necessary to acheive final convergence.

If there is reason to suspect a negative eigenvalue, the first course
is to disable the Newton-Raphson iteration until the solution is
closer to convergence.  It may be necessary to disable it completely.
At some point close to convergence, the Hessian will be positive
definite, so disabling Newton-Raphson should yeild a solution with
approximately the same convergence rate as DIIS.

If temporarily disabling Newton-Raphson is not sufficient to acheive
convergence, it may be necessary to disable it entirely and apply a
small level-shift to the approximate Hessian.  This should improve the
convergence rate of the micro-iterations and stabilize the
macro-iterations.  The level-shifting will destroy exact quadratic
convergence, but the optimization process is automatically adjusted to
reflect this by enforcing conjugacy and reducing the accuracy to which
the linear equations are solved.  The net result of this is that the
solution will do more macro-iterations, but each one should take less
time than it would with the unshifted Hessian.

The following subsections describe the directives needed to disable the
Newton-Raphson iteration and specify level-shifting.


\subsection{{\tt NR} --- controlling the Newton-Raphson}
\label{sec:nrswitch}

\begin{verbatim}
    NR <real nr_switch default 0.1>
\end{verbatim}

The exact orbital Hessian is adopted as the preconditioner when the
maximum element of the orbital gradient is below the value specified
for \verb+nr_switch+.  The default value is 0.1, which means that
Newton-Raphson will be disabled until the maximum value of the orbital
gradient (twice the largest off-diagonal Fock-matrix element) is less
than 0.1.   To disable the second-order Newton-Raphson entirely, the
value of \verb+nr_switch+ must be set to zero.  The directive to accomplish
this is as follows:
\begin{verbatim}
  nr 0
\end{verbatim}

\subsection{{\tt LEVEL} --- level-shifting the orbital Hessian}
\label{sec:level}

This directive allows the user to specify level-shifting to obtain a
positive-definite preconditioning matrix for the SCF solution
procedure.  Separate level shifts can be set for the first-order
convergent one-electron approximation to the Hessian used with the
preconditioned conjugate gradient (PCG) method, and for the full
Hessian used with the Newton Raphson (NR) approach.  It is also
possible to change the level-shift automatically as the solution
attains some specified accuracy.  The form of the directive is as
follows;

\begin{verbatim}
   LEVEL [pcg <real initial default 20.0> \
           [<real tol default 0.5> <real final default 0.0>]] \
         [nr <real initial default 0.0> \
           [<rel tol default 0.0> <real final default 0.0>]]
\end{verbatim}

% Section \ref{sec:scfconv} discussed the use of level shifts to control
% convergence.  Level shifts may be set independently for both the
% approximate (denoted here by PCG) and exact Hessians (denoted by
% NR).  You can also have the level shift automatically changed when a
% certain accuracy is attained.  

This directive contains only two keywords; one for the PCG method and
the other for the exact Hessians.  Specifying the keyword \verb+pcg+
allows the user to define the level shifting for the approximate
(i.e., PCG) method.  Specifying the keyword \verb+nr+ allows the user
to define the level shifting for the exact Hessians.  In both options,
the initial level shift is defined by the value specified for the
variable \verb+initial+.  Optionally, \verb+tol+ can specified
independently with each keyword to define the level of accuracy that
must be attained in the solution before the level shifting is changed
to the value specified by input in the real variable \verb+final+.

For the PCG method (as specified using the keyword \verb+pcg+), the
defaults for this input are 20.0 for \verb+initial+, 0.5 for
\verb+tol+, and 0.0 for \verb+final+.  This meeans that the
approximate Hessian will be shifted by 20.0 until the maximum element
of the gradient falls below 0.5, at which point the shift will be set
to zero.

For the exact Hessian (as specified using the keyword \verb+nr+), the
defaults are all zero.  The exact Hessian is usually not shifted since
this destroys quadratic convergence.  An example of an input directive
that applies a shift of 0.2 to the exact Hessian is as follows;

\begin{verbatim}
  level nr 0.2
\end{verbatim}

To apply this shift to the exact Hessian only until the maximum
element of the gradient falls below 0.005, the required input
directive is as follows;

\begin{verbatim}
  level nr 0.2 0.005 0
\end{verbatim}

Note that for both of these examples the parameters for the PCG method
are at the default values.  To obtain values different from the
defaults, the keyword \verb+pcg+ must be specified also.  For example,
to specify the level shifting in the above example for the exact
Hessian {\em and} non-default shifting for the PCG method, the
directive would be something like the following;

\begin{verbatim}
  level pcg 20 0.3 0.0 nr 0.2 0.005 0.0
\end{verbatim}

This input will cause the PCG method to be level-shifted by 20.0 until
the maximum element of the gradient falls below 0.3, then the shift
will be zero.  For the exact Hessian, the level shifting is initially
0.2, until the maximum element falls below 0.005, after which the
shift is zero.  (use of PCG or NR is determined by the input specified
for \verb+nr_switch+ on the \verb+NR+ directive, Section
\ref{sec:nrswitch} above.)

The default options correspond to
\begin{verbatim}
  level pcg 20 0.5 0 nr 0 0 0
\end{verbatim}


\subsection{Printing Information from the SCF Module}
\label{sec:scfprint}

All output from the SCF module is controlled using the \verb+PRINT+
directive described in Section \ref{sec:printcontrol}.  The following 
list describes the items from SCF that are currently under direct 
print control, along with the print level or each one.

\begin{tabbing}
  Very\_long\_descriptive\_name \= Print level space \= \kill
  Name                    \> Print Level \> Description \\
                          \>        \> \\
 ``atomic guess density'' \> debug  \> guess density matrix \\
 ``atomic scf''           \> debug  \> details of atomic SCF \\
 ``mo guess''             \> default\> brief info from mo guess \\
 ``information''          \> low    \> results  \\
 ``initial vectors''      \> debug  \> \\
 ``intermediate vectors'' \> debug  \> \\
 ``final vectors''        \> debug  \> \\
 ``intermediate evals''   \> debug  \> \\
 ``final evals''          \> default\> \\
 ``schwarz''              \> high   \> integral screening info \&
  stats at completion\\
 ``screening statistics'' \> debug  \> display stats after every Fock build \\
 ``geometry''             \> high   \> \\
 ``symmetry''             \> debug  \> detailed symmetry info \\
 ``basis''                \> high   \> \\
 ``geombas''              \> debug  \> detailed basis map info \\
 ``vectors i/o''          \> default\> report vectors I/O \\
 ``parameters''           \> default\> convergence parameters \\
 ``convergence''          \> default\> info each iteration
\end{tabbing}

If no \verb+PRINT+ directives are defined explicitly in the input for
the SCF module, the printed output from an SCF calculation will
consist only of the above items with a ``default'' print level (i.e.,
\verb+''mo guess''+, \verb+''final evals''+, \verb+''vectors i/o''+,
\verb+''parameters''+, and \verb+''convergence''+).  If the keyword
\verb+debug+ is explicitly invoked on a \verb+PRINT+ directive, the
output will include all items in the above list with a print level of
\verb+debug+, in addition to the items with a print level of
\verb+default+.  If the keyword \verb+high+ is also invoked, all items
in the above list will be printed.  If only the keyword \verb+low+ is
invoked, the only item that will be printed is \verb+''information''+.



