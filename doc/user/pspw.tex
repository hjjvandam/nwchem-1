\label{sec:pspw}

\newcounter{algcounter}[chapter]
\def\thealgcounter{\thechapter.\arabic{algcounter}}
\newenvironment{algorithm}[1]
               { \refstepcounter{algcounter}
                \begin{center}
                  {\bf Algorithm} \thealgcounter: #1
                \end{center}
               \begin{center}\begin{enumerate} \em}
               {\end{enumerate}\end{center}}


A pseudopotential plane-wave (PSPW) module, which can perform Car-Parrinello
simulations, is being implemented into the NWChem program package.  
This module complements the capabilities of NWChem by including code 
which allows for the calculation of density functional theory total energies 
and forces with the technology based on plane-wave basis sets and 
pseudopotentials.  Consistent with NWChem's philosophy this module is able 
to run on a variety of architectures, including parallel supercomputers.

The advantage of a PSPW method is that it has been shown to have an accuracy 
close to chemical accuracy for many a  pplications, yet is still fast enough 
to treat systems containing hundreds of atoms.  Another significant advantage 
is its ability to simulate dynamics on a ground state potential surface 
directly at run-time.  This method's efficiency and accuracy make it a 
desirable first principles method of simulation in the study of complex 
molecular, liquid, and solid state systems.  Applications for this first 
principles method include the calculation of free energies, search for 
global minima, explicit simulation of solvated molecules, and simulations 
of complex vibrational modes that cannot be described within the harmonic 
approximation.

Section \ref{sec:pspw_tasks} describes the tasks contained within the PSPW module. 
Then the RTDB entries and datafiles used by the 
PSPW module are described in section \ref{sec:pspw_data},  Car-Parrinello output 
data files are described in section \ref{sec:pspw_cp_data}, and the minimization 
and Car-Parrinello algorithms are described in sections 
\ref{sec:pspw_Minimize}-\ref{sec:pspw_Car-Parrinello}. Examples of how to setup and run
a steepest descent simulation and a Car-Parrinello simulation are presented
in sections \ref{sec:pspw_sd}-\ref{sec:pspw_cp}.  Finally in section
\ref{sec:pspw_limits} the capabilities and limitations of the PSPW
module are discussed.

If you are a first time user of this module it is recommended that you skip
the next five sections and proceed directly to the tutorials in sections 
\ref{sec:pspw_sd}-\ref{sec:pspw_cp}.

\section{PSPW Tasks}
\label{sec:pspw_tasks}

All input to the PSPW Tasks is contained within the compound PSPW  block,
\begin{verbatim}
PSPW
   ...
END
\end{verbatim}

To perform an actual calculation a TASK PSPW directive is used.  The TASK
cg\_pspw directive may also be used (see below).  The format for the 
TASK PSPW directive is the TASK directive followed by the 
PSPW string, and after that an $<$operation$>$ string is required.  The 
TASK PSPW directive for PSPW calculations is of the following form:
\begin{verbatim}
TASK PSPW [steepest_descent           ||
           conjugate_gradient         ||
           Car-Parrinello             ||
           psp_formatter              ||
           wavefunction_initializer   ||
           v_wavefunction_initializer ||
           wavefunction_expander      ||
           psp_generator              ||
           (no default)]
\end{verbatim}
Currently available tasks are listed.  Note that unlike most 
NWChem modules, the PSPW module does not contain an energy operation.  
This means that there is no default operation and hence an operation must 
always be specified. 

PSPW tasks are of two types.  The first type of 
task is used to setup or change needed data files for a 
PSPW simulation.  Tasks of this type are psp\_formatter, 
wavefunction\_initializer, v\_wavefunction\_initializer, 
wavefunction\_expander, and psp\_generator.  The second type 
of task is used to actually run a PSPW simulation.  Tasks 
of this type are steepest\_descent, and Car-Parrinello.
The following subsections describe the input to these tasks.

The PSPW module is also interfaced to driver, stepper, and freqency task 
operations through the cg\_pspw theory directive, see 
section \ref{sec:first_task}. The PSPW conjugate\_gradient sub-module is used
in this interface.  Specifically the following task operations 
are interafaced using the cg\_pspw theory directive.
\begin{verbatim}
TASK cg_pspw energy      #equivalent to TASK PSPW conjugate_gradient           
TASK cg_pspw gradient         
TASK cg_pspw optimize         
TASK cg_pspw saddle           
TASK cg_pspw freqencies       
TASK cg_pspw vib
\end{verbatim}


\subsection{STEEPEST\_DESCENT} 

The steepest\_descent task is used to optimize the one-electron orbitals
with respect to the total energy.  In addition it can also be used to optimize
geometries.   This method is meant to be used for coarse optimization of
the one-electron orbitals.  A detailed description of the this method
is described in section \ref{sec:pspw_sd2}

Input to the steepest\_descent simulation is contained
within the steepest\_descent sub-block.
\begin{verbatim}
PSPW
  ...
  STEEPEST_DESCENT
     ...
  END
  ...
END
\end{verbatim}
and to run a steepest\_descent calculation the following directive is used:
\begin{verbatim}
TASK PSPW steepest_descent 
\end{verbatim}
The steepest\_descent sub-block contains a great deal
of input, including pointers to RTDB data, pointers to data, as well as
parameter input.  Listed below is the format of a STEEPEST\_DESCENT sub-block.
\begin{verbatim}
PSPW
...
   STEEPEST_DESCENT
      CELL_NAME: <string cell_name>
      [GEOMETRY_OPTIMIZE]
      (FORMATTED_FILENAME: <string formatted_name>)+
      INPUT_WAVEFUNCTION_FILENAME:  <string input_wavefunctions  default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME: <string output_wavefunctions default input_movecs>
      FAKE_MASS: <real fake_mass default 400000.0>
      TIME_STEP: <real time_step default 5.8>
      LOOP: <integer inner_iteration outer_iteration default 10 1>
      TOLERANCES: <real tole tolc tolr default 1.0d-9 1.0d-9 1.0d-4>
      ENERGY_CUTOFF:       <real ecut default (see input desciption)>
      WAVEFUNCTION_CUTOFF: <real wcut default (see input description)>
      EWALD_NCUT: <integer ncut default 1>]
      EWALD_RCUT: <real rcut default (see input description)>
      EXCHANGE_CORRELATION: (Vosko || PBE96  default Vosko)
      [MULLIKEN]

   END
...

END
\end{verbatim}
The following list describes the input for the STEEPEST\_DESCENT
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$. See section \ref{sec:pspw_cell}.
	\item GEOMETRY\_OPTIMIZE - optional keyword which if specified
	      turns on geometry optimization. 	
	\item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
	\item $<$input\_wavefuncitons$>$ - name that points
              to a file containing one-electron orbitals
	\item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
	\item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$).
	\item $<$time\_step$>$ - value for the time step ($\Delta t$).
	\item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
	\item $<$outer\_iteration$>$ - number of outer iterations
 	\item $<$tole$>$ - energy tolerance requested.
	\item $<$tolc$>$ - one-electron orbital tolerance requested.
	\item $<$tolr$>$ - ion position tolerance requested.
	\item $<$ecut$>$ - value for the cutoff energy used
                           to define the density.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
	\item $<$wcut$>$ - value for the cutoff energy used
 			   to define the one-electron orbitals. Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
	\item $<$ncut$>$ - value for the number of unit cells
 			  to sum over (in each direction) for the real space
			  part of the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic.
	\item $<$rcut$>$ - value for the cutoff radius used
			  in the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                          Default set to be
		          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item MULLIKEN - optional keyword which if specified
                         causes a Mulliken anaysis to be performed at
                         the end of the simulation.  For this option
	                 to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
\end{itemize}


\subsection{CONJUGATE\_GRADIENT} 

The conjugate\_descent task is used to optimize the one-electron orbitals
with respect to the total energy.  This method should be used for finer
optimization. It is better to the the steepest\_descent task When intitially 
optimizing the one-electron orbitals.  A detailed description of the this method
is described in section \ref{sec:pspw_cgmanifold}.


Input to the conjugate\_gradient simulation is contained
within the conjugate\_gradient sub-block.
\begin{verbatim}
PSPW
  ...
  CONJUGATE_GRADIENT
     ...
  END
  ...
END
\end{verbatim}
and to run a conjugate\_gradient calculation the following directive is used:
\begin{verbatim}
TASK PSPW conjugate_gradient 
\end{verbatim}
The conjugate\_gradient sub-block contains a great deal
of input, including pointers to RTDB data, pointers to data, as well as
parameter input.  Listed below is the format of a conjugate\_gradient sub-block.
\begin{verbatim}
PSPW
...
   CONJUGATE_GRADIENT
      CELL_NAME: <string cell_name>
      {FORMATTED_FILENAME: <string formatted_name>}+
      INPUT_WAVEFUNCTION_FILENAME:  <string input_wavefunctions  default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME: <string output_wavefunctions default input_movecs>
      [FAKE_MASS: <real fake_mass default 400000.0>]
      [TIME_STEP: <real time_step default 5.8>]
      LOOP: <integer inner_iteration outer_iteration default 10 1>
      TOLERANCES: <real tole tolc tolr default 1.0e-9 1.0e-9 1.0e-4>
      ENERGY_CUTOFF:       <real ecut default (see input description)>
      WAVEFUNCTION_CUTOFF: <real wcut default (see input description)>
      EWALD_NCUT: <integer ncut default 1>]
      EWALD_RCUT: <real rcut default (see input description)>
      EXCHANGE_CORRELATION: (Vosko || PBE96  default Vosko)
      [MULLIKEN]

   END
...

END
\end{verbatim}
The following list describes the input for the CONJUGATE\_GRADIENT
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
	\item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
	\item $<$input\_wavefuncitons$>$ - name that points
              to a file containing one-electron orbitals
	\item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
	\item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$). This parameter is not presently used in a 
              conjugate gradient simulation
	\item $<$time\_step$>$ - value for the time step ($\Delta t$).  This
              parameter is not presently used in a conjugate gradient simulation.
	\item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
	\item $<$outer\_iteration$>$ - number of outer iterations
 	\item $<$tole$>$ - energy tolerance requested.
	\item $<$tolc$>$ - one-electron orbital tolerance requested.
	\item $<$tolr$>$ - ion position tolerance requested.
	\item $<$ecut$>$ - value for the cutoff energy used
                           to define the density. Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
	\item $<$wcut$>$ - value for the cutoff energy used
 			   to define the one-electron orbitals.
                           Default is set to be the maximum value that 
                           will fix within the simulation\_cell $<$cell\_name$>$.
	\item $<$ncut$>$ - value for the number of unit cells
 			  to sum over (in each direction) for the real space
			  part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
	\item $<$rcut$>$ - value for the cutoff radius used
			  in the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                           Default set to be
		          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item MULLIKEN - optional keyword which if specified
                         causes a Mulliken anaysis to be performed at
                         the end of the simulation.  For this option
	                 to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
\end{itemize}





\subsection{Car-Parrinello}
The Car-Parrinello task is used to perform ab initio molecular dynamics
using the scheme developed by Car and Parrinello.  In this unified ab
initio molecular dynamics scheme the motion of the ion cores is coupled to
a fictacious motion for the Kohn-Sham orbitals of density functional
theory.  Constant energy or constant temperature simulations can be
performed.  A detailed description of the this method
is described in section \ref{sec:pspw_Car-Parrinello}.


  Input to the Car-Parrinello 
simulation is contained within the Car-Parrinello sub-block.
\begin{verbatim}
PSPW
  ...
  Car-Parrinello
     ...
  END
  ...
END
\end{verbatim}
and to run a Car-Parrinello calculation the following directive is used:
\begin{verbatim}
TASK PSPW Car-Parrinello 
\end{verbatim}
The Car-Parrinello sub-block contains a great deal
of input, including pointers to RTDB data, pointers to data, as well as
parameter input.  Listed below is the format of a Car-Parrinello sub-block.
\begin{verbatim}
PSPW
...
   Car-Parrinello
      CELL_NAME: <string cell_name>
      {FORMATTED_FILENAME: <string formatted_name>}+
      INPUT_WAVEFUNCTION_FILENAME:    <string input_wavefunctions    default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME:   <string output_wavefunctions   default input_movecs>
      INPUT_V_WAVEFUNCTION_FILENAME:  <string input_v_wavefunctions  default input_vmovecs>
      OUTPUT_V_WAVEFUNCTION_FILENAME: <string output_v_wavefunctions default input_vmovecs>
      FAKE_MASS: <real fake_mass default default 1000.0>
      TIME_STEP: <real time_step default 5.0>
      LOOP: <integer inner_iteration outer_iteration default 10 1>
      SCALING: <real scale_c scale_r default 1.0 1.0>
      ENERGY_CUTOFF:       <real ecut default (see input description)>
      WAVEFUNCTION_CUTOFF: <real wcut default (see input description)>
      EWALD_NCUT: <integer ncut default 1>
      EWALD_RCUT: <real rcut    default (see input description)>
      EXCHANGE_CORRELATION: (Vosko || PBE96  default Vosko)
      [Nose-Hoover: <real Period_electron Temperature_electrion Period_ion Temperature_ion 
                          default 100.0 298.15 100.0 298.15>]
      XYZ_FILENAME: <string xyz_filename default XYZ>
      EMOTION_FILENAME: <string emotion_filename default EMOTION>
      HMOTION_FILENAME: <string hmotion_filename default HMOTION>
      OMOTION_FILENAME: <string omotion_filename default OMOTION>
      EIGMOTION_FILENAME: <string eigmotion_filename default EIGMOTION>
      ION_MOTION_FILENAME: <string ion_motion_filename default MOTION>

   END
...

END
\end{verbatim}
The following list describes the input for the Car-Parrinello
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
	\item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
	\item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
	\item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
	\item $<$input\_v\_wavefunctions$>$ - name that points
              to a file containing one-electron orbital velocities.
	\item $<$output\_v\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbital velocities
	      at the end of the run. 
	\item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$).
	\item $<$time\_step$>$ - value for the Verlet integration 
               time step ($\Delta t$).
	\item $<$inner\_iteration$>$ - number of iterations between the
              printing out of energies.
	\item $<$outer\_iteration$>$ - number of outer iterations
 	\item $<$scale\_c$>$ - value for the initial velocity
			      scaling of the one-electron orbital velocities.
	\item $<$scale\_r$>$ - value for the initial velocity
			      scaling of the ion velocities.
	\item $<$ecut$>$ - value for the cutoff energy used
                           to define the density.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
	\item $<$wcut$>$ - value for the cutoff energy used
 			   to define the one-electron orbitals.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
	\item $<$ncut$>$ - value for the number of unit cells
 			  to sum over (in each direction) for the real space
			  part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
	\item $<$rcut$>$ - value for the cutoff radius used
			  in the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                          Default set to be
		          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item Nose-Hoover: - optional subblock which if specified
                         causes the simulation to perform Nose-Hoover dynamics.
                         If this subblock is not specified causes the 
                         simulation to perform constant energy dyanmics.
                         See section \ref{sec:pspw_nose} for a description of the parameters.
                         \begin{itemize}
                             \item $<$Period\_electron$>$ $\equiv$ $P_{electron}$ 
                                    - estimated period for fictacious electron thermostat.
                             \item $<$Temperature\_electron$>$ $\equiv$ $T_{electron}$ 
                                    - temperature for fictacious electron motion
                             \item $<$Period\_ion$>$ $\equiv$ $P_{ion}$ 
                                    - estimated period for ionic thermostat
                             \item $<$Temperature\_ion$>$ $\equiv$ $T_{ion}$ 
                                    - temperature for ion motion
                         \end{itemize}
	\item $<$xyz\_filename$>$ - name that points to the XYZ motion file
				generated
        \item $<$emotion\_filename$>$ - name that points to the emotion motion file
				generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$hmotion\_filename$>$ - name that points to the hmotion motion file
				generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$eigmotion\_filename$>$ - name that points to the eigmotion motion file
				generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$ion\_motion\_filename$>$ - name that points to the ion\_motion motion file
				generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
       \item MULLIKEN - optional keyword which if specified
                         causes an omotion motion file to be created.  For this option
	                 to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
        \item $<$omotion\_filename$>$ - name that points to the omotion motion file
				generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
\end{itemize}



\subsection{PSP\_FORMATTER}
The psp\_formatter task takes a non-seperable pseudopotential defined in
one-dimension real-space in a one-dimensional psp datafile and does two 
things to it.  First it puts it into the semi-local form suggested by 
Kleinman and Bylander and then it expands in in a periodic Fourier
series defined by the simulation cell RTDB.  

Input to the PSP\_FORMATTER task is contained
within the PSP\_FORMATTER sub-block.
\begin{verbatim}
PSPW
  ...
  PSP_FORMATTER
     ...
  END
  ...
END
\end{verbatim}
and to run a PSP\_FORMATTER calculation the following directive is used:
\begin{verbatim}
TASK PSPW PSP_FORMATTER
\end{verbatim}
Listed below is the format of a PSP\_FORMATTER sub-block.
\begin{verbatim}
PSPW
... 
   PSP_FORMATTER
      CELL_NAME:          <string cell_name> 
      PSP_FILENAME:       <string psp_name>
      FORMATTED_FILENAME: <string formatted_name>
      LOCP: (s||p||d||f||g default (see input description))
      LMAX: (s||p||d||f||g default (see input description))
   end
...
END
\end{verbatim}
The following list describes the input for the PSP\_FORMATTER
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points 
		to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
	\item $<$psp\_name$>$ - name that points
              to a one-dimensional pseudopotential datafile.
	\item $<$formatted\_name$>$ -  
 	      name that points to a formatted\_pseudopotential datafile.
        \item LMAX (s$||$p$||$d$||$f$||$g) - used to specify the maximum number
              of angular potentials to use. The default is set to the maximum
              angular momentum in $<$psp\_name$>$.
        \item LOCP (s$||$p$||$d$||$f$||$g) - used to specify which angular potential
	      is to used as the local potential.  The default is is set to LMAX.
\end{itemize}




\subsection{WAVEFUNCTION\_INTITIALIZER}
The wavefunction\_initializer task is used to generate an initial wavefunction
datafile.
Input to the WAVEFUNCTION\_INITIALIZER task is contained
within the WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
  ...
  WAVEFUNCTION_INITIALIZER
     ...
  END
  ...
END
\end{verbatim}
and to run a WAVEFUNCTION\_INITIALIZER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_INITIALIZER
\end{verbatim}
Listed below is the format of a WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_INITIALIZER
     CELL_NAME: <string cell_name>
     WAVEFUNCTION_FILENAME: <string wavefunction_name default input_movecs>
     (RESTRICTED||UNRESTRICTED)
     if (RESTRICTED)   [RESTRICTED_ELECTRONS: <integer restricted electrons>]
     if (UNRESTRICTED) [UP_ELECTRONS: <integer up_electrons>]
                       [DOWN_ELECTRONS: <integer down_electrons>]
     
     [UP_FILLING: <integer up_filling>
        [0 0 0 0   0]
        {<integer kx ky kz> (-2||-1||1||2)}]
     [DOWN_FILLING: <integer down_filling>
        [0 0 0 0   0]
        {<integer kx ky kz> (-2||-1||1||2)}]
   END
...
END
\end{verbatim}
The following list describes the input for the WAVEFUNCTION\_INITIALIZER
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points 
		to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
	\item $<$wavefunction\_name$>$ - name that will point
              to a wavefunction file.
	\item (RESTRICTED$||$UNRESTRICTED) - keyword specifying the whether
              the calculation is restricted or unrestricted.
	\item $<$up\_filling$>$ - number of restricted molecular orbitals if
              RESTRICTED and number of spin-up molecular orbitals if 
              UNRESTRICTED.
        \item $<$down\_filling$>$ - number of spin-down moleclar orbitals if
              UNRESTRICTED.  Not used if a RESTRICTED calculations
        \item $<$kx ky kz$>$ - specifies which planewave is to be filled. 
\end{itemize}



\subsection{V\_WAVEFUNCTION\_INITIALIZER}
The v\_wavefunction\_initializer task is used to generate an initial velocity 
wavefunction datafile.
Input to the V\_WAVEFUNCTION\_INITIALIZER task is contained
within the V\_WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
  ...
  V_WAVEFUNCTION_INITIALIZER
     ...
  END
  ...
END
\end{verbatim}
and to run a V\_WAVEFUNCTION\_INITIALIZER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_INITIALIZER
\end{verbatim}
Listed below is the format of a V\_WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
... 
   V_WAVEFUNCTION_INITIALIZER
     V_WAVEFUNCTION_FILENAME: <string v_wavefunction_name default input_vmovecs>
     CELL_NAME: <string cell_name>
     (RESTRICTED||UNRESTRICTED)
     UP_FILLING: <integer up_filling>
     DOWN_FILLING: <integer down_filling>
   END
...
END
\end{verbatim}
The following list describes the input for the V\_WAVEFUNCTION\_INITIALIZER
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - name that points 
		to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
	\item $<$wavefunction\_name$>$ - name that will point
              to a velocity wavefunction file.
	\item (RESTRICTED$||$UNRESTRICTED) - keyword specifying the whether
              the calculation is restricted or unrestricted.
	\item $<$up\_filling$>$ - number of restricted velocity molecular 
	      orbitals if RESTRICTED and number of spin-up velocity molecular 
              orbitals if UNRESTRICTED.
        \item $<$down\_filling$>$ - number of spin-down velocity moleclar 
              orbitals if UNRESTRICTED.  Not used if a RESTRICTED calculation.
\end{itemize}



\subsection{WAVEFUNCTION\_EXPANDER}
The v\_wavefunction\_initializer task is used to convert a new wavefunction
file that span a larger grid space from an old wavefunction file.
Input to the WAVEFUNCTION\_EXPANDER task is contained
within the WAVEFUNCTION\_EXPANDER sub-block.
\begin{verbatim}
PSPW
  ...
  WAVEFUNCTION_EXPANDER
     ...
  END
  ...
END
\end{verbatim}
and to run a WAVEFUNCTION\_EXPANDER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_EXPANDER
\end{verbatim}
Listed below is the format of a WAVEFUNCTION\_EXPANDER sub-block.
\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_EXPANDER   
     OLD_WAVEFUNCTION_FILENAME: <string old_wavefunction_name>
     NEW_WAVEFUNCTION_FILENAME: <string new_wavefunction_name>
     NEW_NGRID: <integer na1 na2 na3>
    
   END
...
END
\end{verbatim}
The following list describes the input for the WAVEFUNCTION\_EXPANDER
sub-block.
\begin{itemize}
	\item $<$old\_wavefunction\_name$>$ - name that points
              to a wavefunction file.
	\item $<$new\_wavefunction\_name$>$ - name that will 
              point to a wavefunction file.
	\item $<$na1 na2 na3$>$ - number of grid points in each dimension
              for the new wavefunction file. 
\end{itemize}



\subsection{PSP\_GENERATOR}

A one-dimensional pseudopotential code has been integrated into NWChem.
This code allows the user to modify and develop pseudopotentials.  Currently, 
only the Hamann and Troullier-Martins norm-conserving pseudopotentials can be
generated.  This file can then be used by the pseudopotential\_formatter 
task to generate a formatted pseudopotential file. 
Input to the PSP\_GENERATOR task is contained
within the PSP\_GENERATOR sub-block.
\begin{verbatim}
PSPW
  ...
  PSP_GENERATOR
     ...
  END
  ...
END
\end{verbatim}
and to run a PSP\_GENERATOR calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW PSP_GENERATOR
\end{verbatim}
Listed below is the format of a PSP\_GENERATOR sub-block.
\begin{verbatim}
PSPW
... 
   PSP_GENERATOR
      PSEUDOPOTENTIAL_FILENAME: <string psp_name>
      ELEMENT: <string element>
      CHARGE: <real charge>
      MASS_NUMBER: <real mass_number>
      ATOMIC_FILLING: <integer ncore nvalence>
       {n=(1||2||...) l=(s||p||d||f) <real filling[n,l]> i=1,(ncore+nvalence)}
      
      [CUTOFF: <integer lmax> \
         {l=(s||p||d||f||g) <real rcut[l]> i=1,lmax}
      ]
      PSEUDOPOTENTIAL_TYPE: (TROULLIER-MARTINS || HAMANN default HAMANN)
      SOLVER_TYPE: (PAULI || SCRHODINGER default PAULI)
      EXCHANGE_TYPE: (dirac || PBE96 default DIRAC)
      CORRELATION_TYPE: (VOSKO || PBE96 default VOSKO)
      [SEMICORE_RADIUS: <real rcore>]
      
   end
... 
END
The following list describes the input for the PSP\_GENERATOR
sub-block.
\begin{itemize}

	\item $<$psp\_name$>$ - name that points to a.
	\item $<$element$>$ - Atomic symbol.
        \item $<$charge$>$ - charge of the atom
        \item $<$mass$>$ - mass number for the atom
        \item $<$ncore$>$ - number of core states
        \item $<$nvalence$>$ - number of valence states.
        \item .....
	\item $<$rcore$>$ - value for the semicore radius. 
\end{itemize}



\end{verbatim}



\section{PSPW RTDB Entries and DataFiles}
\label{sec:pspw_data}
Input to the PSPW module is contained in both the RTDB and datafiles.
The RTDB is used to store input that the user will need to directly specify.
Input of this kind includes ion positions, ion velocities, and simulation cell
parameters.  The datafiles are used to store input, such the one-electron 
orbitals, one-electron orbital velocities, formatted pseudopotentials, 
and one-dimensional pseudopotentials, that the user will in most cases
run a program to generate.

\subsection{Ion Positions}
The positions of the ions are stored in the default geometry structure
in the RTDB and must be specified in cartesian 
coordinates using the GEOMETRY directive.

\subsection{Ion Velocities}
The velocities of the ions are stored in the default geometry structure
in the RTDB, and must be specified in cartesian 
coordinates using the GEOMETRY directive.

\subsection{Simulation Cell}
\label{sec:pspw_cell}
Simulation cells are stored in the RTDB.  To enter a  simulation cell
into the RTDB the user defines a simulation\_cell sub-block within the PSPW 
block.  Listed below is the format of a simulation\_cell sub-block.
\begin{verbatim}
PSPW
...
   SIMULATION_CELL
      CELL_NAME: <string name>
      BOUNDRY_CONDITIONS: (periodic || aperiodic)
      LATTICE_VECTORS:
        <real a1.x a1.y a1.z>
        <real a2.x a2.y a2.z>
        <real a3.x a3.y a3.z>
      NGRID: <integer na1 na2 na3>
   END
...
END
\end{verbatim}
Basically, the user needs to enter the dimensions, gridding and boundry
conditions of the simulation cell.  The following list describes the 
input in detail.
\begin{itemize}
	\item $<$name$>$ - user-supplied name for the simulation block.
	\item periodic - keyword specifying that the simulation cell 
	                 has periodic boundary conditions. 	
	\item aperiodic - keyword specifying that the simulation cell
		          has free-space boundary conditions. 
	\item $<$a1.x a1.y a1.z$>$ - user-supplied values for the first 
				   lattice vector 
	\item $<$a2.x a2.y a2.z$>$ - user-supplied values for the second 
				   lattice vector
	\item $<$a3.x a3.y a3.z$>$ - user-supplied values for the third 
				   lattice vector
	\item $<$na1 na2 na3$>$ - user-supplied values for discretization 
				along lattice vector directions.
\end{itemize}

\subsection{Analysis: Mulliken RTDB data}
\label{sec:pspw_analysis}

To perform Mulliken analysis information is needed from one-dimensional
pseudopotential files.  In-order to facilitate the transfer of this information
to the simulation the ANALYSIS sub-block is used to exract the necessary information
and put it into the RTDB.
\begin{verbatim}
PSPW
...
   ANALYSIS
      {psp_filename: <string psp_name>}+
   END
...
END
\end{verbatim}
Basically, the user needs to enter each pseudopotential used in the simulation.
\begin{itemize}
	\item $<$psp\_name$>$ - name that ponts to a one-dimensional pseudopotential file.
\end{itemize}


\subsection{Wavefunction Datafile}
The one-electron orbitals are stored in a wavefunction datafile.  This
is a binary file and cannot be directly edited.  This datafile is used
by steepest\_descent and Car-Parrinello tasks and can be generated
using the wavefunction\_initializer or wavefunction\_expander tasks.

\subsection{Velocity Wavefunction Datafile}
The one-electron orbital velocities are stored in a velocity wavefunction 
datafile.  This is a binary file and cannot be directly edited.  This datafile 
is used by the Car-Parrinello task and can be generated
using the v\_wavefunction\_initializer task.

\subsection{Formatted Pseudopotential Datafile}
The pseudopotentials in Kleinman-Bylander form expanded on a simulation
cell (3d grid) are stored in a formatted pseudopotential datafile.
This is a binary file and cannot be directly edited.
This datafile 
is used by steepest\_descent and Car-Parrinello tasks and can be generated
using the pseudpotential\_formatter task.

\subsection{One-Dimensional Pseudopotential Datafile}
The one-dimensional pseudopotentials are stored in a one-dimensional 
pseudopotential file.  This is an ascii file and can be directly edited with
a text editor.  However, the user will usually use the psp\_generator
task to generate this datafile.

The data stored in the one-dimensional pseudopotential file is
\begin{verbatim}
   character*2 element       :: element name
   integer     charge        :: valence charge of ion
   real        mass          :: mass of ion
   integer     lmax          :: maximum angular component
   real        rcut(lmax)    :: cutoff radii used to define pseudopotentials
   integer     nr            :: number of points in the radial grid
   real        dr            :: linear spacing of the radial grid
   real        r(nr)         :: one-dimensional radial grid
   real        Vpsp(nr,lmax) :: one-dimensional pseudopotentials
   real        psi(nr,lmax)  :: one-dimensional pseudowavefunctions
\end{verbatim}
and the format of it is:
\begin{verbatim}
[line 1:     ] element	
[line 2:     ] charge mass lmax
[line 3:     ] (rcut(l), l=1,lmax)
[line 4:     ] nr dr
[line 5:     ]    r(1)  (Vpsp(1,l),  l=1,lmax)
[line 6:     ] ....
[line nr+4:  ] r(nr) (Vpsp(nr,l), l=1,lmax)
[line nr+5:  ] r(1)  (psi(1,l), l=1,lmax) 
[line nr+6:  ] ....
[line 2*nr+4:] r(nr) (psi(nr,l), l=1,lmax)
\end{verbatim}



\section{PSPW Car-Parrinello Output Datafiles}
\label{sec:pspw_cp_data}



\section{Minimizing the DFT Energy Functional}
\label{sec:pspw_Minimize}

In this section the algorithms for steepest\_descent and conjugate\_gradient 
methods that are used to minimize the DFT energy functional are presented.
First is the the steepest descent method without line minimization.   
This method is slow, but doesn't require line minimization.  
Second is the recent method developed by Edelman, Arias, and Smith.
These researchers have developed methods for performing line minimizations
on the constrained space used in the DFT energy functional
(A. Edelman, T. Arias, and S.T. Smith, Siam J. Matrix Anal. Appl., 
\textbf{20},303, (1998)).


\subsection{Steepest Descent Equations}
\label{sec:pspw_sd2}

To minimize the DFT energy functional with respect to $\{\psi_{i,\sigma}\}$
we define the the auxiliary functional, $F$, which takes into account
the orthonormality constraints.

\begin{eqnarray}
F\left(\{\psi_{i,\sigma}\},\{\vec{R_I}\} \right)
&=& E\left(\{\psi_{i,\sigma}\},\{\vec{R_I}\} \right) \nonumber \\
&+&\sum_{ij,\sigma}  \left( \int d\vec{r}\ 
\psi_{i,\sigma}^{*}(\vec{r}) \psi_{j,\sigma}(\vec{r}) \Lambda_{ji,\sigma}
                 - \delta_{ij,\sigma} 
\right) 
\label{eq:sd1}
\end{eqnarray}

\noindent
The steepest descent minimization procedure without line minimization
is then
\begin{eqnarray}
\psi_{i,\sigma}^{t+ \Delta t} 
                   &\leftarrow& 
                    \psi_{i,\sigma}^{t} 
                      - \alpha 
                        \left[ 
                           \frac{\delta F}{\delta \psi_{i,\sigma}^{*}}
                        \right]_{t}
                   = \psi_{i,\sigma}^{t} 
                      - \alpha 
                        \left[ 
                           \frac{\delta E}{\delta \psi_{i,\sigma}^{*}}
                            + \sum_{j} \psi_{j,\sigma} \Lambda_{ji,\sigma} 
                        \right]_{t}
\label{eq:sd2}
\end{eqnarray}
where $\alpha =\frac{\Delta t}{\sqrt{\mu}}$ is a positive numerical parameter.
In this minimization procedure we have to know variational derivative
$\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ and the matrix 
$\Lambda_{ij,\sigma}$. 
The variational derivative $\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ 
can be analytically found and is
\begin{eqnarray}
\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
      &=&  -\frac{1}{2} \nabla^2 
            \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
           W_{ext}(\vec{r},\vec{r^{\prime}}) 
          \psi_{i,\sigma}(\vec{r^{\prime}}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
                    \frac{n(\vec{r^{\prime}})}{|\vec{r}-\vec{r^{\prime}}|}
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \mu_{xc}^{\sigma}(\vec{r}) 
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
& \equiv & \hat{H} \psi_{i,\sigma}
\label{eq:sd3}
\end{eqnarray}
  
The ion positions can also be minimized using a fixed step minimization 
procedure.
\begin{eqnarray}
\vec{R}_I^{t+\Delta t} &\leftarrow& 
                      \vec{R}_I^{t}
                    - \frac{(\Delta t)}{\sqrt{M_I}} 
                       \frac{\partial E}{\partial \vec{R}_I}
\end{eqnarray}
                      
\noindent
To find the matrix $\Lambda_{ij,\sigma}$ we impose the orthonormality
constraint on $\psi_{i,\sigma}^{t+\Delta t}$ to obtain the
matrix Riccatti equation 
(to simplify the following equations we define the following symbol
$\bar{\psi}_{i,\sigma}^{t} =  
              \left(\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} \right)_{t}$
)

\begin{eqnarray}
I &=& <\psi_{i,\sigma}^{t+\Delta t} | \psi_{j,\sigma}^{t+\Delta t}> \nonumber \\
  &=& 
   \left( <\psi_{i,\sigma}^{t}| 
          - \alpha  
            \left[
                  <\bar{\psi}_{i,\sigma}^{t}| 
                  + \sum_{k} \Lambda_{ik,\sigma}^{*} <\psi_{k,\sigma}^{t}|
            \right]
   \right) \nonumber \\
& & 
   \left( |\psi_{j,\sigma}^{t}> 
          - \alpha  
            \left[
                  |\bar{\psi}_{j,\sigma}^{t}> 
                  + \sum_{l} |\psi_{l,\sigma}^{t}> \Lambda_{lj,\sigma} 
            \right]
   \right) \nonumber \\
  &=& <\psi_{i,\sigma}^{t}| \psi_{j,\sigma}^{t}> \nonumber \\
  &-& \alpha 
       \left[ 
         \begin{array}{ll}
           <\psi_{i,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> &
         + <\bar{\psi}_{i,\sigma}^{t}| \psi_{j,\sigma}^{t}> \\
         + \sum_{k} \Lambda_{ik,\sigma}^{*} 
                     <\psi_{k,\sigma}^{t}| \psi_{j,\sigma}^{t}> &
         + \sum_{l} <\psi_{i,\sigma}^{t}| \psi_{l,\sigma}^{t}>
                    \Lambda_{lj,\sigma} 
        \end{array}
       \right] \nonumber \\
  &+& \alpha^2 
       \left[
               <\bar{\psi}_{i,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> 
            + \sum_{k} \Lambda_{ik,\sigma}^{*} 
                    <\psi_{k,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> 
            + \sum_{l} <\bar{\psi}_{i,\sigma}^{t}| \psi_{l,\sigma}^{t}>
                         \Lambda_{lj,\sigma} 
       \right]     \nonumber \\
  &+& \alpha^2 
       \left[
                \sum_{k} \sum_{l}
                 \Lambda_{ik,\sigma}^{*} 
                 <\psi_{k,\sigma}^{t}|\psi_{l,\sigma}^{t}>
                 \Lambda_{lj,\sigma} 
       \right] \nonumber \\
  &=& A + \alpha XB + \alpha B^{\dag}X^{\dag} + \alpha^2 XCX^{\dag} 
\label{eq:sd4}
\end{eqnarray}

\noindent
where $X_{ij,\sigma}=\Lambda_{ij,\sigma}^{*}$ and the matrices 
$A$, $B$, and $C$ are given by

\begin{eqnarray}
A_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
                     \right)_t
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{j,\sigma}^{*}}
                     \right)_t
             \right] \\
B_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{j,\sigma}^{*}}
                     \right)_t
             \right] \\
C_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
             \right]
\end{eqnarray}

\noindent
To solve the Riccatti equation an iterative solution is setup by rewriting
Eq.~\ref{eq:sd4} in the following form.
\begin{equation}
\alpha^2 XCX^{\dag} + \alpha X(B-I) + \alpha (B^{\dag}-I)X^{\dag} 
 + \alpha(X + X^{\dag}) = I-A
\end{equation}
Since X is by definition Hermitian, $X=X^{\dag}$, and 
\begin{eqnarray}
A  &\approx& I + O(\alpha) \nonumber \\
B  &\approx& I + O(\alpha)  \\
\end{eqnarray}
we can solve for X iteratively.
\begin{eqnarray}
\label{eq:sd15}
X_{(n)} \leftarrow && \frac{1}{2 \alpha}(I-A) + \nonumber \\
                   && \frac{1}{2} \left( X_{(n-1)}(I-B)
                    + (I-B^{\dag})X_{(n-1)}^{\dag}
                    - \alpha X_{(n-1)}CX_{(n-1)}^{\dag} \right)  \\
\label{eq:sd16}
X_{(0)} \leftarrow && \left(\frac{I-A}{2 \alpha}\right)
\end{eqnarray}
The convergence of Eq.~\ref{eq:sd15} is guaranteed for small $\alpha$
since each successive iteration has the property
\begin{eqnarray}
X_{(1)} &\leftarrow& X_{(0)} + O(\alpha)X_{(0)} \nonumber \\
X_{(2)} &\leftarrow& X_{(0)} + O(\alpha) X_{(1)} 
        = X_{(0)} + O(\alpha)X_{(0)} + O(\alpha^2)X_{(0)} \nonumber \\
X_{(3)} &\leftarrow& X_{(0)} + O(\alpha) X_{(2)} 
        = X_{(0)} + O(\alpha)   X_{(0)} 
                  + O(\alpha^2) X_{(0)} 
                  + O(\alpha^3) X_{(0)} \nonumber
\end{eqnarray}


\subsection{Conjugate Gradient with Curvature: Grassmann Manifold}
\label{sec:pspw_cgmanifold}

Minimizing the DFT energy functional with a non-linear conjugate 
gradient algorithm requires an algorithm for minimizing along a 
search direction or line.  However, the equation for a line 
(or search direction) in the DFT minimization problem is complicated 
by the fact that the energy functional is subject to orthonormality 
constraints. 
Furthermore, the orthonormality constraints complicate the
conjugate gradient's algorithm for generating the current search 
direction by using a linear combination of the current gradient and 
the previous search direction, since the previous search direction
must be parallel transported to the current search point.

These orthonormality constraint problems
have been investigated and solved for by Edelman {\it et al} 
(A. Edelman, T. Arias, and S.T. Smith, Siam J. Matrix Anal. Appl., 
\textbf{20},303, (1998))..  
They recognized that the orthonormal Kohn-Sham
orbitals $\{\psi_{i,\sigma}\}$ 
belong to a quotient space called a Grassmann manifold. 
Using the properties of the Grassmann manifold they
developed an equation for a line (or geodesic) which
conserves orthonormality, as well as 
a conjugate gradient procedure for generating the current search direction on this
constrained space.

Following Edelman {\it et al} we write
$\{ \psi_{i,\sigma}(\vec{r}) \}$ in terms of the orthonormal basis
$\{ \phi_j(\vec{r}) \}$.
\begin{equation}
\psi_{i,\sigma}(\vec{r}) = \sum_{j}^{N_{basis}} 
                           \psi_{i,\sigma}(\phi_j) 
                            \phi_j(\vec{r})
\end{equation}
Which allows us to rewrite
Eqs.~\ref{eqn:lda1}-\ref{eqn:lda2} as a function,
$E(Y_{\uparrow},Y_{\downarrow})$,
of two tall and skinny $N_{basis}$-by-$N_{\sigma}$ matrices
which are
\begin{equation}
Y_{\uparrow}=\left[\begin{array}{rrrr}
                    \psi_{1,\uparrow}(\phi_1) 
                     & \psi_{2,\uparrow}(\phi_1) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_1) \\
                    \psi_{1,\uparrow}(\phi_2) 
                     & \psi_{2,\uparrow}(\phi_2) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_2) \\
                    \psi_{1,\uparrow}(\phi_3) 
                     & \psi_{2,\uparrow}(\phi_3) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_3) \\
                    \vdots 
                     & \vdots
                     &
                     & \vdots \\
                    \psi_{1,\uparrow}(\phi_{N_{basis}}) 
                     & \psi_{2,\uparrow}(\phi_{N_{basis}}) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_{N_{basis}})
                   \end{array}
               \right]
\end{equation}
and
\begin{equation}
Y_{\downarrow}=\left[\begin{array}{rrrr}
                    \psi_{1,\downarrow}(\phi_1) 
                     & \psi_{2,\downarrow}(\phi_1) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_1) \\
                    \psi_{1,\downarrow}(\phi_2) 
                     & \psi_{2,\downarrow}(\phi_2) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_2) \\
                    \psi_{1,\downarrow}(\phi_3) 
                     & \psi_{2,\downarrow}(\phi_3) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_3) \\
                    \vdots 
                     & \vdots
                     & 
                     & \vdots \\
                    \psi_{1,\downarrow}(\phi_{N_{basis}}) 
                     & \psi_{2,\uparrow}(\phi_{N_{basis}}) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_{N_{basis}})
                   \end{array}
               \right]
\end{equation}
The orthonormality constraints make the $Y_{\sigma}$ matrices
obey $Y_{\sigma}^{\dag}Y_{\sigma}=I$. 
Furthermore since the LSDA energy can be written as
\begin{equation}
E(Y_{\uparrow},Y_{\downarrow}) = \sum_{\sigma} 
        tr \left( Y_{\sigma}^{\dag} (\mathrm{Operator}) Y_{\sigma} \right)
\end{equation}
we are only interested in subspace spanned by $Y_\sigma$.
This homogeneity property allows us to state that
$E(Y_{\uparrow},Y_{\downarrow}) = E(Y_{\uparrow}Q_a,Y_{\downarrow}Q_b)$ 
where $Q_{a/b}$ is any $N_{\sigma}$-by-$N_{\sigma}$
orthogonal matrix (i.e. $Q$ is any group element of the orthogonal
group $O(N_{\sigma})$).  The constrained surface that each $Y_{\sigma}$ spans
is known as the Grassmann manifold (i.e. $Y_{\sigma}$ is a group element
of the quotient space group 
$\frac{\left(\frac{O(N_{basis})}{O(N_{basis}-N_{\sigma})}\right)}{O(N_{\sigma})}$
\footnote{See reference on Lie Groups, e.g. reference (P.J. Olver, 
\textit{Equivalence, Invariants, and Symmetry}, 1st ed. Cambridge University Press,
New York, 1995), for a definition of a quotient space and a definition of the 
          orthogonal group $O(n)$.
         }
).

In this work Algorithm~\ref{algorithm:grassmann} (see below) is the 
conjugate gradient
algorithm that is used to minimize the DFT energy functional
$E=E\left( Y_{\uparrow},Y_{\downarrow} \right)$.  What makes this
algorithm different from a standard 
Polak-Ribi\`{e}re conjugate gradient algorithm
is that a line search on a Euclidean space 
\[ Y_{\sigma}(t) = Y_{\sigma}^{(0)} + t*H_{\sigma}^{(0)} \]
is replaced by Eq.~\ref{grass:1}, 
and the parallel transports on a Euclidean space
\[ \tau H_{\sigma}^{(0)} = H_{\sigma}^{(0)} \]
\[ \tau G_{\sigma}^{(0)} = G_{\sigma}^{(0)} \]
are replaced by Eqs.~\ref{grass:2}-\ref{grass:3}.

\begin{algorithm}{Edelman {\it et al's} Algorithm for Conjugate Gradient
                  Minimization on the Grassmann Manifold}
                   
\label{algorithm:grassmann}
   \item Given $Y_{\sigma}^{(0)}$ such that 
               $Y_{\sigma}^{(0)\dag}Y_{\sigma}^{(0)}$,\\
               Compute $G_{\sigma}^{(0)} 
                        = \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(0)}}
               -  Y_{\sigma}^{(0)}Y_{\sigma}^{(0) \dag} 
                         \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(0)}}$ \\
               Set $H_{\sigma}^{(0)} = -G_{\sigma}^{(0)}$.
   \item Find the compact singular value decompositions of 
           $H_{\sigma}^{(0)} \rightarrow 
                U_{\sigma} \Sigma_{\sigma} V_{\sigma}^{\dag}$
   \item Minimize $E\left(Y_{\uparrow}(t), Y_{\downarrow}(t) \right)$ along the 
         geodesic lines derived by Edelman {\it et al} for the 
         Grassmann Manifold\\
        \begin{equation}
          Y_{\sigma}(t) = Y_{\sigma}^{(0)} V_{\sigma} 
                             \cos \left(\Sigma_{\sigma} t \right) V^{\dag}
           + U_{\sigma} \sin \left(\Sigma_{\sigma} t \right) V_{\sigma}^{\dag}
         \label{grass:1}
        \end{equation}
   \item Set $Y_{\sigma}^{(1)} = Y_{\sigma}(t_{min})$ and\\
         compute $G_{\sigma}^{(1)} 
                        = \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(1)}}
               -  Y_{\sigma}^{(1)}Y_{\sigma}^{(1) \dag} 
                         \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(1)}}$ 
   \item Parallel transport along the geodesics the tangent vectors
         $H_{\sigma}^{(0)}$ and $G_{\sigma}^{(0)}$
        \begin{equation}
          \tau H_{\sigma}^{(0)} = 
            \left( -Y_{\sigma}^{(1)} V_{\sigma} 
                     \sin \left(\Sigma_{\sigma} t \right)
           + U_{\sigma} \cos \left(\Sigma_{\sigma} t \right) 
             \right) \Sigma_{\sigma} V_{\sigma}^{\dag}
         \label{grass:2}
        \end{equation}
        \begin{equation}
          \tau G_{\sigma}^{(0)} = G_{\sigma}^{(0)}
            \left( Y_{\sigma}^{(1)} V_{\sigma} 
                       \sin \left(\Sigma_{\sigma} t \right)
           + U_{\sigma} \left(I- \cos \left(\Sigma_{\sigma} t \right) \right) 
             \right) U_{\sigma}^{\dag} G_{\sigma}^{(0)}
         \label{grass:3}
        \end{equation}
   \item Compute the new search direction
        \[
             H_{\sigma}^{(1)} = -G_{\sigma}^{(1)}  
                                + \Gamma_{\sigma} \tau H_{\sigma}^{(0)}
        \]
        where
        \[
           \Gamma_{\sigma} = \frac{tr \left[\left(G_{\sigma}^{(1)} 
                                   - \tau G_{\sigma}^{(0)}\right)
                                     G_{\sigma}^{(1)}\right]}
                                  {tr \left[G_{\sigma}^{(0)}
                                        G_{\sigma}^{(0)}\right]}
        \]
   \item Set 
         $Y_{\sigma}^{(0)} = Y_{\sigma}^{(1)}$,
         $G_{\sigma}^{(0)} = G_{\sigma}^{(1)}$, and
         $H_{\sigma}^{(0)} = H_{\sigma}^{(1)}$
   \item Go to step 2.
\end{algorithm}
        

\section{Car-Parrinello Scheme for {\it Ab Initio} Molecular Dynamics}
\label{sec:pspw_Car-Parrinello}

Car and Parrinello developed a unified scheme for doing {\it ab initio}
molecular dynamics by combining the motion of the ion cores and a fictacious
motion for the Kohn-Sham orbitals of density-functional theory 
(R. Car and M. Parrinello, Phys. Rev. Lett. \textbf{55}, 2471, (1985)).  
At the heart of this method they introduced a fictacious kinetic energy 
functional for the Kohn-Sham orbitals.

\begin{eqnarray}
\label{appendix:b1}
KE(\{\psi_{i,\sigma}(\vec{r})\}) &=& \sum_{i,\sigma}^{occ} 
                                      \int d\vec{r}\ \mu \left| 
                                      \dot{\psi}_{i,\sigma}(\vec{r}) \right|^2 
\end{eqnarray}

\noindent
Given this kinetic energy the constrained equations of motion are found 
by taking the first variation of the auxiliary Lagrangian.
\begin{eqnarray}
\label{appendix:b2}
L &=& \sum_{i,\sigma}^{occ} \int d\vec{r}\ \mu \left| 
     \dot{\psi}_{i,\sigma}(\vec{r}) \right|^2 
     + \frac 12 \sum_I M_I \left| \dot{\vec{R}}_I \right|^2 
- E\left[ \left\{ \psi_{i,\sigma}(\vec{r})\right\},\left\{\vec{R}_I \right\} \right]  
\nonumber \\
&&+\sum_{ij,\sigma} \Lambda_{ij,\sigma} \left( \int d\vec{r}\ 
\psi_{i,\sigma}^{*}(\vec{r}) \psi_{j,\sigma}(\vec{r}) - \delta_{ij,\sigma} 
\right) 
\end{eqnarray}

\noindent
Which generates a dynamics for the wavefunctions $\psi_{i,\sigma}(\vec{r})$ and 
atoms positions $\vec{R}_I$ through the constrained equations of motion:

\begin{eqnarray}
\mu \ddot{\psi}_{i,\sigma}(\vec{r},t) &=& -\frac{\delta E}{\delta \psi_{i,\sigma }^{*}
\left( \vec{r},t \right) } + \sum\limits_j \Lambda_{ij,\sigma} 
\psi_{j,\sigma} \left( \vec{r},t \right)
\label{eq:b3}
\end{eqnarray}
\begin{eqnarray}
M_I \ddot{\vec{R}}_I &=& -\frac{\partial E}{\partial \vec{R}_I}
\label{eq:b4}
\end{eqnarray}

\noindent
where $\mu$ is the fictitious mass for the electronic degrees of freedom and 
$M_I$ are the ionic masses.  
The adjustable parameter $\mu$ is used to 
describe the relative rate at which the wavefunctions change with time.  
$\Lambda_{ij,\sigma}$ are the 
Lagrangian multipliers for the orthonormalization of the single-particle 
orbitals $\psi_{i,\sigma}(\vec{r})$. 
They are defined by the orthonormalization constraint conditions
and can be rigorously found. 
However, the equations of motion for the Lagrange multipliers
depend on the specific algorithm used to integrate
Eqs.~\ref{eq:b3}-\ref{eq:b4}.

For this method to give ionic motions that are physically meaningful
the kinetic energy of the Kohn-Sham orbitals must be relatively
small when compared to the kinetic energy of the ions.
There are two ways where this criterion can fail.
First, the numerical integrations for the Car-Parrinello equations of motion 
can often lead to large relative values of the kinetic energy of 
the Kohn-Sham orbitals relative to the kinetic energy of the ions.
This kind of failure is easily fixed by requiring a more accurate
numerical integration, i.e. use a smaller time step for the numerical
integration.
Second, during the motion of the system a the ions can be in locations where
there is an Kohn-Sham orbital level crossing, i.e. the density-functional
energy can have two states that are nearly degenerate.  This kind
of failure often occurs in the study of chemical reactions.
This kind of failure is not easily fixed and requires the use
of a more sophisticated density-functional energy that accounts
for low-lying excited electronic states.


\subsection{Verlet Algorithm for Integrating Eqs.~\ref{eq:b3}-\ref{eq:b4}}

Eqs.~\ref{eq:b3}-\ref{eq:b4} integrated using the Verlet algorithm
results in

\begin{eqnarray}
\psi_{i,\sigma}^{t+ \Delta t} 
                   &\leftarrow& 
                    2 \psi_{i,\sigma}^{t} - \psi_{i,\sigma}^{t-\Delta t}
                      + \frac{(\Delta t)^2}{\mu}
                        \left[ 
                           \frac{\delta E}{\delta \psi_{i,\sigma}^{*}}
                            + \sum_{j} \psi_{j,\sigma} \Lambda_{ji,\sigma} 
                        \right]_{t}
\label{eq:b6}
\end{eqnarray}
\begin{eqnarray}
\vec{R}_I^{t+\Delta t} &\leftarrow& 
                    2 \vec{R}_I^{t} - \vec{R}_I^{t-\Delta t}
                    + \frac{(\Delta t)^2}{M_I} 
                       \frac{\partial E}{\partial \vec{R}_I}
\label{eq:b7}
\end{eqnarray}
               
In this molecular dynamic procedure we have to know variational derivative
$\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ and the matrix 
$\Lambda_{ij,\sigma}$. 
The variational derivative $\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ 
can be analytically found and is
\begin{eqnarray}
\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
      &=&  -\frac{1}{2} \nabla^2 
            \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
           W_{ext}(\vec{r},\vec{r^{\prime}}) 
          \psi_{i,\sigma}(\vec{r^{\prime}}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
                    \frac{n(\vec{r^{\prime}})}{|\vec{r}-\vec{r^{\prime}}|}
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \mu_{xc}^{\sigma}(\vec{r}) 
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
& \equiv & \hat{H} \psi_{i,\sigma}
\label{eq:b8}
\end{eqnarray}
                        
\noindent
To find the matrix $\Lambda_{ij,\sigma}$ we impose the orthonormality
constraint on $\psi_{i,\sigma}^{t+\Delta t}$ to obtain the
matrix Riccatti equation 
(To simplify the following equations we define the following symbols
$\bar{\psi}_{i,\sigma}^{t} = 2 \psi_{i,\sigma}^{t} -\psi_{i,\sigma}^{t-\Delta t}
              + \frac{(\Delta t)^2}{\mu}
                 \left[ \frac{\delta E}{\delta \psi_{i,\sigma}^{*}} \right]_{t}$
and $\alpha = \frac{(\Delta t)^2}{\mu}$.
)

\begin{eqnarray}
I &=& <\psi_{i,\sigma}^{t+\Delta t} | \psi_{j,\sigma}^{t+\Delta t}> \nonumber \\
  &=& 
   \left( <\bar{\psi}_{i,\sigma}^{t}| 
          + \alpha  
            \left[
                   \sum_{k} \Lambda_{ik,\sigma}^{*} <\psi_{k,\sigma}^{t}|
            \right]
   \right)
   \left( |\bar{\psi}_{j,\sigma}^{t}> 
          + \alpha  
            \left[
                   \sum_{l} |\psi_{l,\sigma}^{t}> \Lambda_{lj,\sigma} 
            \right]
   \right) \nonumber \\
  &=& <\bar{\psi}_{i,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> \nonumber \\
  &+& \alpha 
       \left[
          \sum_{k} \Lambda_{ik,\sigma}^{*} 
                     <\psi_{k,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> 
         + \sum_{l} <\bar{\psi}_{i,\sigma}^{t}| \psi_{l,\sigma}^{t}>
                    \Lambda_{lj,\sigma} 
       \right] \nonumber \\
  &+& \alpha^2 
       \left[
                \sum_{k} \sum_{l}
                 \Lambda_{ik,\sigma}^{*} 
                 <\psi_{k,\sigma}^{t}|\psi_{l,\sigma}^{t}>
                 \Lambda_{lj,\sigma} 
       \right] \nonumber \\
  &=& A + \alpha XB + \alpha B^{\dag}X^{\dag} + \alpha^2 XCX^{\dag} 
\label{eq:b9}
\end{eqnarray}

\noindent
where $X_{ij,\sigma}=\Lambda_{ij,\sigma}^{*}$ and the matrices 
$A$, $B$, and $C$ are given by

\begin{eqnarray}
A_{ij,\sigma} &=& \int d\vec{r} 
             \left[\bar{\psi}_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\bar{\psi}_{j,\sigma}^{t}(\vec{r}) 
             \right] \\
B_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\bar{\psi}_{j,\sigma}^{t}(\vec{r}) 
             \right] \\
C_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
             \right]
\end{eqnarray}

\noindent
To solve the Riccatti equation an iterative solution is setup by rewriting
Eq.~\ref{eq:b9} in the following form.
\begin{equation}
\alpha^2 XCX^{\dag} + \alpha X(B-I) + \alpha (B^{\dag}-I)X^{\dag} 
 + \alpha(X + X^{\dag}) = I-A
\end{equation}
Since X is by definition Hermitian, $X=X^{\dag}$, and 
\begin{eqnarray}
A  &\approx& I + O(\alpha) \nonumber \\
B  &\approx& I + O(\alpha)  \\
\end{eqnarray}
we can solve for X iteratively.
\begin{eqnarray}
\label{eq:b11}
X_{(n)} \leftarrow && \frac{1}{2 \alpha}(I-A) + \nonumber \\
                   && \frac{1}{2} \left( X_{(n-1)}(I-B)
                    + (I-B^{\dag})X_{(n-1)}^{\dag}
                    - \alpha X_{(n-1)}CX_{(n-1)}^{\dag} \right)  \\
\label{eq:b12}
X_{(0)} \leftarrow && \left(\frac{I-A}{2 \alpha}\right)
\end{eqnarray}
The convergence of Eq.~\ref{eq:b12} is guaranteed for small $\alpha$
since each successive iteration has the property
\begin{eqnarray}
X_{(1)} &\leftarrow& X_{(0)} + O(\alpha)X_{(0)} \nonumber \\
X_{(2)} &\leftarrow& X_{(0)} + O(\alpha) X_{(1)} 
        = X_{(0)} + O(\alpha)X_{(0)} + O(\alpha^2)X_{(0)} \nonumber \\
X_{(3)} &\leftarrow& X_{(0)} + O(\alpha) X_{(2)} 
        = X_{(0)} + O(\alpha)   X_{(0)} 
                  + O(\alpha^2) X_{(0)} 
                  + O(\alpha^3) X_{(0)} \nonumber
\end{eqnarray}

\subsection{Constant Temperature Simulations: Nose-Hoover Thermostats}
\label{sec:pspw_nose}

Nose-Hoover Thermostats for the electrons and ions can also be added to the 
Car-Parrinello simulation.  In this type of simulation thermostats variables $x_e$ and $x_R$ 
are added to the simulation by adding the auxillary energy functionals to the total energy.
\begin{eqnarray}
ION\_THERMOSTAT(x_R)      &=&  \frac{1}{2} Q_R \dot{x_R} + E_{R0}x_R \\ 
ELECTRON\_THERMOSTAT(x_e) &=&  \frac{1}{2} Q_e \dot{x_e} + E_{e0}x_e 
\end{eqnarray}

In these equations, the average kinetic energy for the ions is
\begin{eqnarray}
E_{R0} = \frac{1}{2} f k_B T
\end{eqnarray}
where $f$ is the number of atomic degrees of freedom, $k_B$ is 
Boltzmans constant, and T is the desired temperature.  Defining
the average fictacious kinetic energy of the electrons is not as straighforward.
Bl\"{o}chl and Parrinello 
(P.E. Bl\"{o}chl and M. Parrinello, Phys. Rev. B, \textbf{45}, 9413, (1992)) 
have suggested the following formula for determining
the average fictacious kinetic energy
\begin{eqnarray}
E_{e0} = 4 k_B T \frac{\mu}{M} \sum_i <\psi_i|-\frac{1}{2} \nabla^2 |\psi_i>
\end{eqnarray}
where $\mu$ is the fictacious electronic mass, $M$ is average mass of one atom,
and $sum_i <\psi_i|-\frac{1}{2} \nabla^2 |\psi_i>$ is the kinetic energy of the
electrons.

Bl\"{o}chl and Parrinello suggested that the choice of mass parameters, 
$Q_e$, and $Q_R$ should be made such that the period of oscillating thermostats 
should be chosen larger than the typical time scale for the dynamical events of 
interest but shorter than the simulation time.  
\begin{eqnarray}
P_R &=& 2\pi \sqrt{\frac{Q_R}{4E_{R0}}}\\
P_e &=& 2\pi \sqrt{\frac{Q_e}{4E_{e0}}}
\end{eqnarray}
where $P_R$ and $P_e$ are the periods of oscillation for the ionic and ficatious
electronic thermostats.  




\section{PSPW Tutorial 1: Minimizing the one-electron orbitals by Running a Steepest Descent and Conjuagate Gradient Simulation in Tandem}
\label{sec:pspw_sd}

In this section we show how to setup and run a steepest descent
simulation followed by a conjugate gradient simulation to optimize 
the one-electron orbitals with respect to 
the total energy for a NaCl molecule.  It is practical to
start most simulation in such a tandem fashion because the
conjugate gradient optimizer does not work well when the
one-electron orbitals are far from minimized. 

Before running a steepest\_descent or conjugate\_gradient simulation several files and
RTDB structures must be defined or initialized.  Specifically, the user 
is required to have defined:
\begin{enumerate}
  \item {\bf ion positions} 
  \item {\bf simulation cell} in the RTDB 
  \item {\bf formatted pseudopotential file} for each kind of ion 
  \item {\bf file containing the one-electron orbitals} 
  \item {\bf steepest\_descent PSPW sub-block} 
  \item {\bf conjugate\_gradient PSPW sub-block}
\end{enumerate}

In the following tutorial we show the input needed to find an
energy for an NaCl molecule.  In this example default Hamann pseudopotentials
are used for Na and Cl, the exchange correlation functional is LSDA, and
the cutoff energy is 12 au.  This example input deck can be found in the nwchem
source tree in the file: nwchem/examples/pspw/NaCl.nw
\begin{enumerate}
\item Define the ion positions using the geometry directive.
 \tiny     \begin{verbatim}
         ...
         geometry units au 
         Na    2.23 0.0 0.0
         Cl   -2.23 0.0 0.0
         end
         ...
      \end{verbatim}
\normalsize
\item Generate a pseudopotential for Sodium atoms and store it in a
      one-dimensional pseudopotential datafile called Na.psp.  
      The following input can be used to generate a default
      Hamann pseudopotential.  
 \tiny     \begin{verbatim}
         ...
         PSPW
            PSP_GENERATOR
               pseudopotential_filename: Na.psp
                element: Na
                charge: 11.0
                mass_number: 23.0
                solver_type: pauli
                pseudopotential_type: hamann
                atomic_filling: 3 1
                  1 s 2.0
                  2 s 2.0
                  2 p 6.0
                  3 s 1.0
            END
         END
         task PSPW PSP_GENERATOR
         ...
      \end{verbatim}
\normalsize
\item Use the same proceedure as above generate a pseudopotential 
      for Chlorine. 
 \tiny     \begin{verbatim}
         ...
         PSPW 
            PSP_GENERATOR
               pseudopotential_filename: Cl.psp
               element: Cl
               charge: 17.0
               mass_number: 35.0
               solver_type: pauli
               pseudopotential_type: hamann
               atomic_filling: 3 2
                  1 s 2.0
                  2 s 2.0
                  2 p 6.0
                  3 s 2.0
                  3 p 5.0
            
            END
         END
         task PSPW PSP_GENERATOR
         ...
      \end{verbatim}
\normalsize

\item Define the simulation cell.  
      The following input defines a simulation cell called ``small.'' This
      cell is periodic and cubic with a side length of 20.0 au and has
      32 grid points in each direction.  
\tiny   \begin{verbatim}
         ...
         PSPW
            SIMULATION_CELL
               cell_name: small
               boundry_conditions: periodic
               lattice_vectors:
                  20.0  0.0  0.0 
                   0.0 20.0  0.0 
                   0.0  0.0 20.0 
               ngrid: 32 32 32
            END
         END
         ...
   \end{verbatim}
\normalsize
\item Format the Na pseudopotential onto the ``small'' simulation cell.
\tiny   \begin{verbatim}
         ...
         PSPW
            PSP_FORMATTER
               cell_name: small
               psp_name: Na.psp
               formatted_name: Na.vpp
            END
         END
         task PSPW PSP_FORMATTER
         ...
   \end{verbatim}
\normalsize
\item Format the Cl pseudopotential onto the ``small'' simulation cell.
\tiny   \begin{verbatim}
         ...
         PSPW
            PSP_FORMATTER
               cell_name: small
               psp_name: Cl.psp
               formatted_name: Cl.vpp
            END
         END
         task PSPW PSP_FORMATTER
         ...
   \end{verbatim}
\normalsize
\item Generate an initial guess for the one-electron orbitals.
\tiny   \begin{verbatim}
         ...
         PSPW
            WAVEFUNCTION_INITIALIZER
               cell_name: small
               unrestricted
               up_filling: 4
                  0 0 0   0 
                  1 0 0  -1
                  0 1 0  -1
                  0 0 1  -1
               down_filling: 4
                  0 0 0   0
                  1 0 0  -1
                  0 1 0   1
                  0 0 1  -1
               wavefunction_filename: NaCl.small.00.elc
            END
         END
         task PSPW WAVEFUNCTION_INTITALIZER
         ...
   \end{verbatim}
\normalsize
\item Do a coarse optimization of the one-electron orbitals with respect to energy using
      steepest descent.
\tiny \begin{verbatim}
         ...
         PSPW
            STEEPEST_DESCENT
               cell_name: small
               formatted_filename: Na.vpp
               formatted_filename: Cl.vpp
               input_wavefunction_filename:  NaCl.small.00.elc
               output_wavefunction_filename: NaCl.small.00.elc
               fake_mass: 400000.0d0
               time_step: 51.8d0
               loop: 10 100
               tolerances: 1.0d-4 1.0d-4 1.0d-4
               energy_cutoff:       21.0d0
               wavefunction_cutoff: 21.0d0
            END 
         END
         task PSPW STEEPEST_DESCENT
         ...
      \end{verbatim}
\normalsize
\item Do a finer optimization of the one-electron orbitals with respect to energy using
      conjugate gradient, and perform a Mulliken analysis. Note that an analysis
      block must be defined. 
   \tiny \begin{verbatim}
         ...
         PSPW
           
            CONJUGATE_GRADIENT
               cell_name: small
               formatted_filename: Na.vpp
               formatted_filename: Cl.vpp
               input_wavefunction_filename:  NaCl.small.00.elc
               output_wavefunction_filename: NaCl.small.00.elc
               loop: 25 10
               tolerances: 1.0d-9 1.0d-9 
               energy_cutoff:       21.0d0
               wavefunction_cutoff: 21.0d0
               Mulliken
            END 
            ANALYSIS
                psp_name: Na.psp
                psp_name: Cl.psp
            END
         END
         task PSPW CONJUGATE_GRADIENT
         ...
      \end{verbatim}


\end{enumerate}
\normalsize


\normalsize
\section{PSPW Tutorial 2: Running a Car-Parrinello Simulation}
\label{sec:pspw_cp}

In this section we show how to perform a Car-Parrinello
molecular dynamic simulation for an NaCl molecule.  As with the example in 
the previous tutorial,  this example uses default Hamann 
pseudopotentials for Na and Cl, LSDA exchange 
correlation functional, and a cutoff energy of 12 au.

Before running a PSPW Car-Parrinello  simulation the system should be
on the Born-Oppenheimer surface, i.e. the one-electron
orbitals should be minimized with respect to the total energy using steepest
descent and conjugate gradient simulations(see section~\ref{sec:pspw_sd}).  

Continuning where we left off in section ~\ref{sec:pspw_sd} we now 
continue the simulation to run a MD simulation of an NaCl molecule.  
This example input deck can be found in the nwchem source tree in 
the file: nwchem/examples/pspw/NaCl-md.nw

\begin{enumerate}
\item Optimize wavefunctions - See previous section

\normalsize
\item Generate an initial guess for the one-electron orbitals velocities.
\tiny   \begin{verbatim}
         ...
         PSPW
            V_WAVEFUNCTION_INITIALIZER
               cell_name: small
               unrestricted
               up_filling: 4
               down_filling: 4
               v_wavefunction_filename: NaCl.small.00.velc
            END
         END
         task PSPW WAVEFUNCTION_INTITALIZER
         ...
   \end{verbatim}
\normalsize
\item Run an MD simulation using Car-Parrinello.
\tiny \begin{verbatim}
         PSPW
            Car-Parrinello
               cell_name: small
               formatted_filename: Na.vpp
               formatted_filename: Cl.vpp
               input_wavefunction_filename:    NaCl.small.00.elc
               output_wavefunction_filename:   NaCl.small.01.elc
               v_input_wavefunction_filename:  NaCl.00.velc
               v_output_wavefunction_filename: NaCl.01.velc
               fake_mass: 800.0d0
               time_step: 5.0d0
               loop: 10 100
               scaling: 1.0d0 1.0d0
               energy_cutoff:       21.0d0
               wavefunction_cutoff: 21.0d0
            END 
         END
         task PSPW Car-Parrinello
         ...
      \end{verbatim}


\end{enumerate}
\normalsize



\section{PSPW Capabilities and Limitations}
\label{sec:pspw_limits}

\begin{itemize}
\item You cannot use more processors than the size of the third dimension (e.g. a 64x64x64 FFT grid
      can use at most 64 processors).
\item The second and third dimsntions of the FFT grid must be the same (i.e. the parameters na2 and 
      na3 must be the same for each simulation cell).
\end{itemize}


\section{Questions and Difficulties}

Questions and encountered problems should be reported to 
Eric J. Bylaska, eric.bylaska@pnl.gov




