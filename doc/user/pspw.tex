\label{sec:pspw}

\newcounter{algcounter}[chapter]
\def\thealgcounter{\thechapter.\arabic{algcounter}}
\newenvironment{algorithm}[1]
               { \refstepcounter{algcounter}
                \begin{center}
                  {\bf Algorithm} \thealgcounter: #1
                \end{center}
               \begin{center}\begin{enumerate} \begin{em}}
               {\end{em}\end{enumerate}\end{center}}


The NWChem plane-wave (NWPW) module uses pseudopotentials and
plane-wave basis sets to perform Density Functional Theory
calculations.  This module complements the capabilities of the more
traditional Gaussian function based approaches (i.e. DFT module and
GAPPS Module) by having an accuracy at least as good as the
traditional Gaussian function based approaches for many applications,
yet is still fast enough to treat systems containing hundreds of
atoms.  Another significant advantage is its ability to simulate
dynamics on a ground state potential surface directly at run-time
using the Car-Parrinello algorithm.  This method's efficiency and
accuracy make it a desirable first principles method of simulation in
the study of complex molecular, liquid, and solid state systems.
Applications for this first principles method include the calculation
of free energies, search for global minima, explicit simulation of
solvated molecules, and simulations of complex vibrational modes that
cannot be described within the harmonic  approximation.

The NWPW module is a collection of two modules.
\begin{itemize}
   \item PSPW - (PSeudopotential Plane-Wave) A gamma point code for
     calculating molecules, liquids, crystals, and  surfaces.  
   \item Band - A prototype band structure code for calculating
     crystals and surfaces with small band gaps (e.g. semi-conductors
     and metals).
\end{itemize}
Both of these modules can be used to compute the energy, optimize the
geometry, find saddle points, compute numerical second derivatives.
The PSPW module can also be used to perform Car-Parrinello molecular  dynamics.

Section \ref{sec:pspw_tasks} describes the tasks contained within the
PSPW module, section \ref{sec:band_tasks} describes the tasks
contained within the Band module, and section \ref{sec:psp_library}
describes the pseudopotential library included with NWChem.  The
datafiles used by the PSPW module are described in section
\ref{sec:pspw_data}.  Car-Parrinello output data files are described
in section \ref{sec:pspw_cp_data}, and the minimization and
Car-Parrinello algorithms are described in sections
\ref{sec:pspw_Minimize}-\ref{sec:pspw_Car-Parrinello}. Examples of how
to setup and run a PSPW geometry optimization, a Car-Parrinello
simulation, and a band structure minimization are presented in
sections \ref{sec:pspw_sd}, \ref{sec:pspw_cp}, and
\ref{sec:band_tutorial1}.  Finally in section \ref{sec:pspw_limits}
the capabilities and limitations of the NWPW module are  discussed.

If you are a first time user of this module it is recommended that you skip the next five sections and proceed directly to the tutorials in sections 
\ref{sec:pspw_sd}-\ref{sec:pspw_cp}.

\section{PSPW Tasks}
\label{sec:pspw_tasks}

All input to the PSPW Tasks is contained within the compound PSPW block,
\begin{verbatim}
PSPW
   ...
END
\end{verbatim}

To perform an actual calculation a TASK PSPW directive is used
(Section \ref{sec:task}).  
\begin{verbatim}
  TASK PSPW
\end{verbatim} 
In addition to the directives listed in Section \ref{sec:task}, i.e.
\begin{verbatim}
TASK pspw energy          
TASK pspw gradient         
TASK pspw optimize         
TASK pspw saddle           
TASK pspw freqencies       
TASK pspw vib
\end{verbatim}
There are additional directives that are specific to the PSPW module, which are:
\begin{verbatim}
TASK PSPW [Car-Parrinello             ||
           pspw_dplot                 ||
           psp_generator              ||
           steepest_descent           ||
           conjugate_gradient         ||
           psp_formatter              ||
           wavefunction_initializer   ||
           v_wavefunction_initializer ||
           wavefunction_expander       ]
\end{verbatim}
The following subsections describe the input to these tasks.

Once a user has specified a geometry, the PSPW module can be invoked
with no input  directives (defaults invoked throughout).  However, the
user will probably always specify the  simulation cell used in the
computation, since the default simulation cell is not well suited for
most systems.  There are sub-directives which allow for customized
application; those currently provided as options for the PSPW module are:
\begin{verbatim}
PSPW
  CELL_NAME <string cell_name default 'cell_default'>
  INPUT_WAVEFUNCTION_FILENAME  <string input_wavefunctions  default input_movecs>
  OUTPUT_WAVEFUNCTION_FILENAME <string output_wavefunctions default input_movecs>
  FAKE_MASS <real fake_mass default 400000.0>
  TIME_STEP <real time_step default 5.8>
  LOOP <integer inner_iteration outer_iteration default 10 100>
  TOLERANCES <real tole tolc default 1.0e-7 1.0e-7>
  ENERGY_CUTOFF       <real ecut default (see input description)>
  WAVEFUNCTION_CUTOFF <real wcut default (see input description)>
  EWALD_NCUT <integer ncut default 1>]
  EWALD_RCUT <real rcut default (see input description)>
  XC (Vosko || PBE96  default Vosko)
  DFT||ODFT||RESTRICTED||UNRESTRICTED
  MULT <integer mult default 1>
  MULLIKEN
  ALLOW_TRANSLATION

  SIMULATION_CELL            ... (see input description) END
  DPLOT                      ... (see input description) END
  CAR-PARRINELLO             ... (see input description) END
  PSP_GENERATOR              ... (see input description) END
  PSP_FORMATTER              ... (see input description) END
  WAVEFUNCTION_INITIALIZER   ... (see input description) END
  V_WAVEFUNCTION_INITIATIZER ... (see input description) END
  WAVEFUNCTION_EXPANDER      ... (see input description) END
  STEEPEST_DESCENT           ... (see input description) END
  CONJUGATE_GRADIENT         ... (see input description) END
END 
\end{verbatim}

The following list describes the keywords contained in the PSPW input block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
        \item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
        \item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
        \item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$). This parameter is not presently used in a 
              conjugate gradient simulation
        \item $<$time\_step$>$ - value for the time step ($\Delta t$).  This
              parameter is not presently used in a conjugate gradient simulation.
        \item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
        \item $<$outer\_iteration$>$ - number of outer iterations
        \item $<$tole$>$ - value for the energy tolerance.
        \item $<$tolc$>$ - value for the one-electron orbital tolerance.
        \item $<$ecut$>$ - value for the cutoff energy used
                           to define the density. Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$wcut$>$ - value for the cutoff energy used
                           to define the one-electron orbitals.
                           Default is set to be the maximum value that 
                           will fix within the simulation\_cell $<$cell\_name$>$.
        \item $<$ncut$>$ - value for the number of unit cells
                          to sum over (in each direction) for the real space
                          part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
        \item $<$rcut$>$ - value for the cutoff radius used
                          in the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                           Default set to be
                          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Ernzerhof GGA functional.
        \item MULLIKEN - optional keyword which if specified
                         causes a Mulliken anaysis to be performed at
                         the end of the simulation.  The angular momentum
                         weights for each kind of atom can be modified using 
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}).

        \item SIMULATION\_CELL (see section \ref{sec:pspw_cell})
        \item DPLOT (see section \ref{sec:pspw_dplot})
        \item CAR-PARRINELLO(see section \ref{sec:pspw_CP})
        \item PSP\_GENERATOR (see section \ref{sec:pspw_psp_generator})
        \item PSP\_FORMATTER (see section \ref{sec:pspw_psp_formatter})
        \item WAVEFUNCTION\_INITIALIZER (see section \ref{sec:pspw_wavefunction_initializer})
        \item V\_WAVEFUNCTION\_INITIALIZER (see section \ref{sec:pspw_v_wavefunction_initializer})
        \item WAVEFUNCTION\_EXPANDER (see section \ref{sec:pspw_wavefunction_expander}).
        \item STEEPEST\_DESCENT (see section \ref{sec:pspw_steepest_descent})
        \item CONJUGATE\_GRADIENT (see section \ref{sec:pspw_conjugate_gradient})
\end{itemize}

\subsection{Simulation Cell}
\label{sec:pspw_cell}
Simulation cells are stored in the RTDB.  To enter a  simulation cell
into the RTDB the user defines a simulation\_cell sub-block within the PSPW 
block.  Listed below is the format of a simulation\_cell sub-block.
\begin{verbatim}
PSPW
...
   SIMULATION_CELL
      CELL_NAME <string name default 'cell_default'>
      BOUNDARY_CONDITIONS (periodic || aperiodic default periodic)
      LATTICE_VECTORS
        <real a1.x a1.y a1.z default 20.0  0.0  0.0>
        <real a2.x a2.y a2.z default  0.0 20.0  0.0>
        <real a3.x a3.y a3.z default  0.0  0.0 20.0>
      NGRID <integer na1 na2 na3 default 32 32 32>
   END
...
END
\end{verbatim}
Basically, the user needs to enter the dimensions, gridding and boundry
conditions of the simulation cell.  The following list describes the 
input in detail.
\begin{itemize}
        \item $<$name$>$ - user-supplied name for the simulation block.
        \item periodic - keyword specifying that the simulation cell 
                         has periodic boundary conditions.      
        \item aperiodic - keyword specifying that the simulation cell
                          has free-space boundary conditions. 
        \item $<$a1.x a1.y a1.z$>$ - user-supplied values for the first 
                                   lattice vector 
        \item $<$a2.x a2.y a2.z$>$ - user-supplied values for the second 
                                   lattice vector
        \item $<$a3.x a3.y a3.z$>$ - user-supplied values for the third 
                                   lattice vector
        \item $<$na1 na2 na3$>$ - user-supplied values for discretization 
                                along lattice vector directions.
\end{itemize}

\subsection{\tt DPLOT}
\label{sec:pspw_dplot}
The pspw dplot task is used to generate plots of various types of electron
densities (or orbitals) of a molecule.  The electron density is calculated on the 
specified set of grid points from a PSPW calculation.  The output file
generated is in the Gaussian Cube format.
Input to the DPLOT task is contained
within the DPLOT sub-block.
\begin{verbatim}
PSPW
  ...
  DPLOT
     ...
  END
  ...
END
\end{verbatim}
To run a DPLOT calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW PSPW_DPLOT
\end{verbatim}
Listed below is the format of a DPLOT sub-block.
\begin{verbatim}
PSPW
... 
   DPLOT
     VECTORS <string input_wavefunctions  default input_movecs>  
     DENSITY [total||difference||alpha||beta||laplacian||potential default total] <string density_name no default>
     ORBITAL <integer orbital_number no default> <string orbital_name no default>
   END
...
END
\end{verbatim}
The following list describes the input for the DPLOT
sub-block.
\begin{itemize}
        \item $<$input\_wavefunctions$>$ - name that points
              to a wavefunction file.
        \item $<$density\_name$>$ - name that will 
              point to a generated Gaussian Cube file of the specified density.
        \item $<$orbital\_name$>$ - name that will 
              point to a generated Gaussian Cube file of the specified orbital.
\end{itemize}


\subsection{\tt Car-Parrinello}
\label{sec:pspw_CP}
The Car-Parrinello task is used to perform ab initio molecular dynamics
using the scheme developed by Car and Parrinello.  In this unified ab
initio molecular dynamics scheme the motion of the ion cores is coupled to
a fictitious motion for the Kohn-Sham orbitals of density functional
theory.  Constant energy or constant temperature simulations can be
performed.  A detailed description of this method
is described in section \ref{sec:pspw_Car-Parrinello}.

Input to the Car-Parrinello simulation is contained within the
Car-Parrinello sub-block.
\begin{verbatim}
PSPW
  ...
  Car-Parrinello
     ...
  END
  ...
END
\end{verbatim}
To run a Car-Parrinello calculation the following directive is used:
\begin{verbatim}
TASK PSPW Car-Parrinello 
\end{verbatim}
The Car-Parrinello sub-block contains a great deal
of input, including pointers to data, as well as
parameter input.  Listed below is the format of a Car-Parrinello sub-block.
\begin{verbatim}
PSPW
...
   Car-Parrinello
      CELL_NAME <string cell_name>
      INPUT_WAVEFUNCTION_FILENAME    <string input_wavefunctions    default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME   <string output_wavefunctions   default input_movecs>
      INPUT_V_WAVEFUNCTION_FILENAME  <string input_v_wavefunctions  default input_vmovecs>
      OUTPUT_V_WAVEFUNCTION_FILENAME <string output_v_wavefunctions default input_vmovecs>
      FAKE_MASS <real fake_mass default default 1000.0>
      TIME_STEP <real time_step default 5.0>
      LOOP <integer inner_iteration outer_iteration default 10 1>
      SCALING <real scale_c scale_r default 1.0 1.0>
      ENERGY_CUTOFF       <real ecut default (see input description)>
      WAVEFUNCTION_CUTOFF <real wcut default (see input description)>
      EWALD_NCUT <integer ncut default 1>
      EWALD_RCUT: <real rcut    default (see input description)>
      XC (Vosko || PBE96  default Vosko)
      [Nose-Hoover <real Period_electron Temperature_electrion Period_ion Temperature_ion 
                          default 100.0 298.15 100.0 298.15>]
      XYZ_FILENAME <string xyz_filename default XYZ>
      EMOTION_FILENAME <string emotion_filename default EMOTION>
      HMOTION_FILENAME <string hmotion_filename default HMOTION>
      OMOTION_FILENAME <string omotion_filename default OMOTION>
      EIGMOTION_FILENAME <string eigmotion_filename default EIGMOTION>
      ION_MOTION_FILENAME <string ion_motion_filename default MOTION>

   END
...

END
\end{verbatim}
The following list describes the input for the Car-Parrinello
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
        \item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
        \item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
        \item $<$input\_v\_wavefunctions$>$ - name that points
              to a file containing one-electron orbital velocities.
        \item $<$output\_v\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbital velocities
              at the end of the run. 
        \item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$).
        \item $<$time\_step$>$ - value for the Verlet integration 
               time step ($\Delta t$).
        \item $<$inner\_iteration$>$ - number of iterations between the
              printing out of energies.
        \item $<$outer\_iteration$>$ - number of outer iterations
        \item $<$scale\_c$>$ - value for the initial velocity
                              scaling of the one-electron orbital velocities.
        \item $<$scale\_r$>$ - value for the initial velocity
                              scaling of the ion velocities.
        \item $<$ecut$>$ - value for the cutoff energy used
                           to define the density.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$wcut$>$ - value for the cutoff energy used
                           to define the one-electron orbitals.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$ncut$>$ - value for the number of unit cells
                          to sum over (in each direction) for the real space
                          part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
        \item $<$rcut$>$ - value for the cutoff radius used
                          in the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                          Default set to be
                          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item Nose-Hoover - optional subblock which if specified
                         causes the simulation to perform Nose-Hoover dynamics.
                         If this subblock is not specified the 
                         simulation performs constant energy dyanmics.
                         See section \ref{sec:pspw_nose} for a description of the parameters.
                         \begin{itemize}
                             \item $<$Period\_electron$>$ $\equiv$ $P_{electron}$ 
                                    - estimated period for fictitious electron thermostat.
                             \item $<$Temperature\_electron$>$ $\equiv$ $T_{electron}$ 
                                    - temperature for fictitious electron motion
                             \item $<$Period\_ion$>$ $\equiv$ $P_{ion}$ 
                                    - estimated period for ionic thermostat
                             \item $<$Temperature\_ion$>$ $\equiv$ $T_{ion}$ 
                                    - temperature for ion motion
                         \end{itemize}
        \item $<$xyz\_filename$>$ - name that points to the XYZ motion file
                                generated
        \item $<$emotion\_filename$>$ - name that points to the emotion motion file
                                generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$hmotion\_filename$>$ - name that points to the hmotion motion file
                                generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$eigmotion\_filename$>$ - name that points to the eigmotion motion file
                                generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
        \item $<$ion\_motion\_filename$>$ - name that points to the ion\_motion motion file
                                generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
       \item MULLIKEN - optional keyword which if specified
                         causes an omotion motion file to be created.  For this option
                         to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
        \item $<$omotion\_filename$>$ - name that points to the omotion motion file
                                generated. See section \ref{sec:pspw_cp_data} for a 
                                description of the datafile.
\end{itemize}


\subsection{\tt PSP\_GENERATOR}
\label{sec:pspw_psp_generator}
A one-dimensional pseudopotential code has been integrated into NWChem.
This code allows the user to modify and develop pseudopotentials.  Currently, 
only the Hamann and Troullier-Martins norm-conserving pseudopotentials can be
generated.  In future releases, the pseudopotential library (section \ref{sec:psp_library})
will be more complete, so that the user will not have explicitly generate
pseudopotentials using this module.

Input to the PSP\_GENERATOR task is contained within the
PSP\_GENERATOR  sub-block.
\begin{verbatim}
PSPW
  ...
  PSP_GENERATOR
     ...
  END
  ...
END
\end{verbatim}
To run a PSP\_GENERATOR calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW PSP_GENERATOR
\end{verbatim}
Listed below is the format of a PSP\_GENERATOR sub-block.
\begin{verbatim}
PSPW
... 
   PSP_GENERATOR
      PSEUDOPOTENTIAL_FILENAME: <string psp_name>
      ELEMENT: <string element>
      CHARGE: <real charge>
      MASS_NUMBER: <real mass_number>
      ATOMIC_FILLING: <integer ncore nvalence>
      ( (1||2||...) (s||p||d||f||...) <real filling> \
         ...)
      
      [CUTOFF: <integer lmax> 
         ( (s||p||d||f||g) <real rcut>\
         ...)
      ]
      PSEUDOPOTENTIAL_TYPE: (TROULLIER-MARTINS || HAMANN default HAMANN)
      SOLVER_TYPE: (PAULI || SCRHODINGER default PAULI)
      EXCHANGE_TYPE: (dirac || PBE96 default DIRAC)
      CORRELATION_TYPE: (VOSKO || PBE96 default VOSKO)
      [SEMICORE_RADIUS: <real rcore>]
      
   end
... 
END
\end{verbatim}
The following list describes the input for the PSP\_GENERATOR
sub-block.
\begin{itemize}

        \item $<$psp\_name$>$ - name that points to a.
        \item $<$element$>$ - Atomic symbol.
        \item $<$charge$>$ - charge of the atom
        \item $<$mass$>$ - mass number for the atom
        \item $<$ncore$>$ - number of core states
        \item $<$nvalence$>$ - number of valence states.
        \item ATOMIC\_FILLING:.....(see below)
        \item $<$filling$>$ - occupation of atomic state
        \item CUTOFF:....(see below) 
        \item $<$rcore$>$ - value for the semicore radius (see below) 
\end{itemize}


\subsubsection{\tt ATOMIC\_FILLING Block}
This required block is used to define the reference atom which is used
to define the pseudopotential. After the ATOMIC\_FILLING: $<$ncore$>$
$<$nvalence$>$ line, the core states are listed (one per line), and
then the valence states are listed (one per line). 
Each state contains two integer and a value.  The first integer
specifies the radial quantum number, $n$,
The second integer specifies the angular momentum quantum number, $l$,
and the third value specifies the occupation of the state.

For example to define a pseudopotential
for the Neon atom in the $1s^2 2s^2 2p^6$ state
could have the block
\begin{verbatim}
ATOMIC_FILLING: 1 2
        1  s  2.0   #core state    - 1s^2 
        2  s  2.0   #valence state - 2s^2
        2  p  6.0   #valence state - 2p^6
\end{verbatim}
for a pseudopotential with a $2s$ and $2p$ valence electrons
or the block
\begin{verbatim}
ATOMIC_FILLING: 3 0
        1  s  2.0    #core state
        2  s  2.0    #core state
        2  p  6.0    #core state
\end{verbatim}
could be used for a pseudopotential with no valence electrons.


\subsubsection{{\tt CUTOFF} Block}
This optional block specifies the cutoff distances used
to match the all-electron atom to the pseudopotential atom.  For
Hamann pseudopotentials $r_{cut}(l)$ defines the distance
where the all-electron potential is matched to the pseudopotential, and
for Troullier-Martins pseudopotentials $r_{cut}(l)$ defines the distance
where the all-electron orbital is matched to the pseudowavefunctions. 
Thus the definition of the radii depends on the type of pseudopotential.  
The cutoff radii used in Hamann pseudopotentials will be smaller than
the cufoff raddi used in Troullier-Martins pseudopotentials.  

For example to define a softened Hamann pseudopotential for
Carbon would be
\begin{verbatim}
ATOMIC_FILLING: 1 2
  1  s  2.0
  2  s  2.0
  2  p  2.0
CUTOFF: 2
  s  0.8
  p  0.85
  d  0.85
\end{verbatim}
while a similarly softened Troullier-Marting pseudopotential
for Carbon would be
\begin{verbatim}
ATOMIC_FILLING: 1 2
  1  s  2.0
  2  s  2.0
  2  p  2.0
CUTOFF: 2
  s  1.200
  p  1.275
  d  1.275
\end{verbatim}


\subsubsection{{\tt SEMICORE\_RADIUS} Option}
Specifying the SEMICORE\_RADIUS option turns on the semicore correction approximation proposed
by Louie et al (S.G. Louie, S. Froyen, and M.L. Cohen, Phys. Rev. B, \textbf{26}, 1738, (1982)).  
This approximation is known to dramatically improve results for systems containing 
alkali and transition metal atoms.  

The implmentation in the PSPW module defines the semi-core denisty, $\rho_{semicore}$ in terms of 
the core density, $\rho_{core}$, by using the sixth-order polynomial
\begin{eqnarray}
\rho_{semicore}(r) = \left\{ \begin{array}{ll}
                              \rho_{core} & \mbox{if $r \geq r_{semicore}$} \\
                              c_0 + c_3 r^3 + c_4 r^4 + c_5 r^5 + c_6 r^6 &  \mbox{if $r < r_{semicore}$}
                            \end{array}
                     \right.
\end{eqnarray}
This expansion was suggested by Fuchs and Scheffler 
(M. Fuchs, and M. Scheffler, Comp. Phys. Comm.,\textbf{119},67 (1999)), 
and is better behaved for taking derivatives (i.e. calculating ionic forces) than the expansion suggested 
by Louie et al.


\subsection{\tt PSP\_FORMATTER}
\label{sec:pspw_psp_formatter}
The functionality of this task is now performed automatically. For backwards 
compatibility, we provide a description of the input to this task.

The psp\_formatter task takes a non-separable pseudopotential defined in
one-dimension real-space in a one-dimensional psp datafile and does two 
things to it.  First it puts it into the semi-local form suggested by 
Kleinman and Bylander and then it expands in in a periodic Fourier
series defined by the simulation cell in the RTDB.  

Input to the PSP\_FORMATTER task is contained
within the PSP\_FORMATTER sub-block.
\begin{verbatim}
PSPW
  ...
  PSP_FORMATTER
     ...
  END
  ...
END
\end{verbatim}
To run a PSP\_FORMATTER calculation the following directive is used:
\begin{verbatim}
TASK PSPW PSP_FORMATTER
\end{verbatim}
Listed below is the format of a PSP\_FORMATTER sub-block.
\begin{verbatim}
PSPW
... 
   PSP_FORMATTER
      CELL_NAME:          <string cell_name> 
      PSP_FILENAME:       <string psp_name>
      FORMATTED_FILENAME: <string formatted_name>
      LOCP: (s||p||d||f||g default (see input description))
      LMAX: (s||p||d||f||g default (see input description))
   end
...
END
\end{verbatim}
The following list describes the input for the PSP\_FORMATTER
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points 
                to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$psp\_name$>$ - name that points
              to a one-dimensional pseudopotential datafile.
        \item $<$formatted\_name$>$ -  
              name that points to a formatted\_pseudopotential datafile.
        \item LMAX (s$||$p$||$d$||$f$||$g) - used to specify the maximum number
              of angular potentials to use. The default is set to the maximum
              angular momentum in $<$psp\_name$>$.
        \item LOCP (s$||$p$||$d$||$f$||$g) - used to specify which angular potential
              is to used as the local potential.  The default is is set to LMAX.
\end{itemize}



\subsection{\tt WAVEFUNCTION\_INTITIALIZER}
\label{sec:pspw_wavefunction_initializer}
The functionality of this task is now performed automatically. For backwards 
compatibility, we provide a description of the input to this task.

The wavefunction\_initializer task is used to generate an initial wavefunction
datafile.
Input to the WAVEFUNCTION\_INITIALIZER task is contained
within the WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
  ...
  WAVEFUNCTION_INITIALIZER
     ...
  END
  ...
END
\end{verbatim}
To run a WAVEFUNCTION\_INITIALIZER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_INITIALIZER
\end{verbatim}
Listed below is the format of a WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_INITIALIZER
     CELL_NAME: <string cell_name>
     WAVEFUNCTION_FILENAME: <string wavefunction_name default input_movecs>
     (RESTRICTED||UNRESTRICTED)
     if (RESTRICTED)   
        RESTRICTED_ELECTRONS: <integer restricted electrons>
     if (UNRESTRICTED) 
        UP_ELECTRONS: <integer up_electrons>
        DOWN_ELECTRONS: <integer down_electrons>
   END
...
END
\end{verbatim}
The following list describes the input for the WAVEFUNCTION\_INITIALIZER
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points 
                to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$wavefunction\_name$>$ - name that will point
              to a wavefunction file.
        \item RESTRICTED - keyword specifying that the calculation is restricted.
        \item UNRESTRICTED - keyword specifying that the calculation is unrestricted.

        \item $<$restricted\_electrons$>$ - number of restricted electrons.
               Not used if an UNRESTRICTED calculation. 
         \item $<$up\_electrons$>$ - number of spin-up electrons.
               Not used if a RESTRICTED calculation.
        \item $<$down\_electrons$>$ - number of spin-down electrons.
              Not used if a RESTRICTED calculation.
\end{itemize}

\subsubsection{Old Style Input (version 3.3) to {\tt WAVEFUNCTION\_INTITIALIZER}}

For backwards compatibility, the input to the WAVEFUNCTION\_INITIALIZER 
sub-block can also be of the form
\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_INITIALIZER
     CELL_NAME: <string cell_name>
     WAVEFUNCTION_FILENAME: <string wavefunction_name default input_movecs>
     (RESTRICTED||UNRESTRICTED)
     
     [UP_FILLING: <integer up_filling>
        [0 0 0   0]
        {<integer kx ky kz> (-2||-1||1||2)}]
     [DOWN_FILLING: <integer down_filling>
        [0 0 0   0]
        {<integer kx ky kz> (-2||-1||1||2)}]
   END
...
END
\end{verbatim}
where
\begin{itemize}
        \item $<$cell\_name$>$ - name that points 
                to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$wavefunction\_name$>$ - name that will point
              to a wavefunction file.
        \item RESTRICTED - keyword specifying that the calculation is restricted.
        \item UNRESTRICTED - keyword specifying that the calculation is unrestricted.
        \item $<$up\_filling$>$ - number of restricted molecular orbitals if
              RESTRICTED and number of spin-up molecular orbitals if 
              UNRESTRICTED.
        \item $<$down\_filling$>$ - number of spin-down moleclar orbitals if
              UNRESTRICTED.  Not used if a RESTRICTED calculation.
        \item $<$kx ky kz$>$ - specifies which planewave is to be filled. 
\end{itemize}

The values for the planewave $(-2||-1||1||2)$ are used to represent whether
the specified planewave is a cosine or a sine function, in addition
random noise can be added to these base functions. That is $+1$ 
represents a cosine function, and $-1$ represents a sine function.
The $+2$ and $-2$ values are used to represent a cosine function with
random components added and a sine function with random components
added respectively.  


\subsection{\tt V\_WAVEFUNCTION\_INITIALIZER}
\label{sec:pspw_v_wavefunction_initializer}
The functionality of this task is now performed automatically. For backwards 
compatibility, we provide a description of the input to this task.

The v\_wavefunction\_initializer task is used to generate an initial velocity 
wavefunction datafile.
Input to the V\_WAVEFUNCTION\_INITIALIZER task is contained
within the V\_WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
  ...
  V_WAVEFUNCTION_INITIALIZER
     ...
  END
  ...
END
\end{verbatim}
To run a V\_WAVEFUNCTION\_INITIALIZER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_INITIALIZER
\end{verbatim}
Listed below is the format of a V\_WAVEFUNCTION\_INITIALIZER sub-block.
\begin{verbatim}
PSPW
... 
   V_WAVEFUNCTION_INITIALIZER
     V_WAVEFUNCTION_FILENAME: <string v_wavefunction_name default input_vmovecs>
     CELL_NAME: <string cell_name>
     (RESTRICTED||UNRESTRICTED)
     UP_FILLING: <integer up_filling>
     DOWN_FILLING: <integer down_filling>
   END
...
END
\end{verbatim}
The following list describes the input for the V\_WAVEFUNCTION\_INITIALIZER
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points 
                to the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$wavefunction\_name$>$ - name that will point
              to a velocity wavefunction file.
        \item RESTRICTED - keyword specifying that the calculation is restricted.
        \item UNRESTRICTED - keyword specifying that the calculation is unrestricted.
        \item $<$up\_filling$>$ - number of restricted velocity molecular 
              orbitals if RESTRICTED and number of spin-up velocity molecular 
              orbitals if UNRESTRICTED.
        \item $<$down\_filling$>$ - number of spin-down velocity moleclar 
              orbitals if UNRESTRICTED.  Not used if a RESTRICTED calculation.
\end{itemize}



\subsection{\tt WAVEFUNCTION\_EXPANDER}
\label{sec:pspw_wavefunction_expander}
The wavefunction\_expander task is used to convert a new wavefunction
file that spans a larger grid space from an old wavefunction file.
Input to the WAVEFUNCTION\_EXPANDER task is contained
within the WAVEFUNCTION\_EXPANDER sub-block.
\begin{verbatim}
PSPW
  ...
  WAVEFUNCTION_EXPANDER
     ...
  END
  ...
END
\end{verbatim}
To run a WAVEFUNCTION\_EXPANDER calculation the following directive 
is used:
\begin{verbatim}
TASK PSPW WAVEFUNCTION_EXPANDER
\end{verbatim}
Listed below is the format of a WAVEFUNCTION\_EXPANDER sub-block.
\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_EXPANDER   
     OLD_WAVEFUNCTION_FILENAME: <string old_wavefunction_name default input_movecs>
     NEW_WAVEFUNCTION_FILENAME: <string new_wavefunction_name default input_movecs>
     NEW_NGRID: <integer na1 na2 na3>
    
   END
...
END
\end{verbatim}
The following list describes the input for the WAVEFUNCTION\_EXPANDER
sub-block.
\begin{itemize}
        \item $<$old\_wavefunction\_name$>$ - name that points
              to a wavefunction file.
        \item $<$new\_wavefunction\_name$>$ - name that will 
              point to a wavefunction file.
        \item $<$na1 na2 na3$>$ - number of grid points in each dimension
              for the new wavefunction file. 
\end{itemize}

\subsection{\tt STEEPEST\_DESCENT} 
\label{sec:pspw_steepest_descent}
The functionality of this task is now performed automatically by the PSPW minimizer. 
For backwards compatibility, we provide a description of the input to this task.

The steepest\_descent task is used to optimize the one-electron orbitals
with respect to the total energy.  In addition it can also be used to optimize
geometries.   This method is meant to be used for coarse optimization of
the one-electron orbitals.  A detailed description of the this method
is described in section \ref{sec:pspw_sd2}

Input to the steepest\_descent simulation is contained
within the steepest\_descent sub-block.
\begin{verbatim}
PSPW
  ...
  STEEPEST_DESCENT
     ...
  END
  ...
END
\end{verbatim}
To run a steepest\_descent calculation the following directive is used:
\begin{verbatim}
TASK PSPW steepest_descent 
\end{verbatim}
The steepest\_descent sub-block contains a great deal
of input, including pointers to data, as well as
parameter input.  Listed below is the format of a STEEPEST\_DESCENT sub-block.
\begin{verbatim}
PSPW
...
   STEEPEST_DESCENT
      CELL_NAME <string cell_name>
      [GEOMETRY_OPTIMIZE]
      INPUT_WAVEFUNCTION_FILENAME  <string input_wavefunctions  default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME <string output_wavefunctions default input_movecs>
      FAKE_MASS <real fake_mass default 400000.0>
      TIME_STEP <real time_step default 5.8>
      LOOP <integer inner_iteration outer_iteration default 10 1>
      TOLERANCES <real tole tolc tolr default 1.0d-9 1.0d-9 1.0d-4>
      ENERGY_CUTOFF       <real ecut default (see input desciption)>
      WAVEFUNCTION_CUTOFF <real wcut default (see input description)>
      EWALD_NCUT <integer ncut default 1>
      EWALD_RCUT <real rcut default (see input description)>
      XC (Vosko || PBE96  default Vosko)
      [MULLIKEN]

   END
...

END
\end{verbatim}
The following list describes the input for the STEEPEST\_DESCENT
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$. See section \ref{sec:pspw_cell}.
        \item GEOMETRY\_OPTIMIZE - optional keyword which if specified
              turns on geometry optimization.   
        \item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
        \item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
        \item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
        \item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$).
        \item $<$time\_step$>$ - value for the time step ($\Delta t$).
        \item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
        \item $<$outer\_iteration$>$ - number of outer iterations
        \item $<$tole$>$ - value for the energy tolerance.
        \item $<$tolc$>$ - value for the one-electron orbital tolerance.
        \item $<$tolr$>$ - value for the ion position tolerance.
        \item $<$ecut$>$ - value for the cutoff energy used
                           to define the density.  Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$wcut$>$ - value for the cutoff energy used
                           to define the one-electron orbitals. Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$ncut$>$ - value for the number of unit cells
                          to sum over (in each direction) for the real space
                          part of the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic.
        \item $<$rcut$>$ - value for the cutoff radius used
                          in the Ewald summation.  Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                          Default set to be
                          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item MULLIKEN - optional keyword which if specified
                         causes a Mulliken anaysis to be performed at
                         the end of the simulation.  For this option
                         to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
\end{itemize}

\subsection{\tt CONJUGATE\_GRADIENT} 
\label{sec:pspw_conjugate_gradient}
The functionality of this task is now performed automatically by the PSPW minimizer. 
For backwards compatibility, we provide a description of the input to this task.

The conjugate\_gradient task is used to optimize the one-electron orbitals
with respect to the total energy.  This method should be used for finer
optimization. It is better to use the steepest\_descent task when intitially 
optimizing the one-electron orbitals.  A detailed description of the this method
is described in section \ref{sec:pspw_cgmanifold}.


Input to the conjugate\_gradient simulation is contained
within the conjugate\_gradient sub-block.
\begin{verbatim}
PSPW
  ...
  CONJUGATE_GRADIENT
     ...
  END
  ...
END
\end{verbatim}
To run a conjugate\_gradient calculation the following directive is used:
\begin{verbatim}
TASK PSPW conjugate_gradient 
\end{verbatim}
The conjugate\_gradient sub-block contains a great deal
of input, including pointers to data, as well as
parameter input.  Listed below is the format of a conjugate\_gradient sub-block.
\begin{verbatim}
PSPW
...
   CONJUGATE_GRADIENT
      CELL_NAME: <string cell_name>
      (FORMATTED_FILENAME: <string formatted_name> \
       ...)
      INPUT_WAVEFUNCTION_FILENAME:  <string input_wavefunctions  default input_movecs>
      OUTPUT_WAVEFUNCTION_FILENAME: <string output_wavefunctions default input_movecs>
      [FAKE_MASS: <real fake_mass default 400000.0>]
      [TIME_STEP: <real time_step default 5.8>]
      LOOP: <integer inner_iteration outer_iteration default 10 1>
      TOLERANCES: <real tole tolc default 1.0e-9 1.0e-9>
      ENERGY_CUTOFF:       <real ecut default (see input description)>
      WAVEFUNCTION_CUTOFF: <real wcut default (see input description)>
      EWALD_NCUT: <integer ncut default 1>]
      EWALD_RCUT: <real rcut default (see input description)>
      EXCHANGE_CORRELATION: (Vosko || PBE96  default Vosko)
      [MULLIKEN]

   END
...

END
\end{verbatim}
The following list describes the input for the CONJUGATE\_GRADIENT
sub-block.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
        \item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
        \item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
        \item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$). This parameter is not presently used in a 
              conjugate gradient simulation
        \item $<$time\_step$>$ - value for the time step ($\Delta t$).  This
              parameter is not presently used in a conjugate gradient simulation.
        \item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
        \item $<$outer\_iteration$>$ - number of outer iterations
        \item $<$tole$>$ - value for the energy tolerance.
        \item $<$tolc$>$ - value for the one-electron orbital tolerance.
        \item $<$ecut$>$ - value for the cutoff energy used
                           to define the density. Default is set
                           to be the maximum value that will fit
                           within the simulation\_cell $<$cell\_name$>$.
        \item $<$wcut$>$ - value for the cutoff energy used
                           to define the one-electron orbitals.
                           Default is set to be the maximum value that 
                           will fix within the simulation\_cell $<$cell\_name$>$.
        \item $<$ncut$>$ - value for the number of unit cells
                          to sum over (in each direction) for the real space
                          part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
        \item $<$rcut$>$ - value for the cutoff radius used
                          in the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                           Default set to be
                          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
                               and Erzherhoff GGA functional.
        \item MULLIKEN - optional keyword which if specified
                         causes a Mulliken anaysis to be performed at
                         the end of the simulation.  For this option
                         to work angular momentum weights for each kind
                         of atom have to be entered into the RTDB using
                         the PSPW ANALYSIS sub-block (see section \ref{sec:pspw_analysis}.
\end{itemize}




\section{Band Tasks}
\label{sec:band_tasks}

All input to the Band Tasks is contained within the compound NWPW block,
\begin{verbatim}
NWPW
   ...
END
\end{verbatim}

To perform an actual calculation a TASK Band directive is used (Section \ref{sec:task}).  
\begin{verbatim}
  TASK Band
\end{verbatim} 

Once a user has specified a geometry, the Band module can be invoked with no input directives (defaults invoked throughout).  There are sub-directives which allow for customized application; those currently provided as options for the Band module are:
\begin{verbatim}
NWPW
  CELL_NAME <string cell_name default 'cell_default'>
  ZONE_NAME <string zone_name default 'zone_default'>
  INPUT_WAVEFUNCTION_FILENAME  <string input_wavefunctions  default input_movecs>
  OUTPUT_WAVEFUNCTION_FILENAME <string output_wavefunctions default input_movecs>
  FAKE_MASS <real fake_mass default 400000.0>
  TIME_STEP <real time_step default 5.8>
  LOOP <integer inner_iteration outer_iteration default 10 100>
  TOLERANCES <real tole tolc default 1.0e-7 1.0e-7>
  ENERGY_CUTOFF       <real ecut default (see input description)>
  WAVEFUNCTION_CUTOFF <real wcut default (see input description)>
  EWALD_NCUT <integer ncut default 1>]
  EWALD_RCUT <real rcut default (see input description)>
  EXCHANGE_CORRELATION: (Vosko || PBE96  default Vosko)
  DFT||ODFT||RESTRICTED||UNRESTRICTED
  MULT <integer mult default 1>
  
  SIMULATION_CELL ... (see input description) END
  BRILLOUIN_ZONE  ... (see input description) END

END 
\end{verbatim}
The following list describes these keywords.
\begin{itemize}
        \item $<$cell\_name$>$ - name that points to the
              the simulation\_cell named $<$cell\_name$>$.  See section \ref{sec:pspw_cell}.
        \item $<$formatted\_name$>$ - name that points
              to a formatted\_pseudopotential file.  A file must
              be specified for each kind of ion in the simulation.
        \item $<$input\_wavefunctions$>$ - name that points
              to a file containing one-electron orbitals
        \item $<$output\_wavefunctions$>$ - name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
        \item $<$fake\_mass$>$ - value for the electronic
              fake mass ($\mu$). This parameter is not presently used in a 
              conjugate gradient simulation
        \item $<$time\_step$>$ - value for the time step ($\Delta t$).  This
              parameter is not presently used in a conjugate gradient simulation.
        \item $<$inner\_iteration$>$ - number of iterations between the 
              printing out of energies and tolerances
        \item $<$outer\_iteration$>$ - number of outer iterations
        \item $<$tole$>$ - value for the energy tolerance.
        \item $<$tolc$>$ - value for the one-electron orbital tolerance.
        \item $<$ecut$>$ - value for the cutoff energy used
                           to define the density. Default is set
                           to be the maximum value that will fit
                            within the simulation\_cell $<$cell\_name$>$.
        \item $<$wcut$>$ - value for the cutoff energy used
                           to define the one-electron orbitals.
                           Default is set to be the maximum value that 
                           will fix within the simulation\_cell $<$cell\_name$>$.
        \item $<$ncut$>$ - value for the number of unit cells
                          to sum over (in each direction) for the real space
                          part of the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic.
        \item $<$rcut$>$ - value for the cutoff radius used
                          in the Ewald summation. Note Ewald summation
                          is only used if the simulation\_cell is periodic. \\
                           Default set to be
                          $\frac{MIN(\left| \vec{a_i} \right|)}{\pi}, i=1,2,3$.
        \item (Vosko $||$ PBE96) - Choose between Vosko et al's LDA 
                               parameterization or the Perdew, Burke, 
        \item SIMULATION\_CELL (see section \ref{sec:pspw_cell})
        \item BRILLOUIN\_ZONE  (see section \ref{sec:band_brillouin_zone})
\end{itemize}


\subsection{Brillouin Zone}
\label{sec:band_brillouin_zone}
The special points of the Brillouin zone for a Band structure calculation are 
stored in the RTDB.  To enter special points of the Brillouin zone into the RTDB 
the user defines a brillouin\_zone sub-block within the NWPW 
block.  Listed below is the format of a brillouin\_zone sub-block.
\begin{verbatim}
NWPW
...
   BRILLOUIN_ZONE
      ZONE_NAME <string name default 'zone_default'>
      (KVECTOR <real k1 k2 k3 no default> <real weight default (see input description)>
       ...)
   END
...
END
\end{verbatim}
The user enters the special points and weights of the
Brillouin zone.  The following list describes the input in detail.
\begin{itemize}
        \item $<$name$>$ - user-supplied name for the simulation block. 
        \item $<$k1 k2 k3$>$ - user-supplied values for a special point in the
                               Brillouin zone.
        \item $<$weight$>$ - user-supplied weight.  Default is to set the weight
                         so that the sum of all the weights for the entered  
                         special points adds up to unity.
\end{itemize}


\section{Pseudopotential Libraries}
\label{sec:psp_library}

A library of pseudopotentials is currently available  in the
directory \\
\verb+ $NWCHEM_TOP/src/nwpw/libraryps/library1+

The elements listed in the following table are present:

\begin{verbatim}
  H
 -------
  Li Be                                  C  N  O
 -------                             ------------------
                                      Al Si P  S  
 ------------------------------------------------------
                       Fe          Zn Ga               
 ------------------------------------------------------
\end{verbatim}

If you wish to redirect the code to a different directory ther than
the default one, 
you need to set the environmental variable
{\tt NWCHEM\_NWPW\_LIBRARY}
to the new location of the \verb+libraryps+ directory.



\section{NWPW RTDB Entries and DataFiles}
\label{sec:pspw_data}
Input to the PSPW and Band modules are contained in both the RTDB and datafiles.
The RTDB is used to store input that the user will need to directly specify.
Input of this kind includes ion positions, ion velocities, and simulation cell
parameters.  The datafiles are used to store input, such the one-electron 
orbitals, one-electron orbital velocities, formatted pseudopotentials, 
and one-dimensional pseudopotentials, that the user will in most cases
run a program to generate.

\subsection{Ion Positions}
The positions of the ions are stored in the default geometry structure
in the RTDB and must be specified  using the GEOMETRY directive.

\subsection{Ion Velocities}
The velocities of the ions are stored in the default geometry structure
in the RTDB, and must be specified using the GEOMETRY directive.


\subsection{{\tt ANALYSIS}: Mulliken RTDB data}
\label{sec:pspw_analysis}

To perform Mulliken analysis information is needed from one-dimensional
pseudopotential files.  In-order to facilitate the transfer of this information
to the simulation the ANALYSIS sub-block is used to exract the necessary information
and put it into the RTDB.
\begin{verbatim}
PSPW
...
   ANALYSIS
      (psp_filename: <string psp_name> \
       ...)
   END
...
END
\end{verbatim}
Basically, the user needs to enter each pseudopotential used in the simulation.
\begin{itemize}
        \item $<$psp\_name$>$ - name that ponts to a one-dimensional pseudopotential file.
\end{itemize}


\subsection{Wavefunction Datafile}
The one-electron orbitals are stored in a wavefunction datafile.  This
is a binary file and cannot be directly edited.  This datafile is used
by steepest\_descent and Car-Parrinello tasks and can be generated
using the wavefunction\_initializer or wavefunction\_expander tasks.

\subsection{Velocity Wavefunction Datafile}
The one-electron orbital velocities are stored in a velocity wavefunction 
datafile.  This is a binary file and cannot be directly edited.  This datafile 
is used by the Car-Parrinello task and can be generated
using the v\_wavefunction\_initializer task.

\subsection{Formatted Pseudopotential Datafile}
The pseudopotentials in Kleinman-Bylander form expanded on a simulation
cell (3d grid) are stored in a formatted pseudopotential datafile.
This is a binary file and cannot be directly edited.
This datafile 
is used by steepest\_descent and Car-Parrinello tasks and can be generated
using the pseudpotential\_formatter task.

\subsection{One-Dimensional Pseudopotential Datafile}
The one-dimensional pseudopotentials are stored in a one-dimensional 
pseudopotential file.  This is an ascii file and can be directly edited with
a text editor.  However, the user will usually use the psp\_generator
task to generate this datafile.

The data stored in the one-dimensional pseudopotential file is
\begin{verbatim}
   character*2 element       :: element name
   integer     charge        :: valence charge of ion
   real        mass          :: mass of ion
   integer     lmax          :: maximum angular component
   real        rcut(lmax)    :: cutoff radii used to define pseudopotentials
   integer     nr            :: number of points in the radial grid
   real        dr            :: linear spacing of the radial grid
   real        r(nr)         :: one-dimensional radial grid
   real        Vpsp(nr,lmax) :: one-dimensional pseudopotentials
   real        psi(nr,lmax)  :: one-dimensional pseudowavefunctions
   real        r_semicore        :: semicore radius
   real        rho_semicore(nr)  :: semicore density
\end{verbatim}
and the format of it is:
\begin{verbatim}
[line 1:     ] element  
[line 2:     ] charge mass lmax
[line 3:     ] (rcut(l), l=1,lmax)
[line 4:     ] nr dr
[line 5:     ]    r(1)  (Vpsp(1,l),  l=1,lmax)
[line 6:     ] ....
[line nr+4:  ] r(nr) (Vpsp(nr,l), l=1,lmax)
[line nr+5:  ] r(1)  (psi(1,l), l=1,lmax) 
[line nr+6:  ] ....
[line 2*nr+4:] r(nr) (psi(nr,l), l=1,lmax)
[line 2*nr+5:] r_semicore
if (r_semicore read) then
[line 2*nr+6:] r(1)  rho_semicore(1)
[line 2*nr+7:] ....
[line 3*nr+5:] r(nr) rho_semicore(nr)
end if
\end{verbatim}



\subsection{PSPW Car-Parrinello Output Datafiles}
\label{sec:pspw_cp_data}

\subsubsection{XYZ motion file}
Data file that stores ion positions and velocities as
a function of time in XYZ format.

\begin{verbatim}
[line 1:          ]  n_ion
[line 2:          ]  
do ii=1,n_ion
[line 2+ii:       ] atom_name(ii), x(ii),y(ii),z(ii),vx(ii),vy(ii),vz(ii)
end do
[line n_ion+3     ] n_nion

do ii=1,n_ion
[line n_ion+3+ii: ] atom_name(ii), x(ii),y(ii),z(ii), vx(ii),vy(ii),vz(ii)
end do
[line 2*n_ion+4:  ]  ....
\end{verbatim}


\subsubsection{ION\_MOTION motion file}
Datafile that stores ion positions and velocities
as a function of time

\begin{verbatim}
[line 1:          ]  it_out, n_ion, omega
[line 2:          ]  time
do ii=1,n_ion
[line 2+ii:       ] x(ii),y(ii),z(ii), vx(ii),vy(ii),vz(ii)
end do
[line n_ion+3     ] time
do 
do ii=1,n_ion
[line n_ion+3+ii: ] x(ii),y(ii),z(ii), vx(ii),vy(ii),vz(ii)
end do
[line 2*n_ion+4:  ]  ....
\end{verbatim}

\subsubsection{EMOTION motion file}
Datafile that store energies as a function of time
\begin{verbatim}
[line 1:          ]  time, E1,E2,E3,E4,E5,E6,E7,E8, (E9,E10, if Nose-Hoover)
[line 2:          ] ...
\end{verbatim}


\subsubsection{HMOTION motion file}
Datafile that stores the rotation matrix
as a function of time.

\begin{verbatim}
[line 1:          ] time
[line 2:          ] ms,ne(ms),ne(ms)
do i=1,ne(ms)
[line 2+i:        ] (hml(i,j), j=1,ne(ms)
end do
[line 3+ne(ms):   ] time
[line 4+ne(ms):   ] ....
\end{verbatim}


\subsubsection{EIGMOTION motion file}
Datafile that stores the eigenvalues for the one-electron
orbitals as a function of time.

\begin{verbatim}
[line 1:          ]  time, (eig(i), i=1,number_orbitals)
[line 2:          ] ...
\end{verbatim}


\subsubsection{OMOTION motion file}
Datafile that stores a reduced representation of the
one-electron orbitals.  To be used with a molecular
orbital viewer that will be ported to NWChem
in the near future. 


\section{Minimizing the DFT Energy Functional}
\label{sec:pspw_Minimize}

In this section the algorithms for steepest\_descent and conjugate\_gradient 
methods that are used to minimize the DFT energy functional are presented.
First is the the steepest descent method without line minimization.   
This method is slow, but doesn't require line minimization.  
Second is the recent method developed by Edelman, Arias, and Smith.
These researchers have developed methods for performing line minimizations
on the constrained space used in the DFT energy functional
(A. Edelman, T. Arias, and S.T. Smith, Siam J. Matrix Anal. Appl., 
\textbf{20},303, (1998)).


\subsection{Steepest Descent Equations}
\label{sec:pspw_sd2}

To minimize the DFT energy functional with respect to $\{\psi_{i,\sigma}\}$
we define the the auxiliary functional, $F$, which takes into account
the orthonormality constraints.

\begin{eqnarray}
F\left(\{\psi_{i,\sigma}\},\{\vec{R_I}\} \right)
&=& E\left(\{\psi_{i,\sigma}\},\{\vec{R_I}\} \right) \nonumber \\
&+&\sum_{ij,\sigma}  \left( \int d\vec{r}\ 
\psi_{i,\sigma}^{*}(\vec{r}) \psi_{j,\sigma}(\vec{r}) \Lambda_{ji,\sigma}
                 - \delta_{ij,\sigma} 
\right) 
\label{eq:sd1}
\end{eqnarray}

\noindent
The steepest descent minimization procedure without line minimization
is then
\begin{eqnarray}
\psi_{i,\sigma}^{t+ \Delta t} 
                   &\leftarrow& 
                    \psi_{i,\sigma}^{t} 
                      - \alpha 
                        \left[ 
                           \frac{\delta F}{\delta \psi_{i,\sigma}^{*}}
                        \right]_{t}
                   = \psi_{i,\sigma}^{t} 
                      - \alpha 
                        \left[ 
                           \frac{\delta E}{\delta \psi_{i,\sigma}^{*}}
                            + \sum_{j} \psi_{j,\sigma} \Lambda_{ji,\sigma} 
                        \right]_{t}
\label{eq:sd2}
\end{eqnarray}
where $\alpha =\frac{\Delta t}{\sqrt{\mu}}$ is a positive numerical parameter.
In this minimization procedure we have to know the variational derivative
$\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ and the matrix 
$\Lambda_{ij,\sigma}$. 
The variational derivative $\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ 
can be analytically found and is
\begin{eqnarray}
\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
      &=&  -\frac{1}{2} \nabla^2 
            \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
           W_{ext}(\vec{r},\vec{r^{\prime}}) 
          \psi_{i,\sigma}(\vec{r^{\prime}}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
                    \frac{n(\vec{r^{\prime}})}{|\vec{r}-\vec{r^{\prime}}|}
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \mu_{xc}^{\sigma}(\vec{r}) 
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
& \equiv & \hat{H} \psi_{i,\sigma}
\label{eq:sd3}
\end{eqnarray}
  
The ion positions can also be minimized using a fixed step minimization 
procedure.
\begin{eqnarray}
\vec{R}_I^{t+\Delta t} &\leftarrow& 
                      \vec{R}_I^{t}
                    - \frac{(\Delta t)}{\sqrt{M_I}} 
                       \frac{\partial E}{\partial \vec{R}_I}
\end{eqnarray}
                      
\noindent
To find the matrix $\Lambda_{ij,\sigma}$ we impose the orthonormality
constraint on $\psi_{i,\sigma}^{t+\Delta t}$ to obtain the
matrix Riccatti equation 
(to simplify the following equations we define the following symbol
$\bar{\psi}_{i,\sigma}^{t} =  
              \left(\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} \right)_{t}$
)

\begin{eqnarray}
I &=& <\psi_{i,\sigma}^{t+\Delta t} | \psi_{j,\sigma}^{t+\Delta t}> \nonumber \\
  &=& 
   \left( <\psi_{i,\sigma}^{t}| 
          - \alpha  
            \left[
                  <\bar{\psi}_{i,\sigma}^{t}| 
                  + \sum_{k} \Lambda_{ik,\sigma}^{*} <\psi_{k,\sigma}^{t}|
            \right]
   \right) \nonumber \\
& & 
   \left( |\psi_{j,\sigma}^{t}> 
          - \alpha  
            \left[
                  |\bar{\psi}_{j,\sigma}^{t}> 
                  + \sum_{l} |\psi_{l,\sigma}^{t}> \Lambda_{lj,\sigma} 
            \right]
   \right) \nonumber \\
  &=& <\psi_{i,\sigma}^{t}| \psi_{j,\sigma}^{t}> \nonumber \\
  &-& \alpha 
       \left[ 
         \begin{array}{ll}
           <\psi_{i,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> &
         + <\bar{\psi}_{i,\sigma}^{t}| \psi_{j,\sigma}^{t}> \\
         + \sum_{k} \Lambda_{ik,\sigma}^{*} 
                     <\psi_{k,\sigma}^{t}| \psi_{j,\sigma}^{t}> &
         + \sum_{l} <\psi_{i,\sigma}^{t}| \psi_{l,\sigma}^{t}>
                    \Lambda_{lj,\sigma} 
        \end{array}
       \right] \nonumber \\
  &+& \alpha^2 
       \left[
               <\bar{\psi}_{i,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> 
            + \sum_{k} \Lambda_{ik,\sigma}^{*} 
                    <\psi_{k,\sigma}^{t}| \bar{\psi}_{j,\sigma}^{t}> 
            + \sum_{l} <\bar{\psi}_{i,\sigma}^{t}| \psi_{l,\sigma}^{t}>
                         \Lambda_{lj,\sigma} 
       \right]     \nonumber \\
  &+& \alpha^2 
       \left[
                \sum_{k} \sum_{l}
                 \Lambda_{ik,\sigma}^{*} 
                 <\psi_{k,\sigma}^{t}|\psi_{l,\sigma}^{t}>
                 \Lambda_{lj,\sigma} 
       \right] \nonumber \\
  &=& A + \alpha XB + \alpha B^{\dag}X^{\dag} + \alpha^2 XCX^{\dag} 
\label{eq:sd4}
\end{eqnarray}

\noindent
where $X_{ij,\sigma}=\Lambda_{ij,\sigma}^{*}$ and the matrices 
$A$, $B$, and $C$ are given by

\begin{eqnarray}
A_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
                     \right)_t
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{j,\sigma}^{*}}
                     \right)_t
             \right] \\
B_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
                   - \alpha 
                     \left( \frac{\delta E}{\delta \psi_{j,\sigma}^{*}}
                     \right)_t
             \right] \\
C_{ij,\sigma} &=& \int d\vec{r} 
             \left[\psi_{i,\sigma}^{t}(\vec{r}) 
             \right]^{*} 
             \left[\psi_{j,\sigma}^{t}(\vec{r}) 
             \right]
\end{eqnarray}

\noindent
To solve the Riccatti equation an iterative solution is setup by rewriting
Eq.~\ref{eq:sd4} in the following form.
\begin{equation}
\alpha^2 XCX^{\dag} + \alpha X(B-I) + \alpha (B^{\dag}-I)X^{\dag} 
 + \alpha(X + X^{\dag}) = I-A
\end{equation}
Since X is by definition Hermitian, $X=X^{\dag}$, and 
\begin{eqnarray}
A  &\approx& I + O(\alpha) \nonumber \\
B  &\approx& I + O(\alpha)  \\
\end{eqnarray}
we can solve for X iteratively.
\begin{eqnarray}
\label{eq:sd15}
X_{(n)} \leftarrow && \frac{1}{2 \alpha}(I-A) + \nonumber \\
                   && \frac{1}{2} \left( X_{(n-1)}(I-B)
                    + (I-B^{\dag})X_{(n-1)}^{\dag}
                    - \alpha X_{(n-1)}CX_{(n-1)}^{\dag} \right)  \\
\label{eq:sd16}
X_{(0)} \leftarrow && \left(\frac{I-A}{2 \alpha}\right)
\end{eqnarray}


\subsection{Conjugate Gradient with Curvature: Grassmann Manifold}
\label{sec:pspw_cgmanifold}

Minimizing the DFT energy functional with a non-linear conjugate 
gradient algorithm requires an algorithm for minimizing along a 
search direction or line.  However, the equation for a line 
(or search direction) in the DFT minimization problem is complicated 
by the fact that the energy functional is subject to orthonormality 
constraints. 
Furthermore, the orthonormality constraints complicate the
conjugate gradient's algorithm for generating the current search 
direction by using a linear combination of the current gradient and 
the previous search direction, since the previous search direction
must be parallel transported to the current search point.

These orthonormality constraint problems
have been investigated and solved for by Edelman {\it et al} 
(A. Edelman, T. Arias, and S.T. Smith, Siam J. Matrix Anal. Appl., 
\textbf{20},303, (1998)).  
They recognized that the orthonormal Kohn-Sham
orbitals $\{\psi_{i,\sigma}\}$ 
belong to a quotient space called a Grassmann manifold. 
Using the properties of the Grassmann manifold they
developed an equation for a line (or geodesic) which
conserves orthonormality, as well as 
a conjugate gradient procedure for generating the current search direction on this
constrained space.

Following Edelman {\it et al} we write
$\{ \psi_{i,\sigma}(\vec{r}) \}$ in terms of the orthonormal basis
$\{ \phi_j(\vec{r}) \}$.
\begin{equation}
\psi_{i,\sigma}(\vec{r}) = \sum_{j}^{N_{basis}} 
                           \psi_{i,\sigma}(\phi_j) 
                            \phi_j(\vec{r})
\end{equation}
Which allows us to rewrite the DFT energy functional as a function,
$E(Y_{\uparrow},Y_{\downarrow})$, of two tall and skinny 
$N_{basis}$-by-$N_{\sigma}$ matrices which are
\begin{equation}
Y_{\uparrow}=\left[\begin{array}{rrrr}
                    \psi_{1,\uparrow}(\phi_1) 
                     & \psi_{2,\uparrow}(\phi_1) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_1) \\
                    \psi_{1,\uparrow}(\phi_2) 
                     & \psi_{2,\uparrow}(\phi_2) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_2) \\
                    \psi_{1,\uparrow}(\phi_3) 
                     & \psi_{2,\uparrow}(\phi_3) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_3) \\
                    \vdots 
                     & \vdots
                     &
                     & \vdots \\
                    \psi_{1,\uparrow}(\phi_{N_{basis}}) 
                     & \psi_{2,\uparrow}(\phi_{N_{basis}}) 
                     & \cdots
                     & \psi_{N_{\uparrow},\uparrow}(\phi_{N_{basis}})
                   \end{array}
               \right]
\end{equation}
and
\begin{equation}
Y_{\downarrow}=\left[\begin{array}{rrrr}
                    \psi_{1,\downarrow}(\phi_1) 
                     & \psi_{2,\downarrow}(\phi_1) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_1) \\
                    \psi_{1,\downarrow}(\phi_2) 
                     & \psi_{2,\downarrow}(\phi_2) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_2) \\
                    \psi_{1,\downarrow}(\phi_3) 
                     & \psi_{2,\downarrow}(\phi_3) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_3) \\
                    \vdots 
                     & \vdots
                     & 
                     & \vdots \\
                    \psi_{1,\downarrow}(\phi_{N_{basis}}) 
                     & \psi_{2,\uparrow}(\phi_{N_{basis}}) 
                     & \cdots
                     & \psi_{N_{\downarrow},\downarrow}(\phi_{N_{basis}})
                   \end{array}
               \right]
\end{equation}
The orthonormality constraints make the $Y_{\sigma}$ matrices
obey $Y_{\sigma}^{\dag}Y_{\sigma}=I$. 
Furthermore since the LSDA energy can be written as
\begin{equation}
E(Y_{\uparrow},Y_{\downarrow}) = \sum_{\sigma} 
        tr \left( Y_{\sigma}^{\dag} (\mathrm{Operator}) Y_{\sigma} \right)
\end{equation}
we are only interested in subspace spanned by $Y_\sigma$.
This homogeneity property allows us to state that
$E(Y_{\uparrow},Y_{\downarrow}) = E(Y_{\uparrow}Q_{\uparrow},Y_{\downarrow}Q_{\downarrow})$ 
where $Q_{\sigma}$ is any $N_{\sigma}$-by-$N_{\sigma}$
orthogonal matrix (i.e. $Q$ is any group element of the orthogonal
group $O(N_{\sigma})$).  The constrained surface that each $Y_{\sigma}$ spans
is known as the Grassmann manifold (i.e. $Y_{\sigma}$ is a group element
of the quotient space group 
$\frac{\left(\frac{O(N_{basis})}{O(N_{basis}-N_{\sigma})}\right)}{O(N_{\sigma})}$
\footnote{See reference on Lie Groups, e.g. reference (P.J. Olver, 
\textit{Equivalence, Invariants, and Symmetry}, 1st ed. Cambridge University Press,
New York, 1995), for a definition of a quotient space and a definition of the 
          orthogonal group $O(n)$.
         }
).

In this work Algorithm~\ref{algorithm:grassmann} (see below) is the 
conjugate gradient
algorithm that is used to minimize the DFT energy functional
$E=E\left( Y_{\uparrow},Y_{\downarrow} \right)$.  What makes this
algorithm different from a standard 
Polak-Ribi\`{e}re conjugate gradient algorithm
is that a line search on a Euclidean space 
\[ Y_{\sigma}(t) = Y_{\sigma}^{(0)} + t*H_{\sigma}^{(0)} \]
is replaced by Eq.~\ref{grass:1}, 
and the parallel transports on a Euclidean space
\[ \tau H_{\sigma}^{(0)} = H_{\sigma}^{(0)} \]
\[ \tau G_{\sigma}^{(0)} = G_{\sigma}^{(0)} \]
are replaced by Eqs.~\ref{grass:2}-\ref{grass:3}.

\begin{algorithm}{Edelman {\it et al's} Algorithm for Conjugate Gradient
                  Minimization on the Grassmann Manifold}
                   
\label{algorithm:grassmann}
   \item Given $Y_{\sigma}^{(0)}$ such that 
               $Y_{\sigma}^{(0)\dag}Y_{\sigma}^{(0)}$,\\
               Compute $G_{\sigma}^{(0)} 
                        = \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(0)}}
               -  Y_{\sigma}^{(0)}Y_{\sigma}^{(0) \dag} 
                         \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(0)}}$ \\
               Set $H_{\sigma}^{(0)} = -G_{\sigma}^{(0)}$.
   \item Find the compact singular value decompositions of 
           $H_{\sigma}^{(0)} \rightarrow 
                U_{\sigma} \Sigma_{\sigma} V_{\sigma}^{\dag}$
   \item Minimize $E\left(Y_{\uparrow}(t), Y_{\downarrow}(t) \right)$ along the 
         geodesic lines derived by Edelman {\it et al} for the 
         Grassmann Manifold\\
        \begin{equation}
          Y_{\sigma}(t) = Y_{\sigma}^{(0)} V_{\sigma} 
                             \cos \left(\Sigma_{\sigma} t \right) V^{\dag}
           + U_{\sigma} \sin \left(\Sigma_{\sigma} t \right) V_{\sigma}^{\dag}
         \label{grass:1}
        \end{equation}
   \item Set $Y_{\sigma}^{(1)} = Y_{\sigma}(t_{min})$ and\\
         compute $G_{\sigma}^{(1)} 
                        = \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(1)}}
               -  Y_{\sigma}^{(1)}Y_{\sigma}^{(1) \dag} 
                         \left[\frac{\delta E}{\delta Y_{\sigma}}
                          \right]_{Y_{\sigma}=Y_{\sigma}^{(1)}}$ 
   \item Parallel transport along the geodesics the tangent vectors
         $H_{\sigma}^{(0)}$ and $G_{\sigma}^{(0)}$
        \begin{equation}
          \tau H_{\sigma}^{(0)} = 
            \left( -Y_{\sigma}^{(1)} V_{\sigma} 
                     \sin \left(\Sigma_{\sigma} t \right)
           + U_{\sigma} \cos \left(\Sigma_{\sigma} t \right) 
             \right) \Sigma_{\sigma} V_{\sigma}^{\dag}
         \label{grass:2}
        \end{equation}
        \begin{equation}
          \tau G_{\sigma}^{(0)} = G_{\sigma}^{(0)}
            \left( Y_{\sigma}^{(1)} V_{\sigma} 
                       \sin \left(\Sigma_{\sigma} t \right)
           + U_{\sigma} \left(I- \cos \left(\Sigma_{\sigma} t \right) \right) 
             \right) U_{\sigma}^{\dag} G_{\sigma}^{(0)}
         \label{grass:3}
        \end{equation}
   \item Compute the new search direction
        \[
             H_{\sigma}^{(1)} = -G_{\sigma}^{(1)}  
                                + \Gamma_{\sigma} \tau H_{\sigma}^{(0)}
        \]
        where
        \[
           \Gamma_{\sigma} = \frac{tr \left[\left(G_{\sigma}^{(1)} 
                                   - \tau G_{\sigma}^{(0)}\right)
                                     G_{\sigma}^{(1)}\right]}
                                  {tr \left[G_{\sigma}^{(0)}
                                        G_{\sigma}^{(0)}\right]}
        \]
   \item Set 
         $Y_{\sigma}^{(0)} = Y_{\sigma}^{(1)}$,
         $G_{\sigma}^{(0)} = G_{\sigma}^{(1)}$, and
         $H_{\sigma}^{(0)} = H_{\sigma}^{(1)}$
   \item Go to step 2.
\end{algorithm}
\normalsize        

\section{Car-Parrinello Scheme for Ab Initio Molecular Dynamics}
\label{sec:pspw_Car-Parrinello}

Car and Parrinello developed a unified scheme for doing {\it ab initio}
molecular dynamics by combining the motion of the ion cores and a fictacious
motion for the Kohn-Sham orbitals of density-functional theory 
(R. Car and M. Parrinello, Phys. Rev. Lett. \textbf{55}, 2471, (1985)).  
At the heart of this method they introduced a fictacious kinetic energy 
functional for the Kohn-Sham orbitals.

\begin{eqnarray}
\label{appendix:b1}
KE(\{\psi_{i,\sigma}(\vec{r})\}) &=& \sum_{i,\sigma}^{occ} 
                                      \int d\vec{r}\ \mu \left| 
                                      \dot{\psi}_{i,\sigma}(\vec{r}) \right|^2 
\end{eqnarray}

\noindent
Given this kinetic energy the constrained equations of motion are found 
by taking the first variation of the auxiliary Lagrangian.
\begin{eqnarray}
\label{appendix:b2}
L &=& \sum_{i,\sigma}^{occ} \int d\vec{r}\ \mu \left| 
     \dot{\psi}_{i,\sigma}(\vec{r}) \right|^2 
     + \frac 12 \sum_I M_I \left| \dot{\vec{R}}_I \right|^2 
- E\left[ \left\{ \psi_{i,\sigma}(\vec{r})\right\},\left\{\vec{R}_I \right\} \right]  
\nonumber \\
&&+\sum_{ij,\sigma} \Lambda_{ij,\sigma} \left( \int d\vec{r}\ 
\psi_{i,\sigma}^{*}(\vec{r}) \psi_{j,\sigma}(\vec{r}) - \delta_{ij,\sigma} 
\right) 
\end{eqnarray}

\noindent
Which generates a dynamics for the wavefunctions $\psi_{i,\sigma}(\vec{r})$ and 
atoms positions $\vec{R}_I$ through the constrained equations of motion:

\begin{eqnarray}
\mu \ddot{\psi}_{i,\sigma}(\vec{r},t) &=& -\frac{\delta E}{\delta \psi_{i,\sigma }^{*}
\left( \vec{r},t \right) } + \sum\limits_j \Lambda_{ij,\sigma} 
\psi_{j,\sigma} \left( \vec{r},t \right)
\label{eq:b3}
\end{eqnarray}
\begin{eqnarray}
M_I \ddot{\vec{R}}_I &=& -\frac{\partial E}{\partial \vec{R}_I}
\label{eq:b4}
\end{eqnarray}

\noindent
where $\mu$ is the fictitious mass for the electronic degrees of freedom and 
$M_I$ are the ionic masses.  
The adjustable parameter $\mu$ is used to 
describe the relative rate at which the wavefunctions change with time.  
$\Lambda_{ij,\sigma}$ are the 
Lagrangian multipliers for the orthonormalization of the single-particle 
orbitals $\psi_{i,\sigma}(\vec{r})$. 
They are defined by the orthonormalization constraint conditions
and can be rigorously found. 
However, the equations of motion for the Lagrange multipliers
depend on the specific algorithm used to integrate
Eqs.~\ref{eq:b3}-\ref{eq:b4}.

For this method to give ionic motions that are physically meaningful
the kinetic energy of the Kohn-Sham orbitals must be relatively
small when compared to the kinetic energy of the ions.
There are two ways where this criterion can fail.
First, the numerical integrations for the Car-Parrinello equations of motion 
can often lead to large relative values of the kinetic energy of 
the Kohn-Sham orbitals relative to the kinetic energy of the ions.
This kind of failure is easily fixed by requiring a more accurate
numerical integration, i.e. use a smaller time step for the numerical
integration.
Second, during the motion of the system a the ions can be in locations where
there is an Kohn-Sham orbital level crossing, i.e. the density-functional
energy can have two states that are nearly degenerate.  This kind
of failure often occurs in the study of chemical reactions.
This kind of failure is not easily fixed and requires the use
of a more sophisticated density-functional energy that accounts
for low-lying excited electronic states.


\subsection{Verlet Algorithm for Integration}
%\subsection{Verlet Algorithm for Integrating Eqs. \ref{eq:b3} - \ref{eq:b4} }

Eqs.~\ref{eq:b3}-\ref{eq:b4} integrated using the Verlet algorithm
results in

\begin{eqnarray}
\psi_{i,\sigma}^{t+ \Delta t} 
                   &\leftarrow& 
                    2 \psi_{i,\sigma}^{t} - \psi_{i,\sigma}^{t-\Delta t}
                      + \frac{(\Delta t)^2}{\mu}
                        \left[ 
                           \frac{\delta E}{\delta \psi_{i,\sigma}^{*}}
                            + \sum_{j} \psi_{j,\sigma} \Lambda_{ji,\sigma} 
                        \right]_{t}
\label{eq:b6}
\end{eqnarray}
\begin{eqnarray}
\vec{R}_I^{t+\Delta t} &\leftarrow& 
                    2 \vec{R}_I^{t} - \vec{R}_I^{t-\Delta t}
                    + \frac{(\Delta t)^2}{M_I} 
                       \frac{\partial E}{\partial \vec{R}_I}
\label{eq:b7}
\end{eqnarray}
               
In this molecular dynamic procedure we have to know variational derivative
$\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ and the matrix 
$\Lambda_{ij,\sigma}$. 
The variational derivative $\frac{\delta E}{\delta \psi_{i,\sigma}^{*}}$ 
can be analytically found and is
\begin{eqnarray}
\frac{\delta E}{\delta \psi_{i,\sigma}^{*}} 
      &=&  -\frac{1}{2} \nabla^2 
            \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
           W_{ext}(\vec{r},\vec{r^{\prime}}) 
          \psi_{i,\sigma}(\vec{r^{\prime}}) \nonumber \\
      &+& \int d\vec{r^{\prime}} 
                    \frac{n(\vec{r^{\prime}})}{|\vec{r}-\vec{r^{\prime}}|}
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
      &+& \mu_{xc}^{\sigma}(\vec{r}) 
          \psi_{i,\sigma}(\vec{r}) \nonumber \\
& \equiv & \hat{H} \psi_{i,\sigma}
\label{eq:b8}
\end{eqnarray}
                        
\noindent
To find the matrix $\Lambda_{ij,\sigma}$ we impose the orthonormality
constraint on $\psi_{i,\sigma}^{t+\Delta t}$ to obtain a
matrix Riccatti equation, and then Riccatti equation is solved by an iterative
solution (see section ~\ref{sec:pspw_sd2}).


\subsection{Constant Temperature Simulations: Nose-Hoover Thermostats}
\label{sec:pspw_nose}

Nose-Hoover Thermostats for the electrons and ions can also be added to the 
Car-Parrinello simulation.  In this type of simulation thermostats variables $x_e$ and $x_R$ 
are added to the simulation by adding the auxillary energy functionals to the total energy.
\begin{eqnarray}
ION\_THERMOSTAT(x_R)      &=&  \frac{1}{2} Q_R \dot{x_R} + E_{R0}x_R \\ 
ELECTRON\_THERMOSTAT(x_e) &=&  \frac{1}{2} Q_e \dot{x_e} + E_{e0}x_e 
\end{eqnarray}

In these equations, the average kinetic energy for the ions is
\begin{eqnarray}
E_{R0} = \frac{1}{2} f k_B T
\end{eqnarray}
where $f$ is the number of atomic degrees of freedom, $k_B$ is 
Boltzmans constant, and T is the desired temperature.  Defining
the average fictacious kinetic energy of the electrons is not as straighforward.
Bl\"{o}chl and Parrinello 
(P.E. Bl\"{o}chl and M. Parrinello, Phys. Rev. B, \textbf{45}, 9413, (1992)) 
have suggested the following formula for determining
the average fictacious kinetic energy
\begin{eqnarray}
E_{e0} = 4 k_B T \frac{\mu}{M} \sum_i <\psi_i|-\frac{1}{2} \nabla^2 |\psi_i>
\end{eqnarray}
where $\mu$ is the fictacious electronic mass, $M$ is average mass of one atom,
and $\sum_i <\psi_i|-\frac{1}{2} \nabla^2 |\psi_i>$ is the kinetic energy of the
electrons.

Bl\"{o}chl and Parrinello suggested that the choice of mass parameters, 
$Q_e$, and $Q_R$ should be made such that the period of oscillating thermostats 
should be chosen larger than the typical time scale for the dynamical events of 
interest but shorter than the simulation time.  
\begin{eqnarray}
P_{ion} &=& 2\pi \sqrt{\frac{Q_R}{4E_{R0}}}\\
P_{electron} &=& 2\pi \sqrt{\frac{Q_e}{4E_{e0}}}
\end{eqnarray}
where $P_{ion}$ and $P_{electron}$ are the periods of oscillation for the ionic and ficatious
electronic thermostats.  




\section{PSPW Tutorial 1: Minimizing the geometry for a C$_2$ molecule}
\label{sec:pspw_sd}

In this section we show how use the PSPW module to optimize the geometry 
for a C$_2$ molecule at the LDA and PBE96 levels. 

In the following example we show the input needed to optimize the geometry
for a C$_2$ molecule at the LDA level.  In this example, default pseudopotentials
from the pseudopotential library are used for C, the boundary condition is free-space, 
the exchange correlation functional is LDA, The boundary condition is free-space, and 
the simulation cell cell is aperiodic and cubic with a side length of 10.0 Angstroms and has
40 grid points in each direction (cutoff energy is 44 Ry).  This example input 
deck can be found in the nwchem source tree in the file: nwchem/examples/pspw/c2\_pspw\_lda.nw
\begin{verbatim}
         
start c2_pspw_lda
title "C2 restricted singlet dimer optimization - LDA/44Ry"

geometry  
C    -0.62 0.0 0.0
C     0.62 0.0 0.0
end
       
pspw
   simulation_cell units angstroms
      boundary_conditions aperiodic
      lattice
        lat_a 10.00d0
        lat_b 10.00d0
        lat_c 10.00d0
      end
      ngrid 40 40 40
   end
end
set nwpw:minimizer 2
task pspw optimize
\end{verbatim}

In the next example we show the input needed to optimize the geometry
for a C$_2$ molecule at the PBE96 level.  For the most part the input
is exactly the same as above.  However additional input is needed to
specify a GGA pseudopotential for carbon, since in the current release PBE96
pseudopotentials are not included in the default pseudopotential library.

\begin{verbatim}
start c2_pspw_pbe96
title "C2 restricted singlet dimer optimization - PBE96/44Ry"

geometry  
C    -0.62 0.0 0.0
C     0.62 0.0 0.0
end

pspw

   ###### Troullier and Martins PBE96 pseudopotential for carbon #####
   psp_generator
     pseudopotential_filename: C.psp
     element: C
     charge: 6.0
     mass_number: 12.0
     solver_type: pauli
     pseudopotential_type: troullier-martins
     exchange_type: pbe96
     correlation_type: pbe96
     maximum_angular_momentum: p   
     atomic_filling: 1 2
       1 s 2.0
       2 s 2.0
       2 p 2.0
     cutoff: 2
       s 1.50
       p 1.54
   end
      
   simulation_cell units angstroms
      boundary_conditions aperiodic
      lattice
        lat_a 10.00d0
        lat_b 10.00d0
        lat_c 10.00d0
      end
      ngrid 40 40 40
   end
   xc pbe96
end
set nwpw:minimizer 2
task pspw optimize
\end{verbatim}


\normalsize
\section{PSPW Tutorial 2: Running a Car-Parrinello Simulation}
\label{sec:pspw_cp}
\normalsize

In this section we show how use the PSPW module to perform a Car-Parrinello
molecular dynamic simulation for a C$_2$ molecule at the LDA level.  
Before running a PSPW Car-Parrinello  simulation the system should be
on the Born-Oppenheimer surface, i.e. the one-electron orbitals should be minimized 
with respect to the total energy (i.e. task pspw energy).  The input needed
is basically the same as for optimizing the geometry of a C$_2$ molecule at the LDA level,
except that and additional Car-Parrinello sub-block is added.  

In the following example we show the input needed to run a Car-Parrinello simulation
for a C$_2$ molecule at the LDA level.  In this example, default pseudopotentials
from the pseudopotential library are used for C, the boundary condition is free-space, 
the exchange correlation functional is LDA, The boundary condition is free-space, and 
the simulation cell cell is aperiodic and cubic with a side length of 10.0 Angstroms and has
40 grid points in each direction (cutoff energy is 44 Ry).  The time step and fake mass
for the Car-Parrinello run are specified to be 5.0 au and 600.0 au, respectively.  
This example input deck can be found in the nwchem source tree in the file: nwchem/examples/pspw/c2\_pspw\_lda\_md.nw

\begin{verbatim}
         
start c2_pspw_lda_md
title "C2 restricted singlet dimer, LDA/44Ry - constant energy Car-Parrinello simulation"

geometry  
C    -0.62 0.0 0.0
C     0.62 0.0 0.0
end
       
pspw
   simulation_cell units angstroms
      boundary_conditions aperiodic
      lattice
        lat_a 10.00d0
        lat_b 10.00d0
        lat_c 10.00d0
      end
      ngrid 40 40 40
   end
   Car-Parrinello
     fake_mass 600.0
     time_step 5.0
     loop 10 10
   end
end
set nwpw:minimizer 2
task pspw energy
task pspw Car-Parrinello
\end{verbatim}



\normalsize
\section{Band Tutorial 1: Minimizing the energy of a silicon-carbide crystal by running a PSPW and Band simulation in tandem}
\label{sec:band_tutorial1}
\normalsize
 
\begin{verbatim}
start SiC_band
title "SiC 8 atom cubic cell"

#**** geometry entered using fractional coordinates ****
geometry units au center noautosym noautoz print 
  system crystal 
    lat_a 8.277d0
    lat_b 8.277d0
    lat_c 8.277d0
    alpha 90.0d0
    beta  90.0d0
    gamma 90.0d0
  end
Si    -0.50000d0  -0.50000d0  -0.50000d0
Si     0.00000d0   0.00000d0  -0.50000d0
Si     0.00000d0  -0.50000d0   0.00000d0
Si    -0.50000d0   0.00000d0   0.00000d0
C     -0.25000d0  -0.25000d0  -0.25000d0
C      0.25000d0   0.25000d0  -0.25000d0
C      0.25000d0  -0.25000d0   0.25000d0
C     -0.25000d0   0.25000d0   0.25000d0
end

#***** setup the nwpw gamma point code ****
nwpw
   simulation_cell
     ngrid 16 16 16
   end
   brillouin_zone
     kvector  0.0 0.0 0.0
   end
   ewald_ncut 8
end
set nwpw:minimizer 2
set nwpw:psi_brillioun_check .false.
task pspw energy
task band energy
\end{verbatim}


\section{NWPW Capabilities and Limitations}
\label{sec:pspw_limits}
\normalsize

\begin{itemize}
\item You cannot use more processors than the size of the third dimension 
  (e.g. a 64x64x64 FFT grid can use at most 64 processors).
\item The second and third dimensions of the FFT grid must be the same 
  (i.e. the parameters na2 and na3 must be the same for each simulation cell).
\item A default Brillouin zone has not been defined for Band simulations.
\end{itemize}


\section{Questions and Difficulties}
\normalsize

Questions and encountered problems should be reported to 
nwchem-support@emsl.pnl.gov 
or to Eric J. Bylaska, Eric.Bylaska@pnl.gov





