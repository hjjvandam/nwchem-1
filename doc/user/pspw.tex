\label{sec:pspw}

A pseudopotential plane-wave (PSPW) module, also known as the Car-Parrinello 
method, is being implemented into the NWChem program package.  This module  
complements the capabilities of NWChem by including algorithms which allow 
for the calculation of density functional theory total energies and forces 
with the technology based on plane-wave basis sets and pseudopotentials.  
Consistent with NWChem's philosophy this module is able to run on a variety 
of architectures, including parallel supercomputers.

The advantage of a PSPW method is that it has been shown to have an accuracy 
close to chemical accuracy for many applications, yet is still fast enough 
to treat systems containing hundreds of atoms.  Another significant advantage 
is its ability to simulate dynamics on a ground state potential surface 
directly at run-time.  This method's efficiency and accuracy make it a 
desirable first principles method of simulation in the study of complex 
molecular, liquid, and solid state systems.  Applications for this first 
principles method include the calculation of free energies, search for 
global minima, explicit simulation of solvated molecules, and simulations 
of complex vibrational modes that cannot be described within the harmonic 
approximation.

The NWChem PSPW module is used to perform several types of calculations that
can be used in a simulation.  Specific input to these calculations are
provided using input sub-blocks contained in the compound PSPW  block
\begin{verbatim}
PSPW
   ...
END
\end{verbatim}
To perform an actual PSPW calculation the user in addition needs to include
the TASK directive in the input module.  Immediately following the 
TASK directive is the PSPW string, and after that an $<$operation$>$ string 
is required.  The TASK directive for PSPW calculations is of the following
form:
\begin{verbatim}
TASK PSPW [steepest_descent           ||
           Car-Parrinello             ||
           psp_formatter              ||
           wavefunction_initializer   ||
           v_wavefunction_initializer ||
           wavefunction_expander      ||
	   (no default)]
\end{verbatim}
The currently available operations are listed.  Future releases will
also contain Conjugate\_Gradient, CG\_MD, and wavefunction\_converter
operations.  Note that unlike most NWChem modules, the PSPW module does 
not contain an energy operation.  This means that there is no default
operation and hence an operation must always be specified.

The PSPW operations can be broken up into two types.  The first type of 
operation is used to setup or change needed data files of a simulation.  
Operations of this type are psp\_formatter, wavefunction\_initializer, 
v\_wavefunction\_initializer, and wavefunction\_expander.  The second type 
of operation is used to actually run a PSPW simulation.  Operations of this 
type are steepest\_descent, and Car-Parrinello.

In the following sections we describe how setup and run a steepest descent
simulation and a Car-Parrinello simulation.


\section{Running a STEEPEST\_DESCENT simulation} 

A workhorse of most PSPW simulations is a steepest descent code.  
The primary purpose of this code is to optimize the one-electron
orbitals with respect to the total energy.  However, in addition it
can also be used to optimize geometries. 

Before running a PSPW steepest\_descent simulation several files and
RTDB structures must be defined or initialized.  Specifically, the user 
is required to have defined the ion positions and simulation cell in the 
RTDB, a formatted pseudopotential file for each kind of ion, 
a file containing the one-electron orbitals, and lastly a 
steepest\_descent PSPW sub-block. 

Provided the RTDB and data files are correctly defined
the following TASK directive
\begin{verbatim}
TASK PSPW steepest_descent 
\end{verbatim}
will run the STEEPEST\_DESCENT module.


\subsection{STEEPEST\_DESCENT  sub-block}
The STEEPEST\_DESCENT sub-block is used to provide input to the
STEEPEST\_DESCENT simulations.  This sub-block contains a great deal
of input, including pointers to RTDB data, pointers to data, as well as
parameter input.  Listed below is the format of a STEEPEST\_DESCENT sub-block.
\begin{verbatim}
PSPW
...
   STEEPEST_DESCENT
      [CELL_NAME: <string cell_name>]
      [GEOMETRY_OPTIMIZE]
      [FORMATTED_FILENAME: <string formatted_name>]+
      [INPUT_WAVEFUNCTION_FILENAME:  <string input_wavefunctions>]
      [OUTPUT_WAVEFUNCTION_FILENAME: <string output_wavefunctions>]
      [FAKE_MASS: <real fake_mass>]
      [TIME_STEP: <real time_step>]
      [LOOP: <integer inner_iteration outer_iteration>]
      [TOLERANCES: <real tole tolc tolr>]
      [ENERGY_CUTOFF:       <real ecut>]
      [WAVEFUNCTION_CUTOFF: <real wcut>]
      [EWALD_NCUT: <integer ncut>]
      [EWALD_RCUT: <real rcut>]
   END
...

END
\end{verbatim}

The following list describes the input for the STEEPEST\_DESCENT
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - user-supplied name that points to the
              the simulation\_cell named $<$cell\_name$>$.
	\item GEOMETRY\_OPTIMIZE - optional keyword which if specified
	      turns on geometry optimization. 	
	\item $<$formatted\_name$>$ - user-supplied name that points
              to a formatted\_pseudopotential file.
	\item $<$input\_wavefuncitons$>$ - user-supplied name that points
              to a file containing one-electron orbitals
	\item $<$output\_wavefunctions$>$ - user-supplied name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
	\item $<$fake\_mass$>$ - user-supplied value for the electronic
              fake mass.  In the steepest descent code this parameter is
              used to define the steepest descent loop for the one-electron
              orbitals.
	\item $<$time\_step$>$ - user-supplied value for the time step.
               In the steepest descent code this parameter is used to
               define the steepest descent loop for the one-electron orbitals
               and ion positions (if GEOMETRY\_OPTIMIZE is specified).
	\item $<$inner\_iteration$>$ -
	\item $<$outer\_iteration$>$ -
 	\item $<$tole$>$ - user-supplied value for the energy tolerance.
	\item $<$tolc$>$ - user-supplied value for the one-electron orbital
                           tolerance.
	\item $<$tolr$>$ - user-supplied value for the ion position tolerance
	\item $<$ecut$>$ - user-supplied value for the cutoff energy used
                           to define the density.
	\item $<$wcut$>$ - user-supplied value for the cutoff energy used
 			   to define the one-electron orbitals.
	\item $<$ncut$>$ - user-supplied value for the number of unit cells
 			  to sum over (in each direction) for the real space
			  part of the Ewald summation.
	\item $<$rcut$>$ - user-supplied value for the cutoff radius used
			  in the Ewald summation.
\end{itemize}




\section{Running a Car-Parrinello simulation}

A Car-Parrinello simulation is used to perform an ab initio molecular
dynamics simulation.  

Before running a PSPW Car-Parrinello  simulation several files and
RTDB structures must be defined or initialized.  Specifically, the user 
is required to have defined the ion positions, ion velocities, and 
simulation cell in the RTDB, a formatted pseudopotential file for each 
kind of ion, a file containing the one-electron orbitals, a file containing 
the one-electron orbital velocities, and lastly a Car-Parrinello 
PSPW sub-block. 

Provided the RTDB and data files are correctly defined
the following TASK directive
\begin{verbatim}
TASK PSPW Car-Parrinello
\end{verbatim}
will run the Car-Parrinello module.


\subsection{Car-Parrinello  sub-block}
The Car-Parrinellosub-block is used to provide input to the
Car-Parrinello simulations.  This sub-block contains a great deal
of input, including pointers to RTDB data, pointers to data, as well as
parameter input.  Listed below is the format of a Car-Parrinello sub-block.
\begin{verbatim}
PSPW
...
   Car-Parrinello
      [CELL_NAME: <string cell_name>]
      [GEOMETRY_OPTIMIZE]
      [FORMATTED_FILENAME: <string formatted_name>]+
      [INPUT_WAVEFUNCTION_FILENAME:    <string input_wavefunctions>]
      [OUTPUT_WAVEFUNCTION_FILENAME:   <string output_wavefunctions>]
      [INPUT_V_WAVEFUNCTION_FILENAME:  <string input_v_wavefunctions>]
      [OUTPUT_V_WAVEFUNCTION_FILENAME: <string output_v_wavefunctions>]
      [FAKE_MASS: <real fake_mass>]
      [TIME_STEP: <real time_step>]
      [LOOP: <integer inner_iteration outer_iteration>]
      [SCALING: <real scale_c scale_r>]
      [ENERGY_CUTOFF:       <real ecut>]
      [WAVEFUNCTION_CUTOFF: <real wcut>]
      [EWALD_NCUT: <integer ncut>]
      [EWALD_RCUT: <real rcut>]
   END
...

END
\end{verbatim}

The following list describes the input for the Car-Parrinello
sub-block.
\begin{itemize}
	\item $<$cell\_name$>$ - user-supplied name that points to the
              the simulation\_cell named $<$cell\_name$>$.
	\item $<$formatted\_name$>$ - user-supplied name that points
              to a formatted\_pseudopotential file.
	\item $<$input\_wavefunctions$>$ - user-supplied name that points
              to a file containing one-electron orbitals
	\item $<$output\_wavefunctions$>$ - user-supplied name that will
              point to file containing the one-electron orbitals at the
              end of the run. 
	\item $<$input\_v\_wavefunctions$>$ - user-supplied name that points
              to a file containing one-electron orbital velocities.
	\item $<$output\_v\_wavefunctions$>$ - user-supplied name that will
              point to file containing the one-electron orbital velocities
	      at the end of the run. 
	\item $<$fake\_mass$>$ - user-supplied value for the electronic
              fake mass.  In the steepest descent code this parameter is
              used to define the steepest descent loop for the one-electron
              orbitals.
	\item $<$time\_step$>$ - user-supplied value for the time step.
               In the steepest descent code this parameter is used to
               define the steepest descent loop for the one-electron orbitals
               and ion positions (if GEOMETRY\_OPTIMIZE is specified).
	\item $<$inner\_iteration$>$ -
	\item $<$outer\_iteration$>$ -
 	\item $<$scale\_c$>$ - user-supplied value for the initial velocity
			      scaling of the one-electron orbital velocities.
	\item $<$scale\_r$>$ - user-supplied value for the initial velocity
			      scaling of the ion velocities.
	\item $<$ecut$>$ - user-supplied value for the cutoff energy used
                           to define the density.
	\item $<$wcut$>$ - user-supplied value for the cutoff energy used
 			   to define the one-electron orbitals.
	\item $<$ncut$>$ - user-supplied value for the number of unit cells
 			  to sum over (in each direction) for the real space
			  part of the Ewald summation.
	\item $<$rcut$>$ - user-supplied value for the cutoff radius used
			  in the Ewald summation.
\end{itemize}



\section{Specifying ion positions into the RTDB}

The positions of the ions are stored in the default geometry structure
in the RTDB.  
The positions of the ions must be specified in cartesian coordinates
using the GEOMETRY directive.

\section{Specifying ion velocities into the RTDB}

The velocities of the ions are stored in the default geometry structure
in the RTDB.
The velocities of the ions must be specified in cartesian coordinates
using the GEOMETRY directive.


\section{Specifying a Simulation Cell into the RTDB}

Simulation cells are stored in the RTDB.  To enter a  simulation cell
into the RTDB the user defines a simulation\_cell sub-block within the PSPW 
block.  Listed below is the format of a simulation\_cell sub-block.
\begin{verbatim}
PSPW

...

   SIMULATION_CELL
      CELL_NAME: <string name>
      BOUNDRY_CONDITIONS: (periodic || aperiodic)
      LATTICE_VECTORS:
        <real a1.x a1.y a1.z>
        <real a2.x a2.y a2.z>
        <real a3.x a3.y a3.z>
      NGRID: <integer na1 na2 na3>
   END

...

END
\end{verbatim}
Basically, the user needs to enter the dimensions, gridding and boundry
conditions of the simulation cell.  The following list describes the 
input in detail.
\begin{itemize}
	\item $<$name$>$ - user-supplied name for the simulation block.
	\item periodic - keyword specifying that the simulation cell 
	                 has periodic boundary conditions. 	
	\item aperiodic - keyword specifying that the simulation cell
		          has free-space boundary conditions.
	\item $<$a1.x a1.y a1.z$>$ - user-supplied values for the first lattice 
				 vector 
	\item $<$a2.x a2.y a2.z$>$ - user-supplied values for the second lattice
				 vector
	\item $<$a3.x a3.y a3.z$>$ - user-supplied values for the third lattice
			  	 vector
	\item $<$na1 na2 na3$>$ - user-supplied values for the discretization along
			      the lattice vector directions.
\end{itemize}



\section{Generating a Pseudopotential}

A one-dimensional pseudopotential code has been integrated into NWChem.
This code allows the user to modify and develop pseudopotentials.  Currently, 
only the Hamann and Troullier-Martins norm-conserving pseudopotentials can be
generated.  However, we plan to support other popular ones in the near future, 
including Rappe, Scheffler, and Vanderbilt's ultra-soft pseudopotentials.

Input to the one-dimensional pseudpotential code is provided using a
psp\_generator section.  Listed below is the format of a 
psp\_generator sub-block.
\begin{verbatim}
PSPW

...
 
   PSP_GENERATOR
      [PSEUDOPOTENTIAL_FILENAME: <string psp_name>]
      [ELEMENT: <string element>
      [CHARGE: (real charge>
      [MASS_NUMBER: <real mass_number>
      [ATOMIC_FILLING: <integer ncore nvalence>
       {n=(1||2||...) l=(s||p||d||f) <real filling[n,l]> i=1,(ncore+nvalence)}
      ]
      [CUTOFF: <integer lmax> \
         {l=(s||p||d||f||g) <real rcut[l]> i=1,lmax}
      ]
      [PSEUDOPOTENTIAL_TYPE: (troullier-martins||hamann)]
      [SOLVER_TYPE: (pauli||schrodinger)]
      [EXCHANGE_TYPE: dirac]
      [CORRELATION_TYPE: vosko]
   end

... 

END
\end{verbatim}

When this sub-block is encountered it will immediately generate a file called
$<$psp\_name$>$ (i.e. no task directive is needed).  This file can then
be used by the pseudopotential\_formatter task to generate a formatted
pseudopotential file. 


\section{Generating a Formatted Pseudopotential File}
Input to the  pseudpotential formatting code is provided using a
psp\_formatter section. 

\begin{verbatim}
PSPW

... 

   PSP_FORMATTER
      CELL_NAME:          <string cell_name> 
      PSP_FILENAME:       <string psp_name>
      FORMATTED_FILENAME: <string formatted_name>
      LOCP: (s||p||d||f)
      LMAX: (s||p||d||f||g)
   end

...

END
\end{verbatim}

Provided the RTDB and data files are correctly defined
the following TASK directive
\begin{verbatim}
TASK PSPW PSP\_FORMATTER.
\end{verbatim}


\section{Generating initial one-electron orbitals}

\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_INITIALIZER
     WAVEFUNCTION_FILENAME: <string wavefunction_name>
     CELL_NAME: <string cell_name>
     (RESTRICTED||UNRESTRICTED)
     UP_FILLING: <integer up_filling>
        [0 0 0 0   0]
        {<integer kx ky kz> (-1||1)}
     DOWN_FILLING: <integer down_filling>
        [0 0 0 0   0]
        {<integer kx ky kz> (-1||1)}
   END
...
END
\end{verbatim}


The TASK directive
\begin{verbatim}
TASK PSPW PSP\_FORMATTER.
\end{verbatim}




\section{Running the wavefunction expander}


\begin{verbatim}
PSPW
... 
   WAVEFUNCTION_EXPANDER   
     OLD_WAVEFUNCTION_FILENAME: <string old_wavefunction_name>
     NEW_WAVEFUNCTION_FILENAME: <string new_wavefunction_name>
     NEW_NGRID: <integer na1 na2 na3>
    
   END
...
END
\end{verbatim}



\section{Generating initial one-electron orbital velocities}

\begin{verbatim}
PSPW
... 
   V_WAVEFUNCTION_INITIALIZER
     V_WAVEFUNCTION_FILENAME: <string v_wavefunction_name>
     CELL_NAME: <string cell_name>
     (RESTRICTED||UNRESTRICTED)
     UP_FILLING: <integer up_filling>
     DOWN_FILLING: <integer down_filling>
   END
...
END
\end{verbatim}


\section{Format of the one-dimensional pseudopotential file}


The data stored in the one-dimensiona pseudopotential file is
\begin{verbatim}
   character*2 element       :: element name
   integer     charge        :: valence charge of ion
   real        mass          :: mass of ion
   integer     lmax          :: maximum angular component
   real        rcut(lmax)    :: cutoff radii used to define pseudopotentials
   integer     nr            :: number of points in the radial grid
   real        dr            :: linear spacing of the radial grid
   real        r(nr)         :: one-dimensional radial grid
   real        Vpsp(nr,lmax) :: one-dimensional pseudopotentials
   real        psi(nr,lmax)  :: one-dimensional pseudowavefunctions
\end{verbatim}
and the format of it is:
\begin{verbatim}
[line 1:     ] element	
[line 2:     ] charge mass lmax
[line 3:     ] (rcut(l), l=1,lmax)
[line 4:     ] nr dr
[line 5:     ]    r(1)  (Vpsp(1,l),  l=1,lmax)
[line 6:     ] ....
[line nr+4:  ] r(nr) (Vpsp(nr,l), l=1,lmax)
[line nr+5:  ] r(1)  (psi(1,l), l=1,lmax) 
[line nr+6:  ] ....
[line 2*nr+4:] r(nr) (psi(nr,l), l=1,lmax)
\end{verbatim}


\section{PSPW Capabilities}

This section list the technical capabilities for the PSPW code being 
implemented into NWChem.  The capabilities included in this pre-release
are highlighted, with the full implementation of the listed capabilities 
expected to be done by early winter of 1999.

\large
\textbf{Energies}
\normalsize

Many exchange-correlation potentials are implemented.
The following spin-dependent and spin-independent exchange-correlation
potentials are implemented.
\begin{itemize}
	\item \textbf{Vosko et al's parameterization of Ceperley and 
	       Alder's data (LDA/LSD)}
	\item Becke exchange, and Perdew and Wang correlation (RBP91/BP91)
	\item Becke exchange, and Lee, Yang and Parr correlation (RBLYP/BLYP)
\end{itemize} 

\large
\textbf{Energy Minimization}
\normalsize

Several methods are  available for minimizing the total energy functional
with respect to the ground state density (or 1-electron orbitals).
\begin{itemize}
	\item \textbf{Fixed step length steepest descent algorithm}
	\item Conjugate gradient on a Grassmann manifold algorithm.
	      This algorithm was developed by Edelman, Arias, and Smith.
\end{itemize}

\large
\textbf{Geometry Optimizations}
\normalsize

The nuclear coordinate forces are calculated analytically using the 
Hellman-Feynman theorem.  Using these forces we implemented the following
geometry optimization algorithms
\begin{itemize}
	\item \textbf{Fixed step length steepest descent algorithm}
	\item Newton-Raphson with density minimized via a conjugate
	      gradient algorithm
\end{itemize}

\large
\textbf{Molecular Dynamics}
\normalsize

The following constant energy molecular dynamics algorithms are implemented.
\begin{itemize}
	\item \textbf{Car-Parrinello (extened Lagrangian dynamics) algorithm}
	\item To allow the user to do molecular dynamics explicitly on
	      the Born-Oppenheimer surface we have implemented the Verlet
	      algorithm to integrate the nuclear coordinates equation of
	      motion and mimimize the density at each time step with
	      the conjugate gradient algorithm.
\end{itemize}

\large
\textbf{Pseudopotentials}
\normalsize

\begin{itemize}
	\item \textbf{Hamann norm-conserving pseudopotential}
	\item \textbf{Troullier-Martins norm-conserving pseudopotential}
	\item Rappe norm-conserving pseudopotential
	\item Scheffler
	\item Vanderbilt's ultra-soft pseudopotentials
	\item core-corrections	
	\item spin-dependent potentials
\end{itemize}


\large
\textbf{Simulations Cells}
\normalsize

\begin{itemize}
	\item \textbf{periodic boundary conditions}
	\item free-space boundary conditions
	\item general orthorhombic dimensions
\end{itemize}

\section{Acknowledgements}

Encountered problems should be reported to 
Eric J. Bylaska, eric.bylaska@pnl.gov




